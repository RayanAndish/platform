### File: /home/errick/core/funding.json ###
{
  "opRetro": {
    "projectId": "0xa08c7ab7824d147d6cb87ffb4e86cec454a030d48b8c395bad6d64456be3d911"
  }
}


### File: /home/errick/core/package.json ###
{
  "name": "DAO-VC",
  "version": "0.1.0",
  "description": "Rayan DAO Framework",
  "repository": "https://github.com/aragon/osx",
  "author": "Erfan Shamohammadi Heydari",
  "license": "MIT-3.0-or-later",
  "private": true,
  "workspaces": {
    "packages": [
      "packages/*"
    ],
    "nohoist": [
      "**/@graphprotocol/graph-ts",
      "**/@graphprotocol/graph-ts/**",
      "**/@graphprotocol/graph-cli",
      "**/@graphprotocol/graph-cli/**",
      "**/matchstick-as",
      "**/matchstick-as/**",
      "**/@aragon/osx-commons-subgraph",
      "**/@aragon/osx-commons-subgraph/**"
    ]
  },
  "scripts": {
    "start": "react-scripts start --host 0.0.0.0 --port 3000",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },

  "devDependencies": {
    "@trivago/prettier-plugin-sort-imports": "^4.2.0",
    "prettier-plugin-solidity": "^1.1.3",
    "prettier": "^2.8.8"
  }
}


### File: /home/errick/core/core-content.txt ###


### File: /home/errick/core/crowdin.yml ###
files:
  - source: /packages/web-app/src/languages/en/*.json
    translation: /packages/web-app/src/languages/%two_letters_code%/%original_file_name%.json


### File: /home/errick/core/.mythx.yml ###
analyze:
  create-group: true
  group-name: Core
  solc: 0.8.20
  remappings:
    - '@openzeppelin/=./node_modules/@openzeppelin/'
    - '@opengsn/=./node_modules/@opengsn/'
    - '@ensdomains/=./node_modules/@ensdomains/'


### File: /home/errick/core/LICENSE ###
# GNU Affero General Public License

_Version 3, 19 November 2007_
_Copyright © 2007 Free Software Foundation, Inc. &lt;<https://fsf.org/>&gt;_

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

## Preamble

The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works. By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.

When we speak of free software, we are referring to freedom, not
price. Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

Developers that use our General Public Licenses protect your rights
with two steps: **(1)** assert copyright on the software, and **(2)** offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.

A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate. Many developers of free software are heartened and
encouraged by the resulting cooperation. However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.

The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community. It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server. Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.

An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals. This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.

The precise terms and conditions for copying, distribution and
modification follow.

## TERMS AND CONDITIONS

### 0. Definitions

“This License” refers to version 3 of the GNU Affero General Public License.

“Copyright” also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

“The Program” refers to any copyrightable work licensed under this
License. Each licensee is addressed as “you”. “Licensees” and
“recipients” may be individuals or organizations.

To “modify” a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy. The resulting work is called a “modified version” of the
earlier work or a work “based on” the earlier work.

A “covered work” means either the unmodified Program or a work based
on the Program.

To “propagate” a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy. Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

To “convey” a work means any kind of propagation that enables other
parties to make or receive copies. Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

An interactive user interface displays “Appropriate Legal Notices”
to the extent that it includes a convenient and prominently visible
feature that **(1)** displays an appropriate copyright notice, and **(2)**
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License. If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

### 1. Source Code

The “source code” for a work means the preferred form of the work
for making modifications to it. “Object code” means any non-source
form of a work.

A “Standard Interface” means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

The “System Libraries” of an executable work include anything, other
than the work as a whole, that **(a)** is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and **(b)** serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form. A
“Major Component”, in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

The “Corresponding Source” for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities. However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work. For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

The Corresponding Source for a work in source code form is that
same work.

### 2. Basic Permissions

All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met. This License explicitly affirms your unlimited
permission to run the unmodified Program. The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work. This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force. You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright. Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under
the conditions stated below. Sublicensing is not allowed; section 10
makes it unnecessary.

### 3. Protecting Users' Legal Rights From Anti-Circumvention Law

No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

### 4. Conveying Verbatim Copies

You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

### 5. Conveying Modified Source Versions

You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

- **a)** The work must carry prominent notices stating that you modified
  it, and giving a relevant date.
- **b)** The work must carry prominent notices stating that it is
  released under this License and any conditions added under section 7.
  This requirement modifies the requirement in section 4 to
  “keep intact all notices”.
- **c)** You must license the entire work, as a whole, under this
  License to anyone who comes into possession of a copy. This
  License will therefore apply, along with any applicable section 7
  additional terms, to the whole of the work, and all its parts,
  regardless of how they are packaged. This License gives no
  permission to license the work in any other way, but it does not
  invalidate such permission if you have separately received it.
- **d)** If the work has interactive user interfaces, each must display
  Appropriate Legal Notices; however, if the Program has interactive
  interfaces that do not display Appropriate Legal Notices, your
  work need not make them do so.

A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
“aggregate” if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit. Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

### 6. Conveying Non-Source Forms

You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

- **a)** Convey the object code in, or embodied in, a physical product
  (including a physical distribution medium), accompanied by the
  Corresponding Source fixed on a durable physical medium
  customarily used for software interchange.
- **b)** Convey the object code in, or embodied in, a physical product
  (including a physical distribution medium), accompanied by a
  written offer, valid for at least three years and valid for as
  long as you offer spare parts or customer support for that product
  model, to give anyone who possesses the object code either **(1)** a
  copy of the Corresponding Source for all the software in the
  product that is covered by this License, on a durable physical
  medium customarily used for software interchange, for a price no
  more than your reasonable cost of physically performing this
  conveying of source, or **(2)** access to copy the
  Corresponding Source from a network server at no charge.
- **c)** Convey individual copies of the object code with a copy of the
  written offer to provide the Corresponding Source. This
  alternative is allowed only occasionally and noncommercially, and
  only if you received the object code with such an offer, in accord
  with subsection 6b.
- **d)** Convey the object code by offering access from a designated
  place (gratis or for a charge), and offer equivalent access to the
  Corresponding Source in the same way through the same place at no
  further charge. You need not require recipients to copy the
  Corresponding Source along with the object code. If the place to
  copy the object code is a network server, the Corresponding Source
  may be on a different server (operated by you or a third party)
  that supports equivalent copying facilities, provided you maintain
  clear directions next to the object code saying where to find the
  Corresponding Source. Regardless of what server hosts the
  Corresponding Source, you remain obligated to ensure that it is
  available for as long as needed to satisfy these requirements.
- **e)** Convey the object code using peer-to-peer transmission, provided
  you inform other peers where the object code and Corresponding
  Source of the work are being offered to the general public at no
  charge under subsection 6d.

A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

A “User Product” is either **(1)** a “consumer product”, which means any
tangible personal property which is normally used for personal, family,
or household purposes, or **(2)** anything designed or sold for incorporation
into a dwelling. In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage. For a particular
product received by a particular user, “normally used” refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product. A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

“Installation Information” for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source. The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information. But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed. Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

### 7. Additional Terms

“Additional permissions” are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law. If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it. (Additional permissions may be written to require their own
removal in certain cases when you modify the work.) You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

- **a)** Disclaiming warranty or limiting liability differently from the
  terms of sections 15 and 16 of this License; or
- **b)** Requiring preservation of specified reasonable legal notices or
  author attributions in that material or in the Appropriate Legal
  Notices displayed by works containing it; or
- **c)** Prohibiting misrepresentation of the origin of that material, or
  requiring that modified versions of such material be marked in
  reasonable ways as different from the original version; or
- **d)** Limiting the use for publicity purposes of names of licensors or
  authors of the material; or
- **e)** Declining to grant rights under trademark law for use of some
  trade names, trademarks, or service marks; or
- **f)** Requiring indemnification of licensors and authors of that
  material by anyone who conveys the material (or modified versions of
  it) with contractual assumptions of liability to the recipient, for
  any liability that these contractual assumptions directly impose on
  those licensors and authors.

All other non-permissive additional terms are considered “further
restrictions” within the meaning of section 10. If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term. If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

### 8. Termination

You may not propagate or modify a covered work except as expressly
provided under this License. Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated **(a)**
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and **(b)** permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License. If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

### 9. Acceptance Not Required for Having Copies

You are not required to accept this License in order to receive or
run a copy of the Program. Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance. However,
nothing other than this License grants you permission to propagate or
modify any covered work. These actions infringe copyright if you do
not accept this License. Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

### 10. Automatic Licensing of Downstream Recipients

Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License. You are not responsible
for enforcing compliance by third parties with this License.

An “entity transaction” is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations. If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License. For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

### 11. Patents

A “contributor” is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based. The
work thus licensed is called the contributor's “contributor version”.

A contributor's “essential patent claims” are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version. For
purposes of this definition, “control” includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

In the following three paragraphs, a “patent license” is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement). To “grant” such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either **(1)** cause the Corresponding Source to be so
available, or **(2)** arrange to deprive yourself of the benefit of the
patent license for this particular work, or **(3)** arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients. “Knowingly relying” means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

A patent license is “discriminatory” if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License. You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license **(a)** in connection with copies of the covered work
conveyed by you (or copies made from those copies), or **(b)** primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

### 12. No Surrender of Others' Freedom

If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License. If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all. For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

### 13. Remote Network Interaction; Use with the GNU General Public License

Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software. This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.

Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work. The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.

### 14. Revised Versions of this License

The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time. Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number. If the
Program specifies that a certain numbered version of the GNU Affero General
Public License “or any later version” applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation. If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.

If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

Later license versions may give you additional or different
permissions. However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

### 15. Disclaimer of Warranty

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS” WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

### 16. Limitation of Liability

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

### 17. Interpretation of Sections 15 and 16

If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

_END OF TERMS AND CONDITIONS_

## How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the “copyright” line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source. For example, if your program is a web application, its
interface could display a “Source” link that leads users to an archive
of the code. There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.

You should also get your employer (if you work as a programmer) or school,
if any, to sign a “copyright disclaimer” for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
&lt;<https://www.gnu.org/licenses/>&gt;.


### File: /home/errick/core/dummy_daos.json ###
{
  "goerli": {
    "dao": {
      "AddresslistVoting": {
        "tx": "0x27f0d2ab1cf88446560b9bfeed5d5d0bd25b273861aeb420c773d4f9e5ba0f81",
        "name": "DummyDAO_Addresslist_Voting_1665145900111",
        "votingType": "AddresslistVoting",
        "address": "0xB2476e2499146F94138bad830c087Bb4B25ca200",
        "token": "0x0000000000000000000000000000000000000000",
        "voting": "0x4165676689f6af99580250759C62295D1112e749",
        "deposits": [
          {
            "approveTx": "",
            "depositTx": "0x14745ac709b26aa08873ba478cfe4f1e6b936950a56bc9951844cebb5a34fdd5",
            "tokenName": "ETH",
            "token": "0x0000000000000000000000000000000000000000",
            "amount": "0.001",
            "dao": "0xB2476e2499146F94138bad830c087Bb4B25ca200"
          }
        ],
        "proposal": {
          "proposalTx": "0x8a3d6fa71ccea5b0e1374051b06a4ceefbdee5eb708fc454885516ece5d7bef2",
          "metadata": {
            "name": "AddresslistVoting Dummy Proposal",
            "description": "Dummy withdraw proposal for QA and testing purposes...",
            "links": [
              {
                "label": "link01",
                "url": "https://link.01"
              },
              {
                "label": "link02",
                "url": "https://link.02"
              }
            ]
          },
          "dao": "0xB2476e2499146F94138bad830c087Bb4B25ca200"
        }
      },
      "ERC20Voting": {
        "tx": "0x06a452a2f39cf9c9aa10a17d584825a381e977fd6b52c18c334ad620da2fb9ee",
        "name": "DummyDAO_ERC20_Voting_1665146531157",
        "votingType": "ERC20Voting",
        "address": "0x665F8442B77Aef44644d64E8774e6E3731673e48",
        "token": "0xC69ccfB572F55416843D0371d2fF5e7eD3A6cBf1",
        "voting": "0xf90da85CADC194dF8deeA3cd9e8e7De04051C431",
        "deposits": [
          {
            "approveTx": "",
            "depositTx": "0x008d4a5189521322519e33cb1a8e631eb0a99ea926df6fe0ad0f37fee35ae14c",
            "tokenName": "ETH",
            "token": "0x0000000000000000000000000000000000000000",
            "amount": "0.001",
            "dao": "0x665F8442B77Aef44644d64E8774e6E3731673e48"
          }
        ],
        "proposal": {
          "proposalTx": "0x1196980928a0cd803c79a141738e21016479b6105b4aac1c26257fe7c33506a0",
          "metadata": {
            "name": "ERC20Voting Dummy Proposal",
            "description": "Dummy withdraw proposal for QA and testing purposes...",
            "links": [
              {
                "label": "link01",
                "url": "https://link.01"
              },
              {
                "label": "link02",
                "url": "https://link.02"
              }
            ]
          },
          "dao": "0x665F8442B77Aef44644d64E8774e6E3731673e48"
        }
      }
    }
  }
}


### File: /home/errick/core/images/dao-plugin.svg ###
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="441" height="282" viewBox="-0.5 -0.5 441 282"><rect width="280" height="80" x="80" fill="#dae8fc" stroke="#6c8ebf" pointer-events="all" rx="12" ry="12"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe flex-start;justify-content:unsafe center;width:278px;height:1px;padding-top:7px;margin-left:81px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:12px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal">DAO</div></div></div></foreignObject><text x="220" y="19" font-family="Helvetica" font-size="12" text-anchor="middle">
                    DAO
                </text></switch><path fill="none" stroke="#000" stroke-miterlimit="10" d="M120 160V85.78" pointer-events="stroke"/><path stroke="#000" stroke-miterlimit="10" d="m120 80.53 3.5 7-3.5-1.75-3.5 1.75Z" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:120px;margin-left:120px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap">execute()</div></div></div></foreignObject><text x="120" y="123" font-family="Helvetica" font-size="11" text-anchor="middle">
                    execute()
                </text></switch><rect width="80" height="40" x="80" y="160" fill="#d5e8d4" stroke="#82b366" pointer-events="all" rx="6" ry="6"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:78px;height:1px;padding-top:180px;margin-left:81px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:12px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal">Token Voting<br/>Plugin</div></div></div></foreignObject><text x="120" y="184" font-family="Helvetica" font-size="12" text-anchor="middle">
                    Token Voting...
                </text></switch><rect width="80" height="40" x="180" y="30" fill="#f8cecc" stroke="#b85450" pointer-events="all" rx="6" ry="6"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:78px;height:1px;padding-top:50px;margin-left:181px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:12px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal">Permission<br/>Manager</div></div></div></foreignObject><text x="220" y="54" font-family="Helvetica" font-size="12" text-anchor="middle">
                    Permission...
                </text></switch><path fill="none" stroke="#f33" stroke-dasharray="3 3" stroke-miterlimit="10" d="M205 120h-48.63" pointer-events="stroke"/><path fill="#f33" stroke="#f33" stroke-miterlimit="10" d="m151.12 120 7-3.5-1.75 3.5 1.75 3.5Z" pointer-events="all"/><path fill="none" stroke="#000" stroke-miterlimit="10" d="M120 250v-43.63" pointer-events="stroke"/><path stroke="#000" stroke-miterlimit="10" d="m120 201.12 3.5 7-3.5-1.75-3.5 1.75Z" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:230px;margin-left:120px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap">createProposal()</div></div></div></foreignObject><text x="120" y="233" font-family="Helvetica" font-size="11" text-anchor="middle">
                    createProposal()
                </text></switch><circle cx="120" cy="265" r="15" fill="#FFF" stroke="#000" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:28px;height:1px;padding-top:265px;margin-left:106px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:20px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal"><p class="p1" style="margin:0;font-variant-numeric:normal;font-variant-east-asian:normal;font-stretch:normal;line-height:normal;font-family:&quot;.Apple Color Emoji UI&quot;;text-align:start"><font style="font-size:5px"/><font style="font-size:20px">🧑‍💼</font></p></div></div></div></foreignObject><text x="120" y="271" font-family="Helvetica" font-size="20" text-anchor="middle">
                    🧑‍💼
                </text></switch><path fill="none" stroke="#000" stroke-miterlimit="10" d="M220 250v-70h-53.63" pointer-events="stroke"/><path stroke="#000" stroke-miterlimit="10" d="m161.12 180 7-3.5-1.75 3.5 1.75 3.5Z" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:180px;margin-left:220px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap">changeSettings()</div></div></div></foreignObject><text x="220" y="183" font-family="Helvetica" font-size="11" text-anchor="middle">
                    changeSettings()
                </text></switch><circle cx="220" cy="265" r="15" fill="#FFF" stroke="#000" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:28px;height:1px;padding-top:265px;margin-left:206px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:20px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal"><font style="font-size:5px"/><font style="font-size:20px">🧑‍🔧</font></div></div></div></foreignObject><text x="220" y="271" font-family="Helvetica" font-size="20" text-anchor="middle">
                    🧑‍🔧
                </text></switch><path fill="none" stroke="#f33" stroke-dasharray="3 3" stroke-miterlimit="10" d="M220 135v28.63" pointer-events="stroke"/><path fill="#f33" stroke="#f33" stroke-miterlimit="10" d="m220 168.88-3.5-7 3.5 1.75 3.5-1.75Z" pointer-events="all"/><rect width="80" height="40" x="280" y="160" fill="#d5e8d4" stroke="#82b366" pointer-events="all" rx="6" ry="6"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:78px;height:1px;padding-top:180px;margin-left:281px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:12px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal">DeFi<br/>Plugin</div></div></div></foreignObject><text x="320" y="184" font-family="Helvetica" font-size="12" text-anchor="middle">
                    DeFi...
                </text></switch><path fill="none" stroke="#f33" stroke-dasharray="3 3" stroke-miterlimit="10" d="M220 70v35" pointer-events="stroke"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:90px;margin-left:220px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap"><font color="#f33">hasPermission()</font></div></div></div></foreignObject><text x="220" y="93" font-family="Helvetica" font-size="11" text-anchor="middle">
                    hasPermission()
                </text></switch><path fill="none" stroke="#000" stroke-miterlimit="10" d="M320 160v-40h33.63" pointer-events="stroke"/><path stroke="#000" stroke-miterlimit="10" d="m358.88 120-7 3.5 1.75-3.5-1.75-3.5Z" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:120px;margin-left:320px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap">invest()</div></div></div></foreignObject><text x="320" y="123" font-family="Helvetica" font-size="11" text-anchor="middle">
                    invest()
                </text></switch><path fill="none" stroke="#f33" stroke-dasharray="3 3" stroke-miterlimit="10" d="M235 120h48.63" pointer-events="stroke"/><path fill="#f33" stroke="#f33" stroke-miterlimit="10" d="m288.88 120-7 3.5 1.75-3.5-1.75-3.5Z" pointer-events="all"/><circle cx="320" cy="265" r="15" fill="#FFF" stroke="#000" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:28px;height:1px;padding-top:265px;margin-left:306px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:20px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal"><font style="font-size:5px"/><span style="font-family:&quot;.Apple Color Emoji UI&quot;;text-align:start;background-color:initial"><font style="font-size:20px">🧑‍🌾</font></span></div></div></div></foreignObject><text x="320" y="271" font-family="Helvetica" font-size="20" text-anchor="middle">
                    🧑‍🌾
                </text></switch><path fill="none" stroke="#000" stroke-miterlimit="10" d="M320 250v-43.63" pointer-events="stroke"/><path stroke="#000" stroke-miterlimit="10" d="m320 201.12 3.5 7-3.5-1.75-3.5 1.75Z" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:1px;height:1px;padding-top:230px;margin-left:320px"><div data-drawio-colors="color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:11px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;background-color:#fff;white-space:nowrap">depositTokens()</div></div></div></foreignObject><text x="320" y="233" font-family="Helvetica" font-size="11" text-anchor="middle">
                    depositTokens()
                </text></switch><circle cx="220" cy="120" r="15" fill="#FFF" stroke="#000" pointer-events="all"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe flex-start;justify-content:unsafe center;width:28px;height:1px;padding-top:112px;margin-left:206px"><div data-drawio-colors="color: rgb(0, 0, 0);" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:20px;font-family:Helvetica;color:#000;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal"><p class="p1" style="margin:0;font-variant-numeric:normal;font-variant-east-asian:normal;font-stretch:normal;line-height:100%;text-align:start"><font style="font-size:7px"/><font style="font-size:20px">🛡</font></p></div></div></div></foreignObject><text x="220" y="132" font-family="Helvetica" font-size="20" text-anchor="middle">
                    🛡
                </text></switch><rect width="80" height="40" x="360" y="100" fill="#FFF" stroke="#666" pointer-events="all" rx="6" ry="6"/><switch transform="translate(-.5 -.5)"><foreignObject width="100%" height="100%" pointer-events="none" requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility" style="overflow:visible;text-align:left"><div xmlns="http://www.w3.org/1999/xhtml" style="display:flex;align-items:unsafe center;justify-content:unsafe center;width:78px;height:1px;padding-top:120px;margin-left:361px"><div data-drawio-colors="color: #FF3333;" style="box-sizing:border-box;font-size:0;text-align:center"><div style="display:inline-block;font-size:12px;font-family:Helvetica;color:#f33;line-height:1.2;pointer-events:all;white-space:normal;overflow-wrap:normal"><font color="#666">external contract</font></div></div></div></foreignObject><text x="400" y="124" fill="#F33" font-family="Helvetica" font-size="12" text-anchor="middle">
                    external cont...
                </text></switch><rect width="80" height="40" y="100" fill="none" pointer-events="all" rx="6" ry="6"/><switch><g requiredFeatures="http://www.w3.org/TR/SVG11/feature#Extensibility"/><a xlink:href="https://www.diagrams.net/doc/faq/svg-export-text-problems" target="_blank" transform="translate(0 -5)"><text x="50%" y="100%" font-size="10" text-anchor="middle">
                Text is not SVG - cannot display
            </text></a></switch></svg>

### File: /home/errick/core/audits/Halborn_AragonOSx_2023-06-13.pdf ###
Error reading file: 'utf-8' codec can't decode byte 0xe4 in position 10: invalid continuation byte

### File: /home/errick/core/audits/Code4rena_AragonOSx_2023-12-12.pdf ###
Error reading file: 'utf-8' codec can't decode byte 0xd3 in position 10: invalid continuation byte

### File: /home/errick/core/audits/Halborn_AragonOSx_2023-02-24.pdf ###
Error reading file: 'utf-8' codec can't decode byte 0xe4 in position 10: invalid continuation byte

### File: /home/errick/core/audits/Halborn_AragonOSx_v1_4_Smart_Contract_Security_Assessment_Report_2025_01_03.pdf ###
Error reading file: 'utf-8' codec can't decode byte 0xd3 in position 10: invalid continuation byte

### File: /home/errick/core/packages/subgraph/tsconfig.json ###
{
  "extends": "@graphprotocol/graph-ts/types/tsconfig.base.json",
  "include": ["src"]
}


### File: /home/errick/core/packages/subgraph/package.json ###
{
  "name": "@aragon/osx-subgraph",
  "version": "1.4.1",
  "description": "The Aragon OSx Subgraph",
  "homepage": "https://github.com/aragon/osx",
  "license": "AGPL-3.0-or-later",
  "scripts": {
    "lint": "eslint . --ext .ts",
    "build:contracts": "cd ../contracts && yarn build",
    "manifest": "scripts/build-manifest.sh",
    "updateLocalManifest": "yarn node scripts/updateLocalManifest.js",
    "extend:schema": "yarn ts-node tests/schema-extender.ts",
    "build": "scripts/build-subgraph.sh && yarn extend:schema",
    "deploy": "scripts/deploy-subgraph.sh",
    "create:local": "graph create aragon/aragon-core-goerli --node http://localhost:8020",
    "deploy:local": "LOCAL=true scripts/deploy-subgraph.sh",
    "generate:introspection": "scripts/tests/generate-introspection-json.sh",
    "generate:introspection:partial": "scripts/docs/generate-introspection-partial-json.sh",
    "docs:examples": "node ./scripts/docs/generate-markdown.js ./src/examples && rsync -avr --prune-empty-dirs --remove-source-files --include='*/' --include='*.md' --exclude='*' ./src/examples/ ./docs/developer-portal/ --delete;",
    "start:dev": "docker-compose -f docker/docker-compose.yml up -d && sleep 30 && yarn create:local && yarn deploy:local",
    "stop:dev": "docker-compose -f docker/docker-compose.yml down",
    "buildAndStart:dev": "docker-compose -f docker/docker-compose.yml up -d --build hardhat && sleep 30 && yarn create:local && yarn deploy:local",
    "test:fast": "graph test",
    "test": "graph test -r",
    "coverage": "graph test -c"
  },
  "devDependencies": {
    "@graphprotocol/graph-cli": "0.52.0",
    "@graphprotocol/graph-ts": "^0.27.0",
    "@typescript-eslint/eslint-plugin": "^5.18.0",
    "@typescript-eslint/parser": "^5.18.0",
    "eslint": "^8.12.0",
    "matchstick-as": "^0.5.2",
    "mustache": "^4.2.0",
    "ts-morph": "^17.0.1",
    "typescript": "^4.9.5",
    "graphql": "^16.8.1",
    "@graphql-codegen/cli": "^5.0.2",
    "@graphql-codegen/introspection": "^4.0.3"
  },
  "dependencies": {
    "@aragon/osx-commons-subgraph": "^0.0.4"
  }
}


### File: /home/errick/core/packages/subgraph/.eslintrc.json ###
{
  "extends": ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaVersion": "latest"
  },
  "plugins": ["@typescript-eslint"],
  "rules": {
    "prefer-const": "off",
    "@typescript-eslint/no-inferrable-types": "off"
  }
}


### File: /home/errick/core/packages/subgraph/.env-example ###
SUBGRAPH_NAME=< osx >
NETWORK_NAME=< mumbai || goerli || localhost ...etc >
SUBGRAPH_VERSION=< version >
GRAPH_KEY=< subgraph key >




### File: /home/errick/core/packages/subgraph/codegen.yml ###
generates:
  ./docs/schema-introspection-partial.json:
    schema: ./schema.tmp.graphql
    plugins:
      - introspection


### File: /home/errick/core/packages/subgraph/schema.graphql ###
# Types

#############################
########## Tokens ###########
#############################

"""
Interface representing a generic token. Each entity implementing this interface can be queried as Token.
"""
interface Token {
  " The address of the Token Smart Contract. "
  id: ID!

  " The name of the token, mirrored from the smart contract. "
  name: String

  " The symbol of the token, mirrored from the smart contract. "
  symbol: String
}

"""
An [ERC20 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-20), of type Token.
"""
type ERC20Contract implements Token @entity(immutable: true) {
  " The address of the [ERC20 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-20). "
  id: ID!

  " The name of the token, mirrored from the smart contract. "
  name: String

  " The symbol of the token, mirrored from the smart contract. "
  symbol: String

  " The number of decimals of the token, mirrored from the smart contract. "
  decimals: Int!
}

"""
[ERC721 Token Standard](https://eips.ethereum.org/EIPS/eip-721), Non-Fungible Token (NFT), of type Token.
"""
type ERC721Contract implements Token @entity(immutable: true) {
  " The address of the [ERC721 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-721). "
  id: ID!

  " The name of the token, mirrored from the smart contract. "
  name: String

  " The symbol of the token, mirrored from the smart contract. "
  symbol: String
}

"""
[ERC1155 Multi-Token Standard](https://eips.ethereum.org/EIPS/eip-1155), fungible, non-fungible, and semi-fungible tokens all in one contract,
type of Token.
"""
type ERC1155Contract implements Token @entity(immutable: true) {
  " The address of the [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  id: ID!

  " The name of the [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  name: String

  " The symbol of the [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  symbol: String
}

###########################
##### Token Balances ######
###########################

"""
Balance of the DAO for any kind of token. Each entity implementing this interface can be queried as TokenBalance.
"""
interface TokenBalance {
  " The concatenation of DAO Smart contract address and Token Smart Contract address. Joined by '_'. "
  id: ID!

  " The DAO that holds the Tokens"
  dao: Dao!

  " The block timestamp of the last update (transfer) for this token balance. "
  lastUpdated: BigInt!
}

"""
The ERC20 Token balances for the DAO.
"""
type ERC20Balance implements TokenBalance @entity {
  " The concatenation of DAO Smart contract address and Token Smart contract address. Joined by '_'. "
  id: ID!

  " The [ERC20 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-20) instance. "
  token: ERC20Contract!

  " The DAO that holds the ERC20 token. "
  dao: Dao!

  " The amount of ERC20 tokens held by the DAO. "
  balance: BigInt!

  " The block timestamp of the last update (transfer) for this token balance. "
  lastUpdated: BigInt!
}

"""
The Native token balances of the DAO, representing the amount of the blockchain's native currency
(e.g., Ether on Ethereum, MATIC on Polygon) held by the DAO.
"""
type NativeBalance implements TokenBalance @entity {
  " The concatenation of DAO Smart contract address and Token Smart contract address. Joined by '_'. "
  id: ID!

  " The DAO that holds the native tokens"
  dao: Dao!

  " The amount of native tokens held by the DAO. "
  balance: BigInt!

  " The block timestamp of the last update (transfer) for this native token balance. "
  lastUpdated: BigInt!
}

"""
The NFT balances of the DAO. Including all Token IDs held by the DAO per [ERC721 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-721).
"""
type ERC721Balance implements TokenBalance @entity {
  " The concatenation of DAO Smart Contract address and [ERC721 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-721) address. Joined by '_'. "
  id: ID!

  " The [ERC721 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-721) instance. "
  token: ERC721Contract!

  " The DAO that holds tokens from a [ERC721 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-721). "
  dao: Dao!

  " The NFTs from one ERC721 Contract held by the DAO. "
  tokenIds: [BigInt!]!

  " The block timestamp of the last update (transfer) for this token balance. "
  lastUpdated: BigInt!
}

"""
The ERC1155 Token balances of the DAO. Including all Token IDs and it's amounts held by the DAO per [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155).
"""
type ERC1155Balance implements TokenBalance @entity {
  " The concatenation of DAO Smart Contract address and [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155) address. Joined by '_'. "
  id: ID!

  " The [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155) instance. "
  token: ERC1155Contract!

  " The DAO that holds tokens from a [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  dao: Dao!

  " Balance for each token ID from an [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  balances: [ERC1155TokenIdBalance!]! @derivedFrom(field: "balance")

  " The URI of the [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155). "
  metadataUri: String!

  " The block timestamp of the last update (transfer) for this token balance. "
  lastUpdated: BigInt!
}

"""
The DAO token balance for each token within an [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155)
"""
type ERC1155TokenIdBalance @entity {
  " The concatenation of DAO Smart Contract address, [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155) and token ID. Joined by '_'. "
  id: ID!

  " One to Many relationship linking with ERC1155Balance entity. "
  balance: ERC1155Balance!

  " The ID for each different token in an [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155) held by the DAO. "
  tokenId: BigInt!

  " The number of tokens held by the DAO per [ERC1155 Token Smart Contract](https://eips.ethereum.org/EIPS/eip-1155) and token ID. "
  amount: BigInt!

  " The block timestamp of the last update (transfer) for this token balance. "
  lastUpdated: BigInt!
}

###########################
##### Token Transfers #####
###########################

"""
Classifies the types of transfers from the DAO's point of view.
"""
enum TransferType {
  """
  When a DAO facilitates a transfer and neither the source nor the destination addresses match the DAO's. The DAO must
  have token approval to execute the transfer via proposal, acting as an intermediary in the process.
  """
  ExternalTransfer

  " A withdrawal form the DAO treasury. Executed by the DAO via proposal calling `transfer`. "
  Withdraw

  """
  A deposit to the DAO treasury. Using either the DAO `deposit` function or executed by the DAO via proposal calling `transferFrom` as an action to transfer to itself.
  The DAO must have token approval.
  """
  Deposit
}

"""
Interface representing a generic token transfer associated with the DAO. Each entity implementing this interface can be queried as TokenTransfer (refer to `Enum` `TransferType` for a better understanding of transfers associated with the DAO meaning).
"""
interface TokenTransfer {
  " The concatenation of the transfer transaction hash, the log index and the action index. Joined by '_'. "
  id: ID!

  " The DAO that manages the transfer. "
  dao: Dao!

  " The Ethereum address from which the tokens are being transferred. "
  from: Bytes!

  " The Ethereum address receiving the transfer. "
  to: Bytes!

  " The type of transfer (External, Withdraw, Deposit) from the DAO's POV. "
  type: TransferType!

  " The associated Execution container on the DAO, if applicable. If deposited using the DAO `deposit` function then will be empty. "
  actionBatch: ActionBatch

  " The hash of the transfer to track the transaction. "
  txHash: Bytes!

  " The timestamp of the block including transfer. "
  createdAt: BigInt!
}

"""
Transfers of ERC20 token associated with the DAO, including transfers sent to, received by, or intermediated by the DAO (refer to `Enum` `TransferType` for a better understanding of transfers associated with the DAO meaning).
"""
type ERC20Transfer implements TokenTransfer @entity(immutable: true) {
  " The concatenation of the transfer transaction hash, the log index and the action index. Joined by '_'. "
  id: ID!

  " The DAO that manages the transfer. "
  dao: Dao!

  " The ERC20 Smart Contract Token entity involved in the transfer. "
  token: Token!

  " The amount of ERC20 token transferred. "
  amount: BigInt!

  " The Ethereum address from which the ERC20 tokens are being transferred. "
  from: Bytes!

  " The Ethereum address receiving the ERC20 tokens. "
  to: Bytes!

  " The associated DAO transaction, if applicable. If deposited Using the DAO `deposit` function then will be empty "
  actionBatch: ActionBatch

  " The type of transfer (External, Withdraw, Deposit) from the DAO's POV. "
  type: TransferType!

  " The hash of the ERC20 token transfer to track the transaction. "
  txHash: Bytes!

  " The timestamp of the block including the ERC20 token transfer. "
  createdAt: BigInt!
}

"""
Transfers of ERC721 token associated with the DAO, including transfers sent to, received by, or intermediated by the DAO (refer to `Enum` `TransferType` for a better understanding of transfers associated with the DAO meaning).
"""
type ERC721Transfer implements TokenTransfer @entity(immutable: true) {
  " The concatenation of the transfer transaction hash, the log index and the action index. Joined by '_'. "
  id: ID!

  " The DAO that manages the transfer. "
  dao: Dao!

  " The ERC721 Smart Contract Token entity involved in the transfer. "
  token: ERC721Contract!

  " The ID of the transferred token. "
  tokenId: BigInt!

  " The Ethereum address from which the ERC721 token is being transferred. "
  from: Bytes!

  " The Ethereum address receiving the ERC721 token. "
  to: Bytes!

  " The associated DAO transaction, if applicable. If deposited Using the DAO `deposit` function then will be empty "
  actionBatch: ActionBatch

  " The type of transfer (External, Withdraw, Deposit) from the DAO's POV. "
  type: TransferType!

  " The hash of the ERC721 token transfer to track the transaction. "
  txHash: Bytes!

  " The timestamp of the block including the ERC721 token transfer . "
  createdAt: BigInt!
}

"""
Transfers of ERC1155 token associated with the DAO, including transfers sent to, received by, or intermediated by the DAO (refer to `Enum` `TransferType` for a better understanding of transfers associated with the DAO meaning).
"""
type ERC1155Transfer implements TokenTransfer @entity(immutable: true) {
  " The concatenation of the transfer transaction hash, the log index and the action index. Joined by '_'. "
  id: ID!

  " The DAO that manages the transfer. "
  dao: Dao!

  " The ERC1155 Smart Contract Token entity involved in the transfer. "
  token: ERC1155Contract!

  " The ID of the transferred token. "
  tokenId: BigInt!

  " The amount of transferred tokens. "
  amount: BigInt!

  " The Ethereum address performing the token transfer. "
  operator: Bytes!

  " The Ethereum address from which the tokens are being transferred. "
  from: Bytes!

  " The Ethereum address receiving the tokens. "
  to: Bytes!

  " The associated DAO transaction, if applicable. If deposited Using the DAO `deposit` function then will be empty "
  actionBatch: ActionBatch

  " The type of transfer (External, Withdraw, Deposit) from the DAO's POV. "
  type: TransferType!

  " The hash of the ERC1155 token transfer to track the transaction. "
  txHash: Bytes!

  " The timestamp of the block including the ERC1155 token transfer. "
  createdAt: BigInt!
}

"""
Transfers of Native token associated with the DAO, including transfers sent to, received by, or intermediated by the DAO (refer to `Enum` `TransferType` for a better understanding of transfers associated with the DAO meaning).
"""
type NativeTransfer implements TokenTransfer @entity(immutable: true) {
  " The concatenation of the transfer transaction hash, the log index and the action index (set to 0). Joined by '_'. "
  id: ID!

  " The DAO that manages the transfer. "
  dao: Dao!

  " The amount of transferred native tokens . "
  amount: BigInt!

  " The Ethereum address from which the native tokens are being transferred. "
  from: Bytes!

  " The Ethereum address receiving the native tokens. "
  to: Bytes!

  " The reference describing the deposit reason. "
  reference: String!

  " The associated DAO transaction, if applicable. If deposited Using the DAO `deposit` function then will be empty "
  actionBatch: ActionBatch

  " The type of transfer (External, Withdraw, Deposit) from the DAO's POV. "
  type: TransferType!

  " The hash of the native token transfer to track the transaction. "
  txHash: Bytes!

  " The timestamp of the native token transfer block. "
  createdAt: BigInt!
}

#############################
######## Executions #########
#############################

"""
A container for actions executed in batches by the DAO's `execute` function.
"""
type ActionBatch @entity(immutable: true) {
  " generateActionBatchEntityId: Concatenation caller, daoAddress, callId, transactionHash and txLogIndex. Joined by '_'. "
  id: ID!

  " generateDeterministicActionBatchId: Concatenation caller, daoAddress, callId. Joined by '_'. "
  deterministicId: String!
  dao: Dao!
  creator: Bytes!
  metadata: String
  actions: [Action!]! @derivedFrom(field: "actionBatch")
  allowFailureMap: BigInt!
  failureMap: BigInt
  executed: Boolean!
  createdAt: BigInt!
  executionTxHash: Bytes
}

type Action @entity(immutable: true) {
  " generateActionEntityId: Concatenation caller, daoAddress, callId, actionIdx, transactionHash and txLogIndex. Joined by '_'. "
  id: ID!

  " generateDeterministicActionId: Concatenation caller, daoAddress, callId, actionIdx. Joined by '_'. "
  deterministicId: String!

  " container for the actions executed in batches by the DAO's `execute` function. "
  actionBatch: ActionBatch!

  " The DAO that executed the action. "
  dao: Dao!

  " The address to call. "
  to: Bytes!

  " The native token value to be sent with the call. "
  value: BigInt!

  " The bytes-encoded function selector and calldata for the call. "
  data: Bytes!

  " The result obtained from the executed action in `bytes`. "
  execResult: Bytes
}

"""
The supported callback functions for ERC standards registered with [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID and callback function signature.
"""
type StandardCallback @entity {
  " Concatenation of the DAO address and the interfaceID. Joined by '_'. "
  id: ID!

  " The DAO associated with the supported callback functions. "
  dao: Dao!

  " The interface identifier, as specified in [ERC-165](https://eips.ethereum.org/EIPS/eip-165) (XOR of all function selectors in the interface). "
  interfaceId: Bytes!

  " The selector of the registered callback function. "
  callbackSelector: Bytes!

  " The magic number registered for the function signature. "
  magicNumber: Bytes!
}

# DAO

type Dao @entity {
  id: ID! # use address as id
  subdomain: String
  creator: Bytes!
  daoURI: String
  metadata: String
  createdAt: BigInt!
  txHash: Bytes!
  token: ERC20Contract
  actions: [Action!]! @derivedFrom(field: "dao")
  transfers: [TokenTransfer!]! @derivedFrom(field: "dao")
  balances: [TokenBalance!]! @derivedFrom(field: "dao")
  permissions: [Permission!]! @derivedFrom(field: "dao")
  actionBatch: [ActionBatch!]! @derivedFrom(field: "dao")
  trustedForwarder: Bytes
  signatureValidator: Bytes
  standardCallbacks: [StandardCallback!]! @derivedFrom(field: "dao")

  plugins: [PluginInstallation!]! @derivedFrom(field: "dao")
}

# ACL

# Cannot be immutable because a permission can be revoked and granted in the same TX.
# This results in an error in the subgraph if the entity is immutable.
# No need to store granted as we can delete permission when revoked
type Permission @entity {
  id: ID! # emitting contract Address (DAO or PluginRepo) + permissionId + where + who
  where: Bytes!
  permissionId: Bytes!
  who: Bytes!
  actor: Bytes!
  condition: Bytes

  # The following attributes is used to create
  # one-to-many between DAO or PluginRepo to Permission
  dao: Dao
  pluginRepo: PluginRepo
}

# Plugins

type PluginRepo @entity(immutable: true) {
  id: ID! # address
  subdomain: String!
  releases: [PluginRelease!]! @derivedFrom(field: "pluginRepo")
  # Holds all preparations. Also applied ones.
  preparations: [PluginPreparation!]! @derivedFrom(field: "pluginRepo")
  # Holds all installed and uninstalled installations.
  installations: [PluginInstallation!] @derivedFrom(field: "appliedPluginRepo")

  permissions: [Permission!]! @derivedFrom(field: "pluginRepo")
}

type PluginSetup @entity(immutable: true) {
  id: ID! # contract address
  versions: [PluginVersion!]! @derivedFrom(field: "pluginSetup")
}

type PluginRelease @entity {
  id: ID! # pluginRepo + release
  pluginRepo: PluginRepo!
  release: Int!
  metadata: String! # release metadata
  builds: [PluginVersion!]! @derivedFrom(field: "release")
}

type PluginVersion @entity(immutable: true) {
  id: ID! # pluginRepo + release + build
  pluginRepo: PluginRepo!
  pluginSetup: PluginSetup

  release: PluginRelease!
  build: Int!

  metadata: String! # build metadata
  # Holds all preparations. Also applied ones.
  preparations: [PluginPreparation!]! @derivedFrom(field: "pluginVersion")
  # Holds all installed and uninstalled installations.
  installations: [PluginInstallation!] @derivedFrom(field: "appliedVersion")
}

type PluginPermission @entity(immutable: true) {
  id: ID! # PluginPreparation + operation + where + who + permissionId
  pluginPreparation: PluginPreparation!
  operation: PermissionOperation!
  where: Bytes!
  who: Bytes!
  condition: Bytes
  permissionId: Bytes!
}

enum PermissionOperation {
  Grant
  Revoke
  GrantWithCondition
}

type PluginPreparation @entity(immutable: true) {
  id: ID! # psp setupId + installationId
  installation: PluginInstallation!
  creator: Bytes!
  dao: Dao!
  preparedSetupId: Bytes! # the psp setupId
  pluginRepo: PluginRepo!
  pluginVersion: PluginVersion!
  data: Bytes
  pluginAddress: Bytes!
  helpers: [Bytes!]!
  permissions: [PluginPermission!]! @derivedFrom(field: "pluginPreparation")
  type: PluginPreparationType!
}

# Don't implement IPlugin. Otherwise it would show up under plugins in the DAO entity
type PluginInstallation @entity {
  id: ID! # psp installationId
  dao: Dao!
  plugin: IPlugin # The plugin address as id provided by the applied preparation
  appliedPreparation: PluginPreparation
  appliedSetupId: Bytes # The setupId of the application see PSP documentation for more info
  appliedVersion: PluginVersion # Stored to track installations in the different plugin versions
  appliedPluginRepo: PluginRepo # Stored to track installation in the different plugin repos
  preparations: [PluginPreparation!]! @derivedFrom(field: "installation")
  state: PluginPreparationState!
}

enum PluginPreparationType {
  Installation
  Update
  Uninstallation
}

enum PluginPreparationState {
  InstallationPrepared
  Installed
  UpdatePrepared
  UninstallPrepared
  Uninstalled
}

interface IPlugin {
  id: ID! # plugin address
  dao: Dao!
  pluginAddress: Bytes!
  installations: [PluginInstallation!]! @derivedFrom(field: "plugin")
}


### File: /home/errick/core/packages/subgraph/docker/.env.example ###
PROJECT_NAME=local-subgraph
# POSTGRES
POSTGRES_VERSION=15.3-alpine
POSTGRES_USER=graph-node
POSTGRES_PASSWORD=super-secure-password
POSTGRES_DB=graph-node
POSTGRES_HOST=postgres
POSTGRES_VOLUME_DATA=./data/postgres
# IPFS
IPFS_VERSION=v0.27.0
IPFS_PORT=5001
IPFS_HOST=ipfs
IPFS_VOLUME_DATA=./data/ipfs
# GRAPH NODE
GRAPH_NODE_VERSION=latest
GRAPH_NODE_SERVER_PORT=8000
GRAPH_NODE_SERVER_WS_PORT=8001
GRAPH_NODE_ADMIN_PORT=8020
GRAPH_NODE_INDEX_NODE_SERVER_PORT=8030
GRAPH_NODE_METRICS_PORT=8040
GRAPH_NODE_HOST=graph-node
GRAPH_NODE_VOLUME_DATA=./data/graph-node
# HARDHAT
HARDHAT_PORT=8545
HARDHAT_HOST=hardhat


### File: /home/errick/core/packages/subgraph/docker/docker-compose.yml ###
version: '3'
services:
  hardhat-node:
    build:
      context: .
      dockerfile: hardhat.Dockerfile
    container_name: ${PROJECT_NAME:-local-subgraph}-hardhat-node
    ports:
      - 8545:${HARDHAT_PORT:-8545}
    networks:
      internal:
        aliases:
          - ${HARDHAT_HOST:-hardhat}

  ipfs:
    image: ipfs/kubo:${IPFS_VERSION:-v0.27.0}
    container_name: ${PROJECT_NAME:-local-subgraph}-ipfs
    command: ['daemon', '--migrate=true']
    ports:
      - 5001:${IPFS_PORT:-5001}
    volumes:
      - ${IPFS_VOLUME_DATA:-./data/ipfs}:/data/ipfs
    networks:
      internal:
        aliases:
          - ${IPFS_HOST:-ipfs}

  postgres:
    image: postgres:${POSTGRES_VERSION:-15.3-alpine}
    container_name: ${PROJECT_NAME:-local-subgraph}-postgres
    environment:
      POSTGRES_DB: ${POSTGRES_DB:-graph-node}
      POSTGRES_USER: ${POSTGRES_USER:-graph-node}
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-super-secure-password}
      PGDATA: '/var/lib/postgresql/data'
      POSTGRES_INITDB_ARGS: '-E UTF8 --locale=C'
    command: ['postgres', '-cshared_preload_libraries=pg_stat_statements']
    volumes:
      - ${POSTGRES_VOLUME_DATA:-./data/postgres}:/var/lib/postgresql/data
    networks:
      internal:
        aliases:
          - ${POSTGRES_HOST:-postgres}

  graph-node:
    image: graphprotocol/graph-node:${GRAPH_NODE_VERSION:-latest}
    container_name: ${PROJECT_NAME:-local-subgraph}-graph-node
    platform: linux/amd64
    depends_on:
      - ipfs
      - postgres
      - hardhat-node
    ports:
      - 8000:${GRAPH_NODE_SERVER_PORT:-8000}
      - 8001:${GRAPH_NODE_SERVER_WS_PORT:-8001}
      - 8020:${GRAPH_NODE_ADMIN_PORT:-8020}
      - 8030:${GRAPH_NODE_INDEX_NODE_SERVER_PORT:-8030}
      - 8040:${GRAPH_NODE_METRICS_PORT:-8040}
    environment:
      postgres_host: ${POSTGRES_HOST:-postgres}
      postgres_user: ${POSTGRES_USER:-graph-node}
      postgres_pass: ${POSTGRES_PASSWORD:-super-secure-password}
      postgres_db: ${POSTGRES_DB:-graph-node}
      ipfs: ${IPFS_HOST:-ipfs}:${IPFS_PORT:-5001}
      ethereum: localhost:http://${HARDHAT_HOST:-hardhat}:${HARDHAT_PORT:-8545}
      GRAPH_LOG: 'info'
    volumes:
      - ${GRAPH_NODE_VOLUME_DATA:-./data/graph-node}:/data
    networks:
      internal:
        aliases:
          - ${GRAPH_NODE_HOST:-graph-node}

networks:
  internal:
    name: ${PROJECT_NAME:-local-subgraph}


### File: /home/errick/core/packages/subgraph/docker/hardhat.Dockerfile ###
FROM node:20-alpine3.19

COPY ./hardhat /hardhat
WORKDIR /hardhat
RUN yarn install --ignore-scripts

EXPOSE 8545

CMD [ "yarn", "hardhat", "node", "--hostname", "0.0.0.0"]


### File: /home/errick/core/packages/subgraph/docker/hardhat/package.json ###
{
  "name": "hardhat-project",
  "devDependencies": {
    "hardhat": "2.17.2"
  }
}


### File: /home/errick/core/packages/subgraph/docker/hardhat/hardhat.config.js ###
/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: '0.8.19',
};


### File: /home/errick/core/packages/subgraph/manifest/subgraph.placeholder.yaml ###
{{info}}
specVersion: 0.0.2
description: A template for Aragon subgraphs
repository: https://github.com/aragon/osx
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum/contract
    name: {{dataSources.DAORegistry.name}}
    network: {{network}}
    source:
      abi: DAORegistry
      address: '{{dataSources.DAORegistry.address}}'
      startBlock: {{dataSources.DAORegistry.startBlock}}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - Dao
      abis:
        - name: ERC20
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC20/ERC20.sol/ERC20.json
        - name: DAORegistry
          file: $ARAGON_OSX_MODULE/artifacts/src/framework/dao/DAORegistry.sol/DAORegistry.json
      eventHandlers:
        - event: DAORegistered(indexed address,indexed address,string)
          handler: handleDAORegistered
      file: ./src/registries/daoRegistry.ts
  - kind: ethereum/contract
    name: {{dataSources.PluginRepoRegistry.name}}
    network: {{network}}
    source:
      abi: PluginRepoRegistry
      address: '{{dataSources.PluginRepoRegistry.address}}'
      startBlock: {{dataSources.PluginRepoRegistry.startBlock}}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - PluginRepo
      abis:        
        - name: PluginRepoRegistry
          file: $ARAGON_OSX_MODULE/artifacts/src/framework/plugin/repo/PluginRepoRegistry.sol/PluginRepoRegistry.json
      eventHandlers:
        - event: PluginRepoRegistered(string,address)
          handler: handlePluginRepoRegistered
      file: ./src/registries/pluginRepoRegistry.ts
  {{#dataSources.PluginSetupProcessors}}
  - kind: ethereum/contract
    name: {{name}}
    network: {{network}}
    source:
      abi: PluginSetupProcessor
      address: '{{address}}'
      startBlock: {{startBlock}}
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      entities:
        - PluginInstallation
        - PluginPreparation
        - PluginPermission
      abis:        
        - name: PluginSetupProcessor
          file: $ARAGON_OSX_MODULE/artifacts/src/framework/plugin/setup/PluginSetupProcessor.sol/PluginSetupProcessor.json
        - name: ERC20
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC20/ERC20.sol/ERC20.json
        - name: ERC165
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/utils/introspection/ERC165.sol/ERC165.json
      eventHandlers:
        - event: InstallationPrepared(indexed address,indexed address,bytes32,indexed address,(uint8,uint16),bytes,address,(address[],(uint8,address,address,address,bytes32)[]))
          handler: handleInstallationPrepared
        - event: InstallationApplied(indexed address,indexed address,bytes32,bytes32)
          handler: handleInstallationApplied
        - event: UpdatePrepared(indexed address,indexed address,bytes32,indexed address,(uint8,uint16),(address,address[],bytes),(address[],(uint8,address,address,address,bytes32)[]),bytes)
          handler: handleUpdatePrepared
        - event: UpdateApplied(indexed address,indexed address,bytes32,bytes32)
          handler: handleUpdateApplied
        - event: UninstallationPrepared(indexed address,indexed address,bytes32,indexed address,(uint8,uint16),(address,address[],bytes),(uint8,address,address,address,bytes32)[])
          handler: handleUninstallationPrepared
        - event: UninstallationApplied(indexed address,indexed address,bytes32)
          handler: handleUninstallationApplied
      file: ./src/plugin/pluginSetupProcessor.ts
  {{/dataSources.PluginSetupProcessors}}
# templates
templates:
  # DAO
  # subscribing to both dao templates needs care to avoid duplication.
  # Below, the event signature for `Executed` differs slightly, so we can
  # safely define two separate handlers and the graph will index based on the
  # matching event.
  - name: DaoTemplateV1_0_0
    kind: ethereum/contract
    network: {{network}}
    source:
      abi: DAO
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/dao/dao_v1_0_0.ts
      entities:
        - Dao
      abis:
        - name: ERC20
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC20/ERC20.sol/ERC20.json
        - name: ERC721
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC721/ERC721.sol/ERC721.json
        - name: ERC1155
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC1155/ERC1155.sol/ERC1155.json
        - name: ERC165
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/utils/introspection/ERC165.sol/ERC165.json
        - name: DAO
          file: $ARAGON_OSX_MODULE/../subgraph/abis/DAO_v1_0_0.json
        - name: CallbackHandler
          file: $ARAGON_OSX_MODULE/artifacts/src/core/utils/CallbackHandler.sol/CallbackHandler.json
      eventHandlers:
        - event: MetadataSet(bytes)
          handler: handleMetadataSet
        - event: CallbackReceived(address,indexed bytes4,bytes)
          handler: handleCallbackReceived
        - event: Deposited(indexed address,indexed address,uint256,string)
          handler: handleDeposited
        - event: NativeTokenDeposited(address,uint256)
          handler: handleNativeTokenDeposited
        - event: Executed(indexed address,bytes32,(address,uint256,bytes)[],uint256,bytes[])
          handler: handleExecuted
        - event: Granted(indexed bytes32,indexed address,address,indexed address,address)
          handler: handleGranted
        - event: Revoked(indexed bytes32,indexed address,address,indexed address)
          handler: handleRevoked
        - event: TrustedForwarderSet(address)
          handler: handleTrustedForwarderSet
        - event: StandardCallbackRegistered(bytes4,bytes4,bytes4)
          handler: handleStandardCallbackRegistered
        - event: NewURI(string)
          handler: handleNewURI
  - name: DaoTemplateV1_3_0
    kind: ethereum/contract
    network: {{network}}
    source:
      abi: DAO
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/dao/dao_v1_3_0.ts
      entities:
        - Dao
      abis:
        - name: DAO
          file: $ARAGON_OSX_MODULE/artifacts/src/core/dao/DAO.sol/DAO.json
        - name: ERC20
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC20/ERC20.sol/ERC20.json
        - name: ERC721
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC721/ERC721.sol/ERC721.json
        - name: ERC1155
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/token/ERC1155/ERC1155.sol/ERC1155.json
        - name: ERC165
          file: $ARAGON_OSX_MODULE/artifacts/@openzeppelin/contracts/utils/introspection/ERC165.sol/ERC165.json
        - name: CallbackHandler
          file: $ARAGON_OSX_MODULE/artifacts/src/core/utils/CallbackHandler.sol/CallbackHandler.json
      eventHandlers:
        - event: Executed(indexed address,bytes32,(address,uint256,bytes)[],uint256,uint256,bytes[])
          handler: handleExecuted
  # PluginRepo
  - name: PluginRepoTemplate
    kind: ethereum/contract
    network: {{network}}
    source:
      abi: PluginRepo
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.5
      language: wasm/assemblyscript
      file: ./src/plugin/pluginRepo.ts
      entities:
        - PluginRepo
      abis:
        - name: PluginRepo
          file: $ARAGON_OSX_MODULE/artifacts/src/framework/plugin/repo/PluginRepo.sol/PluginRepo.json
      eventHandlers:
        - event: VersionCreated(uint8,uint16,indexed address,bytes)
          handler: handleVersionCreated
        - event: ReleaseMetadataUpdated(uint8,bytes)
          handler: handleReleaseMetadataUpdated
        - event: Granted(indexed bytes32,indexed address,address,indexed address,address)
          handler: handleGranted
        - event: Revoked(indexed bytes32,indexed address,address,indexed address)
          handler: handleGranted
        


### File: /home/errick/core/packages/subgraph/manifest/data/polygon.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "matic",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x96E54098317631641703404C06A5afAD89da7373",
      "startBlock": 40817440
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0xA03C2182af8eC460D498108C92E8638a580b94d4",
      "startBlock": 40817440
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x879D9dfe3F36d7684BeC1a2bB4Aa8E8871A7245B",
        "startBlock": 40817440
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/mumbai.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "mumbai",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x6dD0C8b7F9406206ceAA01B5576D9d46e9298f0E",
      "startBlock": 33514164
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0xc796bB1AfEBc56daDF6CAcD2aDa78055e5381971",
      "startBlock": 33514164
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x9227b311C5cecB416707F1C8B7Ca1b52649AabEc",
        "startBlock": 33514164
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/mainnet.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "mainnet",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x7a62da7B56fB3bfCdF70E900787010Bc4c9Ca42e",
      "startBlock": 16721812
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x5B3B36BdC9470963A2734D6a0d2F6a64C21C159f",
      "startBlock": 16721812
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0xE978942c691e43f65c1B7c7F8f1dc8cDF061B13f",
        "startBlock": 16721812
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/goerli.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "goerli",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0xd51ac19130A73455F8B3b1c26aFea21D6bA88E54",
      "startBlock": 8548226
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x970Eb7Dd57c9F0dc4c5a10c06653d1103946b508",
      "startBlock": 8548226
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0xE8B5d8D66a02CD1b9Bd32a4064D7ABa45F51305e",
        "startBlock": 8548226
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/localhost.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "localhost",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x0000000000000000000000000000000000000001",
      "startBlock": 0
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x0000000000000000000000000000000000000002",
      "startBlock": 0
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x0000000000000000000000000000000000000003",
        "startBlock": 0
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/sepolia.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "sepolia",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "startBlock": 4415294
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "startBlock": 4415294
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
        "startBlock": 4415294
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/arbitrumGoerli.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "arbitrum-goerli",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0xB5146Fd572C669ABC353902e43F47fda4609E38A",
      "startBlock": 51930440
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0xCe0B4124dea6105bfB85fB4461c4D39f360E9ef3",
      "startBlock": 51930451
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
        "startBlock": 51930460
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/baseSepolia.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "base-sepolia",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "startBlock": 3654388
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "startBlock": 3654394
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
        "startBlock": 3654401
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/arbitrumSepolia.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "arbitrum-sepolia",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "startBlock": 2827166
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "startBlock": 2827170
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
        "startBlock": 2827173
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/baseGoerli.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "base-testnet",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0xB5eB5C011827C9F5787ceE3Abc72d247E36a5a0D",
      "startBlock": 7890968
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0x91a851E9Ed7F2c6d41b15F76e4a88f5A37067cC9",
      "startBlock": 7890974
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x6095b5004c59301f8Bb98768Bd395d0bc637C893",
        "startBlock": 7890981
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/arbitrum.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "arbitrum-one",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0xB5146Fd572C669ABC353902e43F47fda4609E38A",
      "startBlock": 145462155
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0xCe0B4124dea6105bfB85fB4461c4D39f360E9ef3",
      "startBlock": 145462169
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
        "startBlock": 145462184
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/manifest/data/baseMainnet.json ###
{
  "info": "# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest",
  "network": "base",
  "dataSources": {
    "DAORegistry": {
      "name": "DAORegistry",
      "address": "0xeB98a71d69a1e12B62c10368D9dA5364CE0f7178",
      "startBlock": 2094724
    },
    "PluginRepoRegistry": {
      "name": "PluginRepoRegistry",
      "address": "0xB5eB5C011827C9F5787ceE3Abc72d247E36a5a0D",
      "startBlock": 2094730
    },
    "PluginSetupProcessors": [
      {
        "name": "PluginSetupProcessor",
        "address": "0x91a851E9Ed7F2c6d41b15F76e4a88f5A37067cC9",
        "startBlock": 2094737
      }
    ]
  }
}


### File: /home/errick/core/packages/subgraph/abis/DAO_v1_0_0.json ###
{
  "_format": "hh-sol-artifact-1",
  "contractName": "DAO",
  "sourceName": "src/core/dao/DAO.sol",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "ActionFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "AnyAddressDisallowedForWhoAndWhere",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ConditionNotPresentForAnyAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InsufficientGas",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "expected",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actual",
          "type": "uint256"
        }
      ],
      "name": "NativeTokenDepositAmountMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "permissionId",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "currentCondition",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "newCondition",
          "type": "address"
        }
      ],
      "name": "PermissionAlreadyGrantedForDifferentCondition",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PermissionsForAnyAddressDisallowed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TooManyActions",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "permissionId",
          "type": "bytes32"
        }
      ],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "callbackSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes4",
          "name": "magicNumber",
          "type": "bytes4"
        }
      ],
      "name": "UnkownCallback",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "previousAdmin",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "newAdmin",
          "type": "address"
        }
      ],
      "name": "AdminChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "beacon",
          "type": "address"
        }
      ],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "bytes4",
          "name": "sig",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "CallbackReceived",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "_reference",
          "type": "string"
        }
      ],
      "name": "Deposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "actor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes32",
          "name": "callId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "indexed": false,
          "internalType": "struct IDAO.Action[]",
          "name": "actions",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "failureMap",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bytes[]",
          "name": "execResults",
          "type": "bytes[]"
        }
      ],
      "name": "Executed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "permissionId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "here",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "where",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "who",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "contract IPermissionCondition",
          "name": "condition",
          "type": "address"
        }
      ],
      "name": "Granted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "metadata",
          "type": "bytes"
        }
      ],
      "name": "MetadataSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "sender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "NativeTokenDeposited",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "daoURI",
          "type": "string"
        }
      ],
      "name": "NewURI",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "permissionId",
          "type": "bytes32"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "here",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "where",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "who",
          "type": "address"
        }
      ],
      "name": "Revoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "signatureValidator",
          "type": "address"
        }
      ],
      "name": "SignatureValidatorSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "callbackSelector",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "magicNumber",
          "type": "bytes4"
        }
      ],
      "name": "StandardCallbackRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "TrustedForwarderSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "implementation",
          "type": "address"
        }
      ],
      "name": "Upgraded",
      "type": "event"
    },
    {
      "stateMutability": "nonpayable",
      "type": "fallback"
    },
    {
      "inputs": [],
      "name": "EXECUTE_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "REGISTER_STANDARD_CALLBACK_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "ROOT_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SET_METADATA_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SET_SIGNATURE_VALIDATOR_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "SET_TRUSTED_FORWARDER_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "UPGRADE_DAO_PERMISSION_ID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "enum PermissionLib.Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "where",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "who",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "condition",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "permissionId",
              "type": "bytes32"
            }
          ],
          "internalType": "struct PermissionLib.MultiTargetPermission[]",
          "name": "_items",
          "type": "tuple[]"
        }
      ],
      "name": "applyMultiTargetPermissions",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "enum PermissionLib.Operation",
              "name": "operation",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "who",
              "type": "address"
            },
            {
              "internalType": "bytes32",
              "name": "permissionId",
              "type": "bytes32"
            }
          ],
          "internalType": "struct PermissionLib.SingleTargetPermission[]",
          "name": "items",
          "type": "tuple[]"
        }
      ],
      "name": "applySingleTargetPermissions",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "daoURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_amount",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "_reference",
          "type": "string"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_callId",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct IDAO.Action[]",
          "name": "_actions",
          "type": "tuple[]"
        },
        {
          "internalType": "uint256",
          "name": "_allowFailureMap",
          "type": "uint256"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "execResults",
          "type": "bytes[]"
        },
        {
          "internalType": "uint256",
          "name": "failureMap",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTrustedForwarder",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_permissionId",
          "type": "bytes32"
        }
      ],
      "name": "grant",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_permissionId",
          "type": "bytes32"
        },
        {
          "internalType": "contract IPermissionCondition",
          "name": "_condition",
          "type": "address"
        }
      ],
      "name": "grantWithCondition",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_permissionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "hasPermission",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_metadata",
          "type": "bytes"
        },
        {
          "internalType": "address",
          "name": "_initialOwner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_trustedForwarder",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "daoURI_",
          "type": "string"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_permissionId",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        }
      ],
      "name": "isGranted",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_hash",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_signature",
          "type": "bytes"
        }
      ],
      "name": "isValidSignature",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxiableUUID",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceId",
          "type": "bytes4"
        },
        {
          "internalType": "bytes4",
          "name": "_callbackSelector",
          "type": "bytes4"
        },
        {
          "internalType": "bytes4",
          "name": "_magicNumber",
          "type": "bytes4"
        }
      ],
      "name": "registerStandardCallback",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_where",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_who",
          "type": "address"
        },
        {
          "internalType": "bytes32",
          "name": "_permissionId",
          "type": "bytes32"
        }
      ],
      "name": "revoke",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "newDaoURI",
          "type": "string"
        }
      ],
      "name": "setDaoURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_metadata",
          "type": "bytes"
        }
      ],
      "name": "setMetadata",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_signatureValidator",
          "type": "address"
        }
      ],
      "name": "setSignatureValidator",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newTrustedForwarder",
          "type": "address"
        }
      ],
      "name": "setTrustedForwarder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "signatureValidator",
      "outputs": [
        {
          "internalType": "contract IERC1271",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        }
      ],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newImplementation",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "data",
          "type": "bytes"
        }
      ],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "stateMutability": "payable",
      "type": "receive"
    }
  ],
  "bytecode": "0x60a0604052306080523480156200001557600080fd5b506200002062000026565b620000e8565b600054610100900460ff1615620000935760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff9081161015620000e6576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b6080516135ad6200012060003960008181610a6c01528181610b0201528181610c9701528181610d2d0152610e2801526135ad6000f3fe6080604052600436106101d15760003560e01c8063829331a1116100f7578063d96054c411610095578063e978afe511610064578063e978afe5146106b2578063eafb8b06146106d2578063ee57e36f146106f2578063fdef91061461071257610210565b8063d96054c41461060a578063da7422281461062a578063e2e355631461064a578063e306bee71461067e57610210565b8063c71bf324116100d1578063c71bf3241461057d578063c9dbc2a4146105ab578063ce1b815f146105cb578063d68bad2c146105ea57610210565b8063829331a114610516578063bfe07da61461054a578063c4a501451461055d57610210565b80632675fdd01161016f5780633e2ab0d91161013e5780633e2ab0d9146104ac5780634f1ef286146104cc57806352d1902d146104df5780637034731b146104f457610210565b80632675fdd0146103ff57806326875b1f1461041f5780633659cfe614610453578063388da9341461047357610210565b80631080f99b116101ab5780631080f99b146103505780631626ba7e1461037257806322844d04146103ab57806324b4d73f146103cb57610210565b806301ffc9a7146102a55780630729d054146102da57806309e56b141461031c57610210565b3661021057604080513381523460208201527f62c2c8e34665db7c56b2cabd7f5fb9702ccd352ffa8150147e450797e9f8e8f3910160405180910390a1005b34801561021c57600080fd5b50600036606060006102706000356001600160e01b03191685858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061073292505050565b604080516001600160e01b03198316602082015291925001604051602081830303815290604052915050915050805190602001f35b3480156102b157600080fd5b506102c56102c036600461293e565b610809565b60405190151581526020015b60405180910390f35b3480156102e657600080fd5b5061030e7fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d81565b6040519081526020016102d1565b34801561032857600080fd5b5061030e7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3381565b34801561035c57600080fd5b5061037061036b3660046129a4565b61085e565b005b34801561037e57600080fd5b5061039261038d366004612a89565b610897565b6040516001600160e01b031990911681526020016102d1565b3480156103b757600080fd5b506103706103c6366004612ae5565b610947565b3480156103d757600080fd5b5061030e7f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc81565b34801561040b57600080fd5b506102c561041a366004612b6d565b610a17565b34801561042b57600080fd5b5061030e7ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc81565b34801561045f57600080fd5b5061037061046e366004612bd9565b610a62565b34801561047f57600080fd5b5061012d54610494906001600160a01b031681565b6040516001600160a01b0390911681526020016102d1565b3480156104b857600080fd5b506103706104c7366004612bd9565b610bff565b6103706104da366004612bf6565b610c8d565b3480156104eb57600080fd5b5061030e610e1b565b34801561050057600080fd5b50610509610ee0565b6040516102d19190612c80565b34801561052257600080fd5b5061030e7f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c81565b610370610558366004612c93565b610f73565b34801561056957600080fd5b50610370610578366004612cef565b6110ad565b34801561058957600080fd5b5061059d610598366004612d3a565b611160565b6040516102d1929190612e14565b3480156105b757600080fd5b506103706105c6366004612e36565b611439565b3480156105d757600080fd5b5061012e546001600160a01b0316610494565b3480156105f657600080fd5b50610370610605366004612e89565b61146f565b34801561061657600080fd5b50610370610625366004612e89565b6114aa565b34801561063657600080fd5b50610370610645366004612bd9565b6114df565b34801561065657600080fd5b5061030e7f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e77808837281565b34801561068a57600080fd5b5061030e7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b81565b3480156106be57600080fd5b506103706106cd366004612eca565b611512565b3480156106de57600080fd5b506103706106ed366004612f3f565b611619565b3480156106fe57600080fd5b5061037061070d3660046129a4565b6117e0565b34801561071e57600080fd5b506102c561072d366004612b6d565b611814565b6001600160e01b0319808316600090815260fb6020526040812054909160e09190911b9081166107a7576040517f54bdcc3e0000000000000000000000000000000000000000000000000000000081526001600160e01b03198086166004830152821660248201526044015b60405180910390fd5b837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f4792cb6e46e49876374bea490ba23274bacea6b84c216a64f47abab54027589b33856040516107f8929190612fd8565b60405180910390a290505b92915050565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614806108035750506001600160e01b03191660009081526033602052604090205460ff1690565b7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b61088881611822565b61089283836118aa565b505050565b61012d546000906001600160a01b03166108b357506000610803565b61012d546040517f1626ba7e0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690631626ba7e906108ff9086908690600401612ffa565b602060405180830381865afa15801561091c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109409190613013565b9392505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361097181611822565b60005b82811015610a1057600084848381811061099057610990613030565b9050606002018036038101906109a6919061305a565b90506000815160028111156109bd576109bd6130c3565b036109da576109d586826020015183604001516118ea565b610a07565b6001815160028111156109ef576109ef6130c3565b03610a0757610a0786826020015183604001516118f7565b50600101610974565b5050505050565b6000610a25858585856119fe565b80610a3e5750610a3e856001600160a01b0385856119fe565b80610a575750610a576001600160a01b038585856119fe565b90505b949350505050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610b005760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161079e565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614610bd75760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161079e565b610be081611b72565b60408051600080825260208201909252610bfc91839190611b9c565b50565b7f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e778088372610c2981611822565b61012d805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0384169081179091556040519081527f3b25c5d3870ec0eac28822b177f18c9130233ade5b7f857c6a224a507c37fc4e906020015b60405180910390a15050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610d2b5760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161079e565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610d867f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614610e025760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161079e565b610e0b82611b72565b610e1782826001611b9c565b5050565b6000306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ebb5760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000606482015260840161079e565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b606061012f8054610ef0906130d9565b80601f0160208091040260200160405190810160405280929190818152602001828054610f1c906130d9565b8015610f695780601f10610f3e57610100808354040283529160200191610f69565b820191906000526020600020905b815481529060010190602001808311610f4c57829003601f168201915b5050505050905090565b82600003610fad576040517f1f2a200500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03841661100257823414610ffd576040517f1abd56100000000000000000000000000000000000000000000000000000000081526004810184905234602482015260440161079e565b611058565b3415611043576040517f1abd56100000000000000000000000000000000000000000000000000000000081526000600482015234602482015260440161079e565b6110586001600160a01b038516333086611d3c565b836001600160a01b0316336001600160a01b03167f2bc500cf071be2d1c1458ed6ff484cd4db4345ada8943dee7ff29e7af3558f7685858560405161109f9392919061313e565b60405180910390a350505050565b7ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc6110d781611822565b6110e084611dc4565b6001600160e01b03198316600090815260fb60205260409020805463ffffffff191660e084901c179055604080516001600160e01b0319808716825280861660208301528416918101919091527ffc72fd547553f7a663e0048e590afc9c47b56a4242e960f31cf4c62e23d308b99060600160405180910390a150505050565b606060007fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d61118e81611822565b6101008511156111ca576040517f11c763d600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8467ffffffffffffffff8111156111e3576111e36129e6565b60405190808252806020026020018201604052801561121657816020015b60608152602001906001900390816112015790505b50925060008060005b878110156113e3575a92506000808a8a8481811061123f5761123f613030565b90506020028101906112519190613158565b61125f906020810190612bd9565b6001600160a01b03168b8b8581811061127a5761127a613030565b905060200281019061128c9190613158565b602001358c8c868181106112a2576112a2613030565b90506020028101906112b49190613158565b6112c2906040810190613178565b6040516112d09291906131bf565b60006040518083038185875af1925050503d806000811461130d576040519150601f19603f3d011682016040523d82523d6000602084013e611312565b606091505b50915091505a9350600160ff84161b89166113665781611361576040517fa6a7dbbd0000000000000000000000000000000000000000000000000000000081526004810184905260240161079e565b6113bb565b816113bb576113766040866131cf565b8410156113af576040517f1c26714c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600160ff84161b871896505b808884815181106113ce576113ce613030565b6020908102919091010152505060010161121f565b50336001600160a01b03167fd0de18eab8dc7532aab0fc4eb308477031cabf9fd312ea3b3a5fe9aa45ac8ed78a8a8a888a6040516114259594939291906131f1565b60405180910390a250505094509492505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361146381611822565b610a1085858585611e43565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361149981611822565b6114a48484846118ea565b50505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada336114d481611822565b6114a48484846118f7565b7f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c61150981611822565b610e1782612101565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361153c81611822565b60005b828110156114a457600084848381811061155b5761155b613030565b905060a002018036038101906115719190613316565b9050600081516002811115611588576115886130c3565b036115a9576115a48160200151826040015183608001516118ea565b611610565b6001815160028111156115be576115be6130c3565b036115da576115a48160200151826040015183608001516118f7565b6002815160028111156115ef576115ef6130c3565b03611610576116108160200151826040015183608001518460600151611e43565b5060010161153f565b600054610100900460ff16158080156116395750600054600160ff909116105b806116535750303b158015611653575060005460ff166001145b6116c55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161079e565b6000805460ff1916600117905580156116e8576000805461ff0019166101001790555b6117117f9385547e00000000000000000000000000000000000000000000000000000000611dc4565b61173a7f1626ba7e00000000000000000000000000000000000000000000000000000000611dc4565b6117637f7034731b00000000000000000000000000000000000000000000000000000000611dc4565b61176b612163565b6117758787612270565b61177e84612101565b61178883836118aa565b611791856122a1565b80156117d7576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050565b7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b61180a81611822565b6108928383612270565b6000610a5785858585610a17565b6118653033836000368080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610a1792505050565b610bfc576040517f1e09743f0000000000000000000000000000000000000000000000000000000081523060048201523360248201526044810182905260640161079e565b61012f6118b88284836133f3565b507fe9b617ecb5f63f6a9ccd8d4d5fa0d7b2ef9b17ce3f48e6b135808d6a40e677428282604051610c819291906134b3565b6108928383836002611e43565b604080517f5045524d495353494f4e000000000000000000000000000000000000000000006020808301919091526bffffffffffffffffffffffff19606086811b8216602a85015287901b16603e83015260528083018590528351808403909101815260729092019092528051910120600090600081815260c960205260409020549091506001600160a01b0316156114a457600081815260c96020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff1916905590516001600160a01b038681168252851691339185917f3ca48185ec3f6e47e24db18b13f1c65b1ce05da1659f9c1c4fe717dda5f67524910160405180910390a450505050565b60008060c96000611a838888886040517f5045524d495353494f4e0000000000000000000000000000000000000000000060208201526bffffffffffffffffffffffff19606084811b8216602a84015285901b16603e820152605281018290526000906072016040516020818303038152906040528051906020012090509392505050565b81526020810191909152604001600020546001600160a01b0316905080611aae576000915050610a5a565b6001196001600160a01b03821601611aca576001915050610a5a565b6040517f2675fdd00000000000000000000000000000000000000000000000000000000081526001600160a01b03821690632675fdd090611b159089908990899089906004016134c7565b602060405180830381865afa925050508015611b4e575060408051601f3d908101601f19168201909252611b4b91810190613503565b60015b15611b66578015611b6457600192505050610a5a565b505b50600095945050505050565b7f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc610e1781611822565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615611bcf5761089283612327565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611c29575060408051601f3d908101601f19168201909252611c2691810190613525565b60015b611c9b5760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f742055555053000000000000000000000000000000000000606482015260840161079e565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114611d305760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c65555549440000000000000000000000000000000000000000000000606482015260840161079e565b506108928383836123f2565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd000000000000000000000000000000000000000000000000000000001790526114a4908590612417565b6001600160e01b03198082169003611e1e5760405162461bcd60e51b815260206004820152601c60248201527f4552433136353a20696e76616c696420696e7465726661636520696400000000604482015260640161079e565b6001600160e01b0319166000908152603360205260409020805460ff19166001179055565b6001600160a01b03848116148015611e6357506001600160a01b03838116145b15611e9a576040517f85f1ba9900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b038481161480611eb957506001600160a01b03838116145b15611f73576000611ec9836124fc565b90507f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada33831480611ef65750805b15611f2d576040517f24159e5b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001196001600160a01b03831601611f71576040517f92ab7d0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505b604080517f5045524d495353494f4e000000000000000000000000000000000000000000006020808301919091526bffffffffffffffffffffffff19606087811b8216602a85015288901b16603e83015260528083018690528351808403909101815260729092019092528051910120600090600081815260c960205260409020549091506001600160a01b0316828161208c57600083815260c96020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038581169190911790915582518a8216815287821692810192909252881691339188917f0f579ad49235a8c1fd9041427e7067b1eb10926bbed380bf6fabc73e0e807644910160405180910390a46117d7565b806001600160a01b0316826001600160a01b0316146117d7576040517f0b98789e0000000000000000000000000000000000000000000000000000000081526001600160a01b03808916600483015280881660248301526044820187905280841660648301528216608482015260a40161079e565b61012e805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383169081179091556040519081527fd91237492a9e30cd2faf361fc103998a382ff0ec2b1b07dc1cbebb76ae2f1ea29060200160405180910390a150565b61218c7f150b7a0200000000000000000000000000000000000000000000000000000000611dc4565b6121b57f4e2312e000000000000000000000000000000000000000000000000000000000611dc4565b60fb6020527f5a08f87af82de422c581ce019b2e54a9c17372e9cba575ae0470ba2482d63686805463ffffffff1990811663150b7a02179091557fe1cfe341950d56d8854f782066100d5ae1d5930cdb4949b973e554a343efc6c38054821663f23a6e611790557fbc197c81000000000000000000000000000000000000000000000000000000006000527f08ba3617671847c1c169da222a5bc01cfdefcc3c4f1e5525214a474479c89123805490911663bc197c81179055565b7fbb39ebb37e60fb5d606ffdb749d2336e56b88e6c88c4bd6513b308f643186eed8282604051610c819291906134b3565b600054610100900460ff1661231e5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161079e565b610bfc816125f5565b6001600160a01b0381163b6123a45760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e747261637400000000000000000000000000000000000000606482015260840161079e565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6123fb83612620565b6000825111806124085750805b15610892576114a48383612660565b600061246c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661276b9092919063ffffffff16565b805190915015610892578080602001905181019061248a9190613503565b6108925760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161079e565b60007fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d82148061254b57507f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc82145b8061257557507f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b82145b8061259f57507f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c82145b806125c957507f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e77808837282145b806108035750507ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc1490565b610bfc30827f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada336118ea565b61262981612327565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b6126df5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e74726163740000000000000000000000000000000000000000000000000000606482015260840161079e565b600080846001600160a01b0316846040516126fa919061353e565b600060405180830381855af49150503d8060008114612735576040519150601f19603f3d011682016040523d82523d6000602084013e61273a565b606091505b509150915061276282826040518060600160405280602781526020016135516027913961277a565b95945050505050565b6060610a5a8484600085612793565b60608315612789575081610940565b6109408383612885565b60608247101561280b5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c0000000000000000000000000000000000000000000000000000606482015260840161079e565b600080866001600160a01b03168587604051612827919061353e565b60006040518083038185875af1925050503d8060008114612864576040519150601f19603f3d011682016040523d82523d6000602084013e612869565b606091505b509150915061287a878383876128af565b979650505050505050565b8151156128955781518083602001fd5b8060405162461bcd60e51b815260040161079e9190612c80565b6060831561291e578251600003612917576001600160a01b0385163b6129175760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161079e565b5081610a5a565b610a5a8383612885565b6001600160e01b031981168114610bfc57600080fd5b60006020828403121561295057600080fd5b813561094081612928565b60008083601f84011261296d57600080fd5b50813567ffffffffffffffff81111561298557600080fd5b60208301915083602082850101111561299d57600080fd5b9250929050565b600080602083850312156129b757600080fd5b823567ffffffffffffffff8111156129ce57600080fd5b6129da8582860161295b565b90969095509350505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112612a0d57600080fd5b813567ffffffffffffffff80821115612a2857612a286129e6565b604051601f8301601f19908116603f01168101908282118183101715612a5057612a506129e6565b81604052838152866020858801011115612a6957600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215612a9c57600080fd5b82359150602083013567ffffffffffffffff811115612aba57600080fd5b612ac6858286016129fc565b9150509250929050565b6001600160a01b0381168114610bfc57600080fd5b600080600060408486031215612afa57600080fd5b8335612b0581612ad0565b9250602084013567ffffffffffffffff80821115612b2257600080fd5b818601915086601f830112612b3657600080fd5b813581811115612b4557600080fd5b876020606083028501011115612b5a57600080fd5b6020830194508093505050509250925092565b60008060008060808587031215612b8357600080fd5b8435612b8e81612ad0565b93506020850135612b9e81612ad0565b925060408501359150606085013567ffffffffffffffff811115612bc157600080fd5b612bcd878288016129fc565b91505092959194509250565b600060208284031215612beb57600080fd5b813561094081612ad0565b60008060408385031215612c0957600080fd5b8235612c1481612ad0565b9150602083013567ffffffffffffffff811115612aba57600080fd5b60005b83811015612c4b578181015183820152602001612c33565b50506000910152565b60008151808452612c6c816020860160208601612c30565b601f01601f19169290920160200192915050565b6020815260006109406020830184612c54565b60008060008060608587031215612ca957600080fd5b8435612cb481612ad0565b935060208501359250604085013567ffffffffffffffff811115612cd757600080fd5b612ce38782880161295b565b95989497509550505050565b600080600060608486031215612d0457600080fd5b8335612d0f81612928565b92506020840135612d1f81612928565b91506040840135612d2f81612928565b809150509250925092565b60008060008060608587031215612d5057600080fd5b84359350602085013567ffffffffffffffff80821115612d6f57600080fd5b818701915087601f830112612d8357600080fd5b813581811115612d9257600080fd5b8860208260051b8501011115612da757600080fd5b95986020929092019750949560400135945092505050565b600081518084526020808501808196508360051b8101915082860160005b85811015612e07578284038952612df5848351612c54565b98850198935090840190600101612ddd565b5091979650505050505050565b604081526000612e276040830185612dbf565b90508260208301529392505050565b60008060008060808587031215612e4c57600080fd5b8435612e5781612ad0565b93506020850135612e6781612ad0565b9250604085013591506060850135612e7e81612ad0565b939692955090935050565b600080600060608486031215612e9e57600080fd5b8335612ea981612ad0565b92506020840135612eb981612ad0565b929592945050506040919091013590565b60008060208385031215612edd57600080fd5b823567ffffffffffffffff80821115612ef557600080fd5b818501915085601f830112612f0957600080fd5b813581811115612f1857600080fd5b86602060a083028501011115612f2d57600080fd5b60209290920196919550909350505050565b60008060008060008060808789031215612f5857600080fd5b863567ffffffffffffffff80821115612f7057600080fd5b612f7c8a838b0161295b565b909850965060208901359150612f9182612ad0565b909450604088013590612fa382612ad0565b90935060608801359080821115612fb957600080fd5b50612fc689828a0161295b565b979a9699509497509295939492505050565b6001600160a01b0383168152604060208201526000610a5a6040830184612c54565b828152604060208201526000610a5a6040830184612c54565b60006020828403121561302557600080fd5b815161094081612928565b634e487b7160e01b600052603260045260246000fd5b80356003811061305557600080fd5b919050565b60006060828403121561306c57600080fd5b6040516060810181811067ffffffffffffffff8211171561308f5761308f6129e6565b60405261309b83613046565b815260208301356130ab81612ad0565b60208201526040928301359281019290925250919050565b634e487b7160e01b600052602160045260246000fd5b600181811c908216806130ed57607f821691505b60208210810361310d57634e487b7160e01b600052602260045260246000fd5b50919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b838152604060208201526000610a57604083018486613113565b60008235605e1983360301811261316e57600080fd5b9190910192915050565b6000808335601e1984360301811261318f57600080fd5b83018035915067ffffffffffffffff8211156131aa57600080fd5b60200191503681900382131561299d57600080fd5b8183823760009101908152919050565b6000826131ec57634e487b7160e01b600052601260045260246000fd5b500490565b60006080820187835260206080818501528187835260a08501905060a08860051b86010192508860005b898110156132ee577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608786030183528135605e198c360301811261325e57600080fd5b8b016060813561326d81612ad0565b6001600160a01b03168752818601358688015260408083013536849003601e1901811261329957600080fd5b90920186810192903567ffffffffffffffff8111156132b757600080fd5b8036038413156132c657600080fd5b82828a01526132d8838a018286613113565b985050509385019350509083019060010161321b565b50505050846040840152828103606084015261330a8185612dbf565b98975050505050505050565b600060a0828403121561332857600080fd5b60405160a0810181811067ffffffffffffffff8211171561334b5761334b6129e6565b60405261335783613046565b8152602083013561336781612ad0565b6020820152604083013561337a81612ad0565b6040820152606083013561338d81612ad0565b60608201526080928301359281019290925250919050565b601f82111561089257600081815260208120601f850160051c810160208610156133cc5750805b601f850160051c820191505b818110156133eb578281556001016133d8565b505050505050565b67ffffffffffffffff83111561340b5761340b6129e6565b61341f8361341983546130d9565b836133a5565b6000601f841160018114613453576000851561343b5750838201355b600019600387901b1c1916600186901b178355610a10565b600083815260209020601f19861690835b828110156134845786850135825560209485019460019092019101613464565b50868210156134a15760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b602081526000610a5a602083018486613113565b60006001600160a01b038087168352808616602084015250836040830152608060608301526134f96080830184612c54565b9695505050505050565b60006020828403121561351557600080fd5b8151801515811461094057600080fd5b60006020828403121561353757600080fd5b5051919050565b6000825161316e818460208701612c3056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212200c168e950345d0d51e5072f0d6741c8fffb903a88e5f4d9ae41a3c116b51090b64736f6c63430008110033",
  "deployedBytecode": "0x6080604052600436106101d15760003560e01c8063829331a1116100f7578063d96054c411610095578063e978afe511610064578063e978afe5146106b2578063eafb8b06146106d2578063ee57e36f146106f2578063fdef91061461071257610210565b8063d96054c41461060a578063da7422281461062a578063e2e355631461064a578063e306bee71461067e57610210565b8063c71bf324116100d1578063c71bf3241461057d578063c9dbc2a4146105ab578063ce1b815f146105cb578063d68bad2c146105ea57610210565b8063829331a114610516578063bfe07da61461054a578063c4a501451461055d57610210565b80632675fdd01161016f5780633e2ab0d91161013e5780633e2ab0d9146104ac5780634f1ef286146104cc57806352d1902d146104df5780637034731b146104f457610210565b80632675fdd0146103ff57806326875b1f1461041f5780633659cfe614610453578063388da9341461047357610210565b80631080f99b116101ab5780631080f99b146103505780631626ba7e1461037257806322844d04146103ab57806324b4d73f146103cb57610210565b806301ffc9a7146102a55780630729d054146102da57806309e56b141461031c57610210565b3661021057604080513381523460208201527f62c2c8e34665db7c56b2cabd7f5fb9702ccd352ffa8150147e450797e9f8e8f3910160405180910390a1005b34801561021c57600080fd5b50600036606060006102706000356001600160e01b03191685858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061073292505050565b604080516001600160e01b03198316602082015291925001604051602081830303815290604052915050915050805190602001f35b3480156102b157600080fd5b506102c56102c036600461293e565b610809565b60405190151581526020015b60405180910390f35b3480156102e657600080fd5b5061030e7fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d81565b6040519081526020016102d1565b34801561032857600080fd5b5061030e7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3381565b34801561035c57600080fd5b5061037061036b3660046129a4565b61085e565b005b34801561037e57600080fd5b5061039261038d366004612a89565b610897565b6040516001600160e01b031990911681526020016102d1565b3480156103b757600080fd5b506103706103c6366004612ae5565b610947565b3480156103d757600080fd5b5061030e7f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc81565b34801561040b57600080fd5b506102c561041a366004612b6d565b610a17565b34801561042b57600080fd5b5061030e7ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc81565b34801561045f57600080fd5b5061037061046e366004612bd9565b610a62565b34801561047f57600080fd5b5061012d54610494906001600160a01b031681565b6040516001600160a01b0390911681526020016102d1565b3480156104b857600080fd5b506103706104c7366004612bd9565b610bff565b6103706104da366004612bf6565b610c8d565b3480156104eb57600080fd5b5061030e610e1b565b34801561050057600080fd5b50610509610ee0565b6040516102d19190612c80565b34801561052257600080fd5b5061030e7f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c81565b610370610558366004612c93565b610f73565b34801561056957600080fd5b50610370610578366004612cef565b6110ad565b34801561058957600080fd5b5061059d610598366004612d3a565b611160565b6040516102d1929190612e14565b3480156105b757600080fd5b506103706105c6366004612e36565b611439565b3480156105d757600080fd5b5061012e546001600160a01b0316610494565b3480156105f657600080fd5b50610370610605366004612e89565b61146f565b34801561061657600080fd5b50610370610625366004612e89565b6114aa565b34801561063657600080fd5b50610370610645366004612bd9565b6114df565b34801561065657600080fd5b5061030e7f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e77808837281565b34801561068a57600080fd5b5061030e7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b81565b3480156106be57600080fd5b506103706106cd366004612eca565b611512565b3480156106de57600080fd5b506103706106ed366004612f3f565b611619565b3480156106fe57600080fd5b5061037061070d3660046129a4565b6117e0565b34801561071e57600080fd5b506102c561072d366004612b6d565b611814565b6001600160e01b0319808316600090815260fb6020526040812054909160e09190911b9081166107a7576040517f54bdcc3e0000000000000000000000000000000000000000000000000000000081526001600160e01b03198086166004830152821660248201526044015b60405180910390fd5b837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19167f4792cb6e46e49876374bea490ba23274bacea6b84c216a64f47abab54027589b33856040516107f8929190612fd8565b60405180910390a290505b92915050565b60007f01ffc9a7000000000000000000000000000000000000000000000000000000006001600160e01b0319831614806108035750506001600160e01b03191660009081526033602052604090205460ff1690565b7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b61088881611822565b61089283836118aa565b505050565b61012d546000906001600160a01b03166108b357506000610803565b61012d546040517f1626ba7e0000000000000000000000000000000000000000000000000000000081526001600160a01b0390911690631626ba7e906108ff9086908690600401612ffa565b602060405180830381865afa15801561091c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109409190613013565b9392505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361097181611822565b60005b82811015610a1057600084848381811061099057610990613030565b9050606002018036038101906109a6919061305a565b90506000815160028111156109bd576109bd6130c3565b036109da576109d586826020015183604001516118ea565b610a07565b6001815160028111156109ef576109ef6130c3565b03610a0757610a0786826020015183604001516118f7565b50600101610974565b5050505050565b6000610a25858585856119fe565b80610a3e5750610a3e856001600160a01b0385856119fe565b80610a575750610a576001600160a01b038585856119fe565b90505b949350505050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610b005760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161079e565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b5b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614610bd75760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161079e565b610be081611b72565b60408051600080825260208201909252610bfc91839190611b9c565b50565b7f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e778088372610c2981611822565b61012d805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0384169081179091556040519081527f3b25c5d3870ec0eac28822b177f18c9130233ade5b7f857c6a224a507c37fc4e906020015b60405180910390a15050565b6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000163003610d2b5760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f64656c656761746563616c6c0000000000000000000000000000000000000000606482015260840161079e565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610d867f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc546001600160a01b031690565b6001600160a01b031614610e025760405162461bcd60e51b815260206004820152602c60248201527f46756e6374696f6e206d7573742062652063616c6c6564207468726f7567682060448201527f6163746976652070726f78790000000000000000000000000000000000000000606482015260840161079e565b610e0b82611b72565b610e1782826001611b9c565b5050565b6000306001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610ebb5760405162461bcd60e51b815260206004820152603860248201527f555550535570677261646561626c653a206d757374206e6f742062652063616c60448201527f6c6564207468726f7567682064656c656761746563616c6c0000000000000000606482015260840161079e565b507f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc90565b606061012f8054610ef0906130d9565b80601f0160208091040260200160405190810160405280929190818152602001828054610f1c906130d9565b8015610f695780601f10610f3e57610100808354040283529160200191610f69565b820191906000526020600020905b815481529060010190602001808311610f4c57829003601f168201915b5050505050905090565b82600003610fad576040517f1f2a200500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03841661100257823414610ffd576040517f1abd56100000000000000000000000000000000000000000000000000000000081526004810184905234602482015260440161079e565b611058565b3415611043576040517f1abd56100000000000000000000000000000000000000000000000000000000081526000600482015234602482015260440161079e565b6110586001600160a01b038516333086611d3c565b836001600160a01b0316336001600160a01b03167f2bc500cf071be2d1c1458ed6ff484cd4db4345ada8943dee7ff29e7af3558f7685858560405161109f9392919061313e565b60405180910390a350505050565b7ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc6110d781611822565b6110e084611dc4565b6001600160e01b03198316600090815260fb60205260409020805463ffffffff191660e084901c179055604080516001600160e01b0319808716825280861660208301528416918101919091527ffc72fd547553f7a663e0048e590afc9c47b56a4242e960f31cf4c62e23d308b99060600160405180910390a150505050565b606060007fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d61118e81611822565b6101008511156111ca576040517f11c763d600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8467ffffffffffffffff8111156111e3576111e36129e6565b60405190808252806020026020018201604052801561121657816020015b60608152602001906001900390816112015790505b50925060008060005b878110156113e3575a92506000808a8a8481811061123f5761123f613030565b90506020028101906112519190613158565b61125f906020810190612bd9565b6001600160a01b03168b8b8581811061127a5761127a613030565b905060200281019061128c9190613158565b602001358c8c868181106112a2576112a2613030565b90506020028101906112b49190613158565b6112c2906040810190613178565b6040516112d09291906131bf565b60006040518083038185875af1925050503d806000811461130d576040519150601f19603f3d011682016040523d82523d6000602084013e611312565b606091505b50915091505a9350600160ff84161b89166113665781611361576040517fa6a7dbbd0000000000000000000000000000000000000000000000000000000081526004810184905260240161079e565b6113bb565b816113bb576113766040866131cf565b8410156113af576040517f1c26714c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600160ff84161b871896505b808884815181106113ce576113ce613030565b6020908102919091010152505060010161121f565b50336001600160a01b03167fd0de18eab8dc7532aab0fc4eb308477031cabf9fd312ea3b3a5fe9aa45ac8ed78a8a8a888a6040516114259594939291906131f1565b60405180910390a250505094509492505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361146381611822565b610a1085858585611e43565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361149981611822565b6114a48484846118ea565b50505050565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada336114d481611822565b6114a48484846118f7565b7f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c61150981611822565b610e1782612101565b7f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada3361153c81611822565b60005b828110156114a457600084848381811061155b5761155b613030565b905060a002018036038101906115719190613316565b9050600081516002811115611588576115886130c3565b036115a9576115a48160200151826040015183608001516118ea565b611610565b6001815160028111156115be576115be6130c3565b036115da576115a48160200151826040015183608001516118f7565b6002815160028111156115ef576115ef6130c3565b03611610576116108160200151826040015183608001518460600151611e43565b5060010161153f565b600054610100900460ff16158080156116395750600054600160ff909116105b806116535750303b158015611653575060005460ff166001145b6116c55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201527f647920696e697469616c697a6564000000000000000000000000000000000000606482015260840161079e565b6000805460ff1916600117905580156116e8576000805461ff0019166101001790555b6117117f9385547e00000000000000000000000000000000000000000000000000000000611dc4565b61173a7f1626ba7e00000000000000000000000000000000000000000000000000000000611dc4565b6117637f7034731b00000000000000000000000000000000000000000000000000000000611dc4565b61176b612163565b6117758787612270565b61177e84612101565b61178883836118aa565b611791856122a1565b80156117d7576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050565b7f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b61180a81611822565b6108928383612270565b6000610a5785858585610a17565b6118653033836000368080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610a1792505050565b610bfc576040517f1e09743f0000000000000000000000000000000000000000000000000000000081523060048201523360248201526044810182905260640161079e565b61012f6118b88284836133f3565b507fe9b617ecb5f63f6a9ccd8d4d5fa0d7b2ef9b17ce3f48e6b135808d6a40e677428282604051610c819291906134b3565b6108928383836002611e43565b604080517f5045524d495353494f4e000000000000000000000000000000000000000000006020808301919091526bffffffffffffffffffffffff19606086811b8216602a85015287901b16603e83015260528083018590528351808403909101815260729092019092528051910120600090600081815260c960205260409020549091506001600160a01b0316156114a457600081815260c96020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff1916905590516001600160a01b038681168252851691339185917f3ca48185ec3f6e47e24db18b13f1c65b1ce05da1659f9c1c4fe717dda5f67524910160405180910390a450505050565b60008060c96000611a838888886040517f5045524d495353494f4e0000000000000000000000000000000000000000000060208201526bffffffffffffffffffffffff19606084811b8216602a84015285901b16603e820152605281018290526000906072016040516020818303038152906040528051906020012090509392505050565b81526020810191909152604001600020546001600160a01b0316905080611aae576000915050610a5a565b6001196001600160a01b03821601611aca576001915050610a5a565b6040517f2675fdd00000000000000000000000000000000000000000000000000000000081526001600160a01b03821690632675fdd090611b159089908990899089906004016134c7565b602060405180830381865afa925050508015611b4e575060408051601f3d908101601f19168201909252611b4b91810190613503565b60015b15611b66578015611b6457600192505050610a5a565b505b50600095945050505050565b7f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc610e1781611822565b7f4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd91435460ff1615611bcf5761089283612327565b826001600160a01b03166352d1902d6040518163ffffffff1660e01b8152600401602060405180830381865afa925050508015611c29575060408051601f3d908101601f19168201909252611c2691810190613525565b60015b611c9b5760405162461bcd60e51b815260206004820152602e60248201527f45524331393637557067726164653a206e657720696d706c656d656e7461746960448201527f6f6e206973206e6f742055555053000000000000000000000000000000000000606482015260840161079e565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc8114611d305760405162461bcd60e51b815260206004820152602960248201527f45524331393637557067726164653a20756e737570706f727465642070726f7860448201527f6961626c65555549440000000000000000000000000000000000000000000000606482015260840161079e565b506108928383836123f2565b604080516001600160a01b0385811660248301528416604482015260648082018490528251808303909101815260849091019091526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f23b872dd000000000000000000000000000000000000000000000000000000001790526114a4908590612417565b6001600160e01b03198082169003611e1e5760405162461bcd60e51b815260206004820152601c60248201527f4552433136353a20696e76616c696420696e7465726661636520696400000000604482015260640161079e565b6001600160e01b0319166000908152603360205260409020805460ff19166001179055565b6001600160a01b03848116148015611e6357506001600160a01b03838116145b15611e9a576040517f85f1ba9900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b038481161480611eb957506001600160a01b03838116145b15611f73576000611ec9836124fc565b90507f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada33831480611ef65750805b15611f2d576040517f24159e5b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001196001600160a01b03831601611f71576040517f92ab7d0c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505b604080517f5045524d495353494f4e000000000000000000000000000000000000000000006020808301919091526bffffffffffffffffffffffff19606087811b8216602a85015288901b16603e83015260528083018690528351808403909101815260729092019092528051910120600090600081815260c960205260409020549091506001600160a01b0316828161208c57600083815260c96020908152604091829020805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b038581169190911790915582518a8216815287821692810192909252881691339188917f0f579ad49235a8c1fd9041427e7067b1eb10926bbed380bf6fabc73e0e807644910160405180910390a46117d7565b806001600160a01b0316826001600160a01b0316146117d7576040517f0b98789e0000000000000000000000000000000000000000000000000000000081526001600160a01b03808916600483015280881660248301526044820187905280841660648301528216608482015260a40161079e565b61012e805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0383169081179091556040519081527fd91237492a9e30cd2faf361fc103998a382ff0ec2b1b07dc1cbebb76ae2f1ea29060200160405180910390a150565b61218c7f150b7a0200000000000000000000000000000000000000000000000000000000611dc4565b6121b57f4e2312e000000000000000000000000000000000000000000000000000000000611dc4565b60fb6020527f5a08f87af82de422c581ce019b2e54a9c17372e9cba575ae0470ba2482d63686805463ffffffff1990811663150b7a02179091557fe1cfe341950d56d8854f782066100d5ae1d5930cdb4949b973e554a343efc6c38054821663f23a6e611790557fbc197c81000000000000000000000000000000000000000000000000000000006000527f08ba3617671847c1c169da222a5bc01cfdefcc3c4f1e5525214a474479c89123805490911663bc197c81179055565b7fbb39ebb37e60fb5d606ffdb749d2336e56b88e6c88c4bd6513b308f643186eed8282604051610c819291906134b3565b600054610100900460ff1661231e5760405162461bcd60e51b815260206004820152602b60248201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960448201527f6e697469616c697a696e67000000000000000000000000000000000000000000606482015260840161079e565b610bfc816125f5565b6001600160a01b0381163b6123a45760405162461bcd60e51b815260206004820152602d60248201527f455243313936373a206e657720696d706c656d656e746174696f6e206973206e60448201527f6f74206120636f6e747261637400000000000000000000000000000000000000606482015260840161079e565b7f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc805473ffffffffffffffffffffffffffffffffffffffff19166001600160a01b0392909216919091179055565b6123fb83612620565b6000825111806124085750805b15610892576114a48383612660565b600061246c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661276b9092919063ffffffff16565b805190915015610892578080602001905181019061248a9190613503565b6108925760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161079e565b60007fbf04b4486c9663d805744005c3da000eda93de6e3308a4a7a812eb565327b78d82148061254b57507f1f53edd44352e5d15bad2b29233baa93bcd595e09457780bc7c5445bbbe751cc82145b8061257557507f4707e94b25cfce1a7c363508fbb838c35864388ad77284b248282b9746982b9b82145b8061259f57507f06d294bc8cbad2e393408b20dd019a772661f60b8d633e56761157cb1ec85f8c82145b806125c957507f0dcbfb19b09fb8ff4e9af583d4b8e9c8127cc1b26529b4d96dd3b7e77808837282145b806108035750507ffaf505be9907aa6951c2ebe5b0312f4980e14f21912ed355372103cc8bd683bc1490565b610bfc30827f815fe80e4b37c8582a3b773d1d7071f983eacfd56b5965db654f3087c25ada336118ea565b61262981612327565b6040516001600160a01b038216907fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b90600090a250565b60606001600160a01b0383163b6126df5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a2064656c65676174652063616c6c20746f206e6f6e2d636f60448201527f6e74726163740000000000000000000000000000000000000000000000000000606482015260840161079e565b600080846001600160a01b0316846040516126fa919061353e565b600060405180830381855af49150503d8060008114612735576040519150601f19603f3d011682016040523d82523d6000602084013e61273a565b606091505b509150915061276282826040518060600160405280602781526020016135516027913961277a565b95945050505050565b6060610a5a8484600085612793565b60608315612789575081610940565b6109408383612885565b60608247101561280b5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c0000000000000000000000000000000000000000000000000000606482015260840161079e565b600080866001600160a01b03168587604051612827919061353e565b60006040518083038185875af1925050503d8060008114612864576040519150601f19603f3d011682016040523d82523d6000602084013e612869565b606091505b509150915061287a878383876128af565b979650505050505050565b8151156128955781518083602001fd5b8060405162461bcd60e51b815260040161079e9190612c80565b6060831561291e578251600003612917576001600160a01b0385163b6129175760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161079e565b5081610a5a565b610a5a8383612885565b6001600160e01b031981168114610bfc57600080fd5b60006020828403121561295057600080fd5b813561094081612928565b60008083601f84011261296d57600080fd5b50813567ffffffffffffffff81111561298557600080fd5b60208301915083602082850101111561299d57600080fd5b9250929050565b600080602083850312156129b757600080fd5b823567ffffffffffffffff8111156129ce57600080fd5b6129da8582860161295b565b90969095509350505050565b634e487b7160e01b600052604160045260246000fd5b600082601f830112612a0d57600080fd5b813567ffffffffffffffff80821115612a2857612a286129e6565b604051601f8301601f19908116603f01168101908282118183101715612a5057612a506129e6565b81604052838152866020858801011115612a6957600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060408385031215612a9c57600080fd5b82359150602083013567ffffffffffffffff811115612aba57600080fd5b612ac6858286016129fc565b9150509250929050565b6001600160a01b0381168114610bfc57600080fd5b600080600060408486031215612afa57600080fd5b8335612b0581612ad0565b9250602084013567ffffffffffffffff80821115612b2257600080fd5b818601915086601f830112612b3657600080fd5b813581811115612b4557600080fd5b876020606083028501011115612b5a57600080fd5b6020830194508093505050509250925092565b60008060008060808587031215612b8357600080fd5b8435612b8e81612ad0565b93506020850135612b9e81612ad0565b925060408501359150606085013567ffffffffffffffff811115612bc157600080fd5b612bcd878288016129fc565b91505092959194509250565b600060208284031215612beb57600080fd5b813561094081612ad0565b60008060408385031215612c0957600080fd5b8235612c1481612ad0565b9150602083013567ffffffffffffffff811115612aba57600080fd5b60005b83811015612c4b578181015183820152602001612c33565b50506000910152565b60008151808452612c6c816020860160208601612c30565b601f01601f19169290920160200192915050565b6020815260006109406020830184612c54565b60008060008060608587031215612ca957600080fd5b8435612cb481612ad0565b935060208501359250604085013567ffffffffffffffff811115612cd757600080fd5b612ce38782880161295b565b95989497509550505050565b600080600060608486031215612d0457600080fd5b8335612d0f81612928565b92506020840135612d1f81612928565b91506040840135612d2f81612928565b809150509250925092565b60008060008060608587031215612d5057600080fd5b84359350602085013567ffffffffffffffff80821115612d6f57600080fd5b818701915087601f830112612d8357600080fd5b813581811115612d9257600080fd5b8860208260051b8501011115612da757600080fd5b95986020929092019750949560400135945092505050565b600081518084526020808501808196508360051b8101915082860160005b85811015612e07578284038952612df5848351612c54565b98850198935090840190600101612ddd565b5091979650505050505050565b604081526000612e276040830185612dbf565b90508260208301529392505050565b60008060008060808587031215612e4c57600080fd5b8435612e5781612ad0565b93506020850135612e6781612ad0565b9250604085013591506060850135612e7e81612ad0565b939692955090935050565b600080600060608486031215612e9e57600080fd5b8335612ea981612ad0565b92506020840135612eb981612ad0565b929592945050506040919091013590565b60008060208385031215612edd57600080fd5b823567ffffffffffffffff80821115612ef557600080fd5b818501915085601f830112612f0957600080fd5b813581811115612f1857600080fd5b86602060a083028501011115612f2d57600080fd5b60209290920196919550909350505050565b60008060008060008060808789031215612f5857600080fd5b863567ffffffffffffffff80821115612f7057600080fd5b612f7c8a838b0161295b565b909850965060208901359150612f9182612ad0565b909450604088013590612fa382612ad0565b90935060608801359080821115612fb957600080fd5b50612fc689828a0161295b565b979a9699509497509295939492505050565b6001600160a01b0383168152604060208201526000610a5a6040830184612c54565b828152604060208201526000610a5a6040830184612c54565b60006020828403121561302557600080fd5b815161094081612928565b634e487b7160e01b600052603260045260246000fd5b80356003811061305557600080fd5b919050565b60006060828403121561306c57600080fd5b6040516060810181811067ffffffffffffffff8211171561308f5761308f6129e6565b60405261309b83613046565b815260208301356130ab81612ad0565b60208201526040928301359281019290925250919050565b634e487b7160e01b600052602160045260246000fd5b600181811c908216806130ed57607f821691505b60208210810361310d57634e487b7160e01b600052602260045260246000fd5b50919050565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b838152604060208201526000610a57604083018486613113565b60008235605e1983360301811261316e57600080fd5b9190910192915050565b6000808335601e1984360301811261318f57600080fd5b83018035915067ffffffffffffffff8211156131aa57600080fd5b60200191503681900382131561299d57600080fd5b8183823760009101908152919050565b6000826131ec57634e487b7160e01b600052601260045260246000fd5b500490565b60006080820187835260206080818501528187835260a08501905060a08860051b86010192508860005b898110156132ee577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff608786030183528135605e198c360301811261325e57600080fd5b8b016060813561326d81612ad0565b6001600160a01b03168752818601358688015260408083013536849003601e1901811261329957600080fd5b90920186810192903567ffffffffffffffff8111156132b757600080fd5b8036038413156132c657600080fd5b82828a01526132d8838a018286613113565b985050509385019350509083019060010161321b565b50505050846040840152828103606084015261330a8185612dbf565b98975050505050505050565b600060a0828403121561332857600080fd5b60405160a0810181811067ffffffffffffffff8211171561334b5761334b6129e6565b60405261335783613046565b8152602083013561336781612ad0565b6020820152604083013561337a81612ad0565b6040820152606083013561338d81612ad0565b60608201526080928301359281019290925250919050565b601f82111561089257600081815260208120601f850160051c810160208610156133cc5750805b601f850160051c820191505b818110156133eb578281556001016133d8565b505050505050565b67ffffffffffffffff83111561340b5761340b6129e6565b61341f8361341983546130d9565b836133a5565b6000601f841160018114613453576000851561343b5750838201355b600019600387901b1c1916600186901b178355610a10565b600083815260209020601f19861690835b828110156134845786850135825560209485019460019092019101613464565b50868210156134a15760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b602081526000610a5a602083018486613113565b60006001600160a01b038087168352808616602084015250836040830152608060608301526134f96080830184612c54565b9695505050505050565b60006020828403121561351557600080fd5b8151801515811461094057600080fd5b60006020828403121561353757600080fd5b5051919050565b6000825161316e818460208701612c3056fe416464726573733a206c6f772d6c6576656c2064656c65676174652063616c6c206661696c6564a26469706673582212200c168e950345d0d51e5072f0d6741c8fffb903a88e5f4d9ae41a3c116b51090b64736f6c63430008110033",
  "linkReferences": {},
  "deployedLinkReferences": {}
}


### File: /home/errick/core/packages/subgraph/src/examples/index.ts ###
/* MARKDOWN
---
title: Aragon Subgraph [WIP]
sidebar_label: Introduction
sidebar_position: 0
---

## The On-Chain Information

Subgraph is a protocol for indexing and querying event data emitted from the smart contracts.

The Aragon Subgraph stores all DAO-related information, either to help users to manage and interact with their DAOs or to query useful information, such as its treasury information, members, plugins, etc.

## Playground

You can use the [Aragon subgraph-satsuma playground](https://subgraph.satsuma-prod.com/aragon/osx-mainnet/playground) for testing.

### Walkthrough

This documentation includes some [example queries](./01-query-examples/index.md) to get you familiarized with subgraph protocol and the [Reference Guide](./reference-guide/index.md) generated from the latest version of our `@aragon/osx` [subgraph schema](https://github.com/aragon/osx/blob/develop/packages/subgraph/schema.graphql).
*/


### File: /home/errick/core/packages/subgraph/src/examples/01-query-examples/index.ts ###
/* MARKDOWN
---
title: Query Examples [WIP]
sidebar_label: Query Examples
---

## Querying in Subgraph

This section will contain useful queries.
*/


### File: /home/errick/core/packages/subgraph/src/examples/01-query-examples/02-balances-query.ts ###
/* MARKDOWN
---
title: Balances Query [WIP]
sidebar_label: Balances Query
---

## Balances Query

The query
*/
import {gql} from 'graphql-request';

export const QueryTokenBalances = gql`
  query TokenBalances(
    $where: TokenBalance_filter!
    $limit: Int!
    $skip: Int!
    $direction: OrderDirection!
    $sortBy: TokenBalance_orderBy!
  ) {
    tokenBalances(
      where: $where
      first: $limit
      skip: $skip
      orderDirection: $direction
      orderBy: $sortBy
    ) {
      lastUpdated
      __typename
      ... on ERC20Balance {
        balance
        token {
          name
          decimals
          symbol
          id
        }
      }
      ... on ERC721Balance {
        token {
          name
          symbol
          id
        }
        tokenIds
      }
      ... on NativeBalance {
        balance
      }
      ... on ERC1155Balance {
        metadataUri
        token {
          id
        }
        balances {
          amount
          id
          tokenId
        }
      }
    }
  }
`;

/* MARKDOWN
The return

```json
{
  "data": {
    "tokenBalances": [
      {
        "lastUpdated": "1682856167",
        "__typename": "ERC20Balance",
        "balance": "308999000000000004456448",
        "token": {
          "name": "VEGAHVB",
          "decimals": 18,
          "symbol": "VGH",
          "id": "0x63677b9f25431e361f15019637533b4228cdc3ef"
        }
      },
      {
        "lastUpdated": "1682856587",
        "__typename": "ERC20Balance",
        "balance": "499999999999999991611392",
        "token": {
          "name": "42K",
          "decimals": 18,
          "symbol": "42K",
          "id": "0x7604fb940b31c988405847cc2db7a90938b529fc"
        }
      },
      {
        "lastUpdated": "1697108195",
        "__typename": "NativeBalance",
        "balance": "2010000000000000"
      }
    ]
  }
}
*/


### File: /home/errick/core/packages/subgraph/src/examples/01-query-examples/01-dao-query.ts ###
/* MARKDOWN
---
title: DAO Query [WIP]
sidebar_label: DAO Query
---

## DAO Query

The query 
*/
import {gql} from 'graphql-request';

export const QueryDao = gql`
  query Dao($address: ID!) {
    dao(id: $address) {
      id
      subdomain
      metadata
      createdAt
      plugins {
        appliedPreparation {
          pluginAddress
        }
        appliedPluginRepo {
          subdomain
        }
        appliedVersion {
          build
          release {
            release
          }
        }
      }
    }
  }
`;

/* MARKDOWN
The return

```json
{
  "data": {
    "dao": {
      "id": "0x02bbc496bebc9a06c239670cea663c43cead899f",
      "subdomain": "test",
      "metadata": "ipfs://QmVGCibCLPgqA8eszxQJMzQFcmQAdrkyhTGH6EB5ERivsR",
      "createdAt": "1677584087",
      "plugins": [
        {
          "appliedPreparation": {
            "pluginAddress": "0x404f4bbd06e3a42c70297633e440b11bb083d482"
          },
          "appliedPluginRepo": {
            "subdomain": "multisig"
          },
          "appliedVersion": {
            "build": 1,
            "release": {
              "release": 1
            }
          }
        }
      ]
    }
  }
}
*/


### File: /home/errick/core/packages/subgraph/src/plugin/pluginSetupProcessor.ts ###
import {
  InstallationApplied,
  InstallationPrepared,
  UninstallationApplied,
  UninstallationPrepared,
  UpdateApplied,
  UpdatePrepared,
} from '../../generated/PluginSetupProcessor/PluginSetupProcessor';
import {
  PluginInstallation,
  PluginPermission,
  PluginPreparation,
} from '../../generated/schema';
import {PERMISSION_OPERATIONS} from './utils';
import {
  generateDaoEntityId,
  generatePluginEntityId,
  generatePluginInstallationEntityId,
  generatePluginPermissionEntityId,
  generatePluginPreparationEntityId,
  generatePluginRepoEntityId,
  generatePluginVersionEntityId,
} from '@aragon/osx-commons-subgraph';
import {Bytes, log} from '@graphprotocol/graph-ts';

export function handleInstallationPrepared(event: InstallationPrepared): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.plugin;
  let pluginRepoAddress = event.params.pluginSetupRepo;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let pluginRepoEntityId = generatePluginRepoEntityId(pluginRepoAddress);
  let preparedSetupId = event.params.preparedSetupId;

  let pluginVersionId = generatePluginVersionEntityId(
    pluginRepoAddress,
    event.params.versionTag.release,
    event.params.versionTag.build
  );

  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }
  installationId = installationId as string;
  let preparationId = generatePluginPreparationEntityId(
    installationId,
    preparedSetupId
  );

  let helpers: Bytes[] = [];
  for (let i = 0; i < event.params.preparedSetupData.helpers.length; i++) {
    helpers.push(event.params.preparedSetupData.helpers[i]);
  }

  let preparationEntity = new PluginPreparation(preparationId);
  preparationEntity.installation = installationId;
  preparationEntity.creator = event.params.sender;
  preparationEntity.dao = daoEntityId;
  preparationEntity.preparedSetupId = event.params.preparedSetupId;
  preparationEntity.pluginRepo = pluginRepoEntityId;
  preparationEntity.pluginVersion = pluginVersionId;
  preparationEntity.data = event.params.data;
  preparationEntity.pluginAddress = event.params.plugin;
  preparationEntity.helpers = helpers;
  preparationEntity.type = 'Installation';
  preparationEntity.save();

  for (let i = 0; i < event.params.preparedSetupData.permissions.length; i++) {
    let permission = event.params.preparedSetupData.permissions[i];
    let permissionId = generatePluginPermissionEntityId(
      preparationId,
      permission.operation,
      permission.where,
      permission.who,
      permission.permissionId
    );
    let operation = PERMISSION_OPERATIONS.get(permission.operation);
    let permissionEntity = new PluginPermission(permissionId);
    permissionEntity.pluginPreparation = preparationId;
    permissionEntity.operation = operation;
    permissionEntity.where = permission.where;
    permissionEntity.who = permission.who;
    permissionEntity.permissionId = permission.permissionId;
    if (permission.condition) {
      permissionEntity.condition = permission.condition;
    }
    permissionEntity.save();
  }

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
  }
  pluginEntity.state = 'InstallationPrepared';
  pluginEntity.dao = daoEntityId;
  pluginEntity.save();
}

export function handleInstallationApplied(event: InstallationApplied): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.plugin;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }

  installationId = installationId as string;
  let preparationId = generatePluginPreparationEntityId(
    installationId,
    event.params.preparedSetupId
  );

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
    pluginEntity.dao = daoEntityId;
  }

  let pluginPreparationEntity = PluginPreparation.load(preparationId);
  if (pluginPreparationEntity) {
    pluginEntity.appliedPluginRepo = pluginPreparationEntity.pluginRepo;
    pluginEntity.appliedVersion = pluginPreparationEntity.pluginVersion;
  }
  pluginEntity.plugin = pluginEntityId;
  pluginEntity.appliedPreparation = preparationId;
  pluginEntity.appliedSetupId = event.params.appliedSetupId;
  pluginEntity.state = 'Installed';
  pluginEntity.save();
}

export function handleUpdatePrepared(event: UpdatePrepared): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.setupPayload.plugin;
  let pluginRepoAddress = event.params.pluginSetupRepo;
  let setupId = event.params.preparedSetupId;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let pluginVersionId = generatePluginVersionEntityId(
    pluginRepoAddress,
    event.params.versionTag.release,
    event.params.versionTag.build
  );

  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }

  installationId = installationId as string;

  let preparationId = generatePluginPreparationEntityId(
    installationId,
    setupId
  );

  let helpers: Bytes[] = [];
  for (let i = 0; i < event.params.preparedSetupData.helpers.length; i++) {
    helpers.push(event.params.preparedSetupData.helpers[i]);
  }

  let preparationEntity = new PluginPreparation(preparationId);
  preparationEntity.installation = installationId;
  preparationEntity.creator = event.params.sender;
  preparationEntity.dao = daoEntityId;
  preparationEntity.preparedSetupId = event.params.preparedSetupId;
  preparationEntity.pluginRepo = generatePluginEntityId(
    event.params.pluginSetupRepo
  );
  preparationEntity.pluginVersion = pluginVersionId;
  preparationEntity.data = event.params.initData;
  preparationEntity.pluginAddress = event.params.setupPayload.plugin;
  preparationEntity.helpers = helpers;
  preparationEntity.type = 'Update';
  preparationEntity.save();

  for (let i = 0; i < event.params.preparedSetupData.permissions.length; i++) {
    let permission = event.params.preparedSetupData.permissions[i];
    let operation = PERMISSION_OPERATIONS.get(permission.operation);
    let permissionId = generatePluginPermissionEntityId(
      preparationId,
      permission.operation,
      permission.where,
      permission.who,
      permission.permissionId
    );
    let permissionEntity = new PluginPermission(permissionId);
    permissionEntity.pluginPreparation = preparationId;
    permissionEntity.operation = operation;
    permissionEntity.where = permission.where;
    permissionEntity.who = permission.who;
    permissionEntity.permissionId = permission.permissionId;
    if (permission.condition) {
      permissionEntity.condition = permission.condition;
    }
    permissionEntity.save();
  }

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
    pluginEntity.dao = daoEntityId;
  }

  pluginEntity.state = 'UpdatePrepared';
  pluginEntity.save();
}

export function handleUpdateApplied(event: UpdateApplied): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.plugin;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }
  installationId = installationId as string;
  let preparationId = generatePluginPreparationEntityId(
    installationId,
    event.params.preparedSetupId
  );

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
    pluginEntity.dao = daoEntityId;
  }

  let pluginPreparationEntity = PluginPreparation.load(preparationId);
  if (pluginPreparationEntity) {
    pluginEntity.appliedPluginRepo = pluginPreparationEntity.pluginRepo;
    pluginEntity.appliedVersion = pluginPreparationEntity.pluginVersion;
  }
  pluginEntity.plugin = pluginEntityId;
  pluginEntity.appliedPreparation = preparationId;
  pluginEntity.appliedSetupId = event.params.appliedSetupId;
  pluginEntity.state = 'Installed';
  pluginEntity.save();
}

export function handleUninstallationPrepared(
  event: UninstallationPrepared
): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.setupPayload.plugin;
  let setupId = event.params.preparedSetupId;
  let pluginRepoAddress = event.params.pluginSetupRepo;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let pluginRepoEntityId = generatePluginRepoEntityId(pluginRepoAddress);

  let pluginVersionId = generatePluginVersionEntityId(
    pluginRepoAddress,
    event.params.versionTag.release,
    event.params.versionTag.build
  );

  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }
  installationId = installationId as string;

  let preparationId = generatePluginPreparationEntityId(
    installationId,
    setupId
  );

  let preparationEntity = new PluginPreparation(preparationId);
  preparationEntity.installation = installationId;
  preparationEntity.creator = event.params.sender;
  preparationEntity.dao = daoEntityId;
  preparationEntity.preparedSetupId = event.params.preparedSetupId;
  preparationEntity.pluginRepo = pluginRepoEntityId;
  preparationEntity.pluginVersion = pluginVersionId;
  preparationEntity.pluginAddress = event.params.setupPayload.plugin;
  preparationEntity.helpers = [];
  preparationEntity.type = 'Uninstallation';
  preparationEntity.save();

  for (let i = 0; i < event.params.permissions.length; i++) {
    let permission = event.params.permissions[i];
    let operation = PERMISSION_OPERATIONS.get(permission.operation);
    let permissionId = generatePluginPermissionEntityId(
      preparationId,
      permission.operation,
      permission.where,
      permission.who,
      permission.permissionId
    );
    let permissionEntity = new PluginPermission(permissionId);
    permissionEntity.pluginPreparation = preparationId;
    permissionEntity.operation = operation;
    permissionEntity.where = permission.where;
    permissionEntity.who = permission.who;
    permissionEntity.permissionId = permission.permissionId;
    if (permission.condition) {
      permissionEntity.condition = permission.condition;
    }
    permissionEntity.save();
  }

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
    pluginEntity.dao = daoEntityId;
  }
  pluginEntity.state = 'UninstallPrepared';
  pluginEntity.save();
}

export function handleUninstallationApplied(
  event: UninstallationApplied
): void {
  let daoAddress = event.params.dao;
  let pluginAddress = event.params.plugin;
  let daoEntityId = generateDaoEntityId(daoAddress);
  let pluginEntityId = generatePluginEntityId(pluginAddress);
  let installationId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!installationId) {
    log.error('Failed to get installationId', [daoEntityId, pluginEntityId]);
    return;
  }

  installationId = installationId as string;

  let preparationId = generatePluginPreparationEntityId(
    installationId,
    event.params.preparedSetupId
  );

  let pluginEntity = PluginInstallation.load(installationId);
  if (!pluginEntity) {
    pluginEntity = new PluginInstallation(installationId);
    pluginEntity.dao = daoEntityId;
  }
  pluginEntity.appliedPreparation = preparationId;
  pluginEntity.state = 'Uninstalled';
  pluginEntity.save();
}


### File: /home/errick/core/packages/subgraph/src/plugin/utils.ts ###
import {
  Address,
  Bytes,
  ethereum,
  crypto,
  ByteArray,
} from '@graphprotocol/graph-ts';

export const PERMISSION_OPERATIONS = new Map<number, string>()
  .set(0, 'Grant')
  .set(1, 'Revoke')
  .set(2, 'GrantWithCondition');

export function getPluginInstallationId(
  dao: string,
  plugin: string
): Bytes | null {
  let installationIdTupleArray = new ethereum.Tuple();
  installationIdTupleArray.push(
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  installationIdTupleArray.push(
    ethereum.Value.fromAddress(Address.fromString(plugin))
  );

  let installationIdTuple = installationIdTupleArray as ethereum.Tuple;
  let installationIdTupleEncoded = ethereum.encode(
    ethereum.Value.fromTuple(installationIdTuple)
  );

  if (installationIdTupleEncoded) {
    return Bytes.fromHexString(
      crypto
        .keccak256(
          ByteArray.fromHexString(installationIdTupleEncoded.toHexString())
        )
        .toHexString()
    );
  }
  return null;
}

export function getPluginVersionId(
  pluginRepo: string,
  release: i32,
  build: i32
): string {
  return pluginRepo
    .concat('_')
    .concat(release.toString())
    .concat('_')
    .concat(build.toString());
}


### File: /home/errick/core/packages/subgraph/src/plugin/pluginRepo.ts ###
import {
  PluginVersion,
  PluginSetup,
  PluginRelease,
  Permission,
} from '../../generated/schema';
import {
  ReleaseMetadataUpdated,
  VersionCreated,
  Granted,
  Revoked,
} from '../../generated/templates/PluginRepoTemplate/PluginRepo';
import {
  generatePermissionEntityId,
  generatePluginReleaseEntityId,
  generatePluginRepoEntityId,
  generatePluginSetupEntityId,
  generatePluginVersionEntityId,
} from '@aragon/osx-commons-subgraph';
import {store} from '@graphprotocol/graph-ts';

export function handleVersionCreated(event: VersionCreated): void {
  // PluginSetup
  let pluginSetupId = generatePluginSetupEntityId(event.params.pluginSetup);

  let pluginSetupEntity = PluginSetup.load(pluginSetupId);
  if (!pluginSetupEntity) {
    pluginSetupEntity = new PluginSetup(pluginSetupId);
    pluginSetupEntity.save();
  }

  // PluginVersion
  const pluginRepoAddress = event.address;
  const build = event.params.build;
  const release = event.params.release;
  let pluginReleaseId = generatePluginReleaseEntityId(
    pluginRepoAddress,
    release
  );
  let pluginVersionId = generatePluginVersionEntityId(
    pluginRepoAddress,
    release,
    build
  );

  let entity = new PluginVersion(pluginVersionId);
  entity.pluginRepo = pluginRepoAddress.toHexString();
  entity.pluginSetup = pluginSetupId;

  entity.release = pluginReleaseId;
  entity.build = build;

  entity.metadata = event.params.buildMetadata.toString();
  entity.save();
}

export function handleReleaseMetadataUpdated(
  event: ReleaseMetadataUpdated
): void {
  let pluginRepoAddress = event.address;
  let pluginRepoId = generatePluginRepoEntityId(pluginRepoAddress);
  let pluginRelease = event.params.release;
  let releaseMetadata = event.params.releaseMetadata.toString();

  let pluginReleaseEntityId = generatePluginReleaseEntityId(
    pluginRepoAddress,
    pluginRelease
  );

  let pluginReleaseEntity = PluginRelease.load(pluginReleaseEntityId);
  if (!pluginReleaseEntity) {
    pluginReleaseEntity = new PluginRelease(pluginReleaseEntityId);
    pluginReleaseEntity.pluginRepo = pluginRepoId;
    pluginReleaseEntity.release = pluginRelease;
  }

  pluginReleaseEntity.metadata = releaseMetadata;
  pluginReleaseEntity.save();
}

export function handleGranted(event: Granted): void {
  const contractAddress = event.address;
  const where = event.params.where;
  const permissionId = event.params.permissionId;
  const who = event.params.who;

  const permissionEntityId = generatePermissionEntityId(
    contractAddress,
    permissionId,
    where,
    who
  );

  // Permission
  let permissionEntity = Permission.load(permissionEntityId);
  if (!permissionEntity) {
    permissionEntity = new Permission(permissionEntityId);
    permissionEntity.where = where;
    permissionEntity.permissionId = permissionId;
    permissionEntity.who = who;
    permissionEntity.actor = event.params.here;
    permissionEntity.condition = event.params.condition;

    permissionEntity.pluginRepo = contractAddress.toHexString();

    permissionEntity.save();
  }
}

export function handleRevoked(event: Revoked): void {
  // permission
  const contractAddress = event.address;
  const where = event.params.where;
  const permissionId = event.params.permissionId;
  const who = event.params.who;

  const permissionEntityId = generatePermissionEntityId(
    contractAddress,
    permissionId,
    where,
    who
  );

  const permissionEntity = Permission.load(permissionEntityId);
  if (permissionEntity) {
    store.remove('Permission', permissionEntityId);
  }
}


### File: /home/errick/core/packages/subgraph/src/utils/proposals.ts ###
import {bigIntToBytes32} from './bytes';
import {Address, BigInt} from '@graphprotocol/graph-ts';

export function getProposalId(
  plugin: Address,
  pluginProposalId: BigInt
): string {
  return plugin
    .toHexString()
    .concat('_')
    .concat(bigIntToBytes32(pluginProposalId));
}


### File: /home/errick/core/packages/subgraph/src/utils/constants.ts ###
export const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';

// AS does not support initializing Map with data, a chain of sets is used instead
export const VOTER_OPTIONS = new Map<number, string>()
  .set(0, 'None')
  .set(1, 'Abstain')
  .set(2, 'Yes')
  .set(3, 'No');

export const VOTE_OPTIONS = new Map<string, string>()
  .set('None', '0')
  .set('Abstain', '1')
  .set('Yes', '2')
  .set('No', '3');

export const VOTING_MODES = new Map<number, string>()
  .set(0, 'Standard')
  .set(1, 'EarlyExecution')
  .set(2, 'VoteReplacement');

export const VOTING_MODE_INDEXES = new Map<string, string>()
  .set('Standard', '0')
  .set('EarlyExecution', '1')
  .set('VoteReplacement', '2');

export const RATIO_BASE = '1000000'; // 10**6


### File: /home/errick/core/packages/subgraph/src/utils/erc165.ts ###
import {ethereum, Bytes} from '@graphprotocol/graph-ts';

export function supportsInterface(
  contract: ethereum.SmartContract,
  interfaceId: string,
  // eslint-disable-next-line @typescript-eslint/no-inferrable-types
  expected: boolean = true
): boolean {
  let result = ethereum.call(
    new ethereum.SmartContractCall(
      contract._name, // '',
      contract._address, // address,
      'supportsInterface', // '',
      'supportsInterface(bytes4):(bool)',
      [ethereum.Value.fromFixedBytes(Bytes.fromHexString(interfaceId) as Bytes)]
    )
  );

  return (
    result != null &&
    (result as Array<ethereum.Value>)[0].toBoolean() == expected
  );
}


### File: /home/errick/core/packages/subgraph/src/utils/ids.ts ###
import {
  generateEntityIdFromAddress,
  generateEntityIdFromBytes,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes} from '@graphprotocol/graph-ts';

export function generateTokenEntityId(tokenAddress: Address): string {
  return generateEntityIdFromAddress(tokenAddress);
}

export function generateERC1155TransferEntityId(
  txHash: Bytes,
  logIndex: BigInt,
  actionIndex: number,
  batchIndex: number
): string {
  return [
    generateEntityIdFromBytes(txHash),
    logIndex.toString(),
    actionIndex.toString(),
    batchIndex.toString(),
  ].join('_');
}

export function generateVoterEntityId(
  memberEntityId: string,
  proposalId: string
): string {
  return [memberEntityId, proposalId].join('_');
}

export function generateMemberEntityId(
  pluginAddress: Address,
  memberAddress: Address
): string {
  return [
    generateEntityIdFromAddress(pluginAddress),
    generateEntityIdFromAddress(memberAddress),
  ].join('_');
}

export function generateVoteEntityId(
  memberAddress: Address,
  proposalId: string
): string {
  return [generateEntityIdFromAddress(memberAddress), proposalId].join('_');
}

export function generateAdministratorAdminPluginEntityId(
  pluginAddress: Address,
  administratorAddress: Address
): string {
  return [
    generateEntityIdFromAddress(pluginAddress),
    generateEntityIdFromAddress(administratorAddress),
  ].join('_');
}


### File: /home/errick/core/packages/subgraph/src/utils/bytes.ts ###
import {BigInt, ByteArray, Bytes} from '@graphprotocol/graph-ts';

export function bigIntToBytes32(input: BigInt): string {
  const hexString = input
    .toHexString() // convert to hex, example: 0x1
    .slice(2) // remove 0x
    .padStart(64, '0'); // pad left with '0' until reaching target length of 32 bytes
  return `0x${hexString}`; // add 0x to the start
}

export function getMethodSignature(data: Bytes): string {
  return data.toHexString().slice(0, 10);
}

export function stringToBytes(input: string): Bytes {
  return Bytes.fromByteArray(ByteArray.fromUTF8(input));
}


### File: /home/errick/core/packages/subgraph/src/utils/tokens/common.ts ###
import {BigInt, Bytes} from '@graphprotocol/graph-ts';

export const onERC721Received = '0x150b7a02';
export const ERC721_safeTransferFromNoData = '0x42842e0e';
export const ERC721_safeTransferFromWithData = '0xb88d4fde';
export const ERC721_transferFrom = '0x23b872dd';

export const ERC20_transfer = '0xa9059cbb';
export const ERC20_transferFrom = '0x23b872dd';

export const onERC1155Received = '0xf23a6e61'; // `bytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"))` (i.e. 0xf23a6e61) if it accepts the transfer.
export const onERC1155BatchReceived = '0xbc197c81'; // `bytes4(keccak256("onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"))` (i.e. 0xbc197c81) if it accepts the transfer(s).
export const ERC1155_safeTransferFrom = '0xf242432a'; // `bytes4(keccak256("safeTransferFrom(address,address,uint256,uint256,bytes)"))` (i.e. 0xf242432a).
export const ERC1155_safeBatchTransferFrom = '0x2eb2c2d6'; // `bytes4(keccak256("safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"))` (i.e. 0x2eb2c2d6).

export enum TransferType {
  Withdraw,
  Deposit,
}

export const DECODE_OFFSET =
  '0x0000000000000000000000000000000000000000000000000000000000000020';

export const ERC165_INTERFACE_ID = '01ffc9a7';
export const ERC1155_INTERFACE_ID = 'd9b67a26';

// Unique ID generation for token transfer entities
export function getTransferId(
  txHash: Bytes,
  logIndex: BigInt,
  actionIndex: number
): string {
  return txHash
    .toHexString()
    .concat('_')
    .concat(logIndex.toString())
    .concat('_')
    .concat(actionIndex.toString());
}

// Unique ID generation for token balance entities
export function getBalanceId(daoId: string, token: string): string {
  return daoId.concat('_').concat(token);
}

// Unique ID generation for token balance entities
export function getTokenIdBalanceId(
  daoId: string,
  token: string,
  tokenId: BigInt
): string {
  return daoId.concat('_').concat(token).concat('_').concat(tokenId.toString());
}

// Unique ID generation for ERC1155 transfers
export function getERC1155TransferId(
  txHash: Bytes,
  logIndex: BigInt,
  actionIndex: number,
  batchIndex: number
): string {
  return (
    txHash
      .toHexString()
      .concat('_')
      .concat(logIndex.toString())
      .concat('_')
      .concat(actionIndex.toString())
      .concat('_')
      // add iteration for supporting batch transfers
      .concat(batchIndex.toString())
  );
}


### File: /home/errick/core/packages/subgraph/src/utils/tokens/erc721.ts ###
import {
  ERC721Balance,
  ERC721Contract,
  ERC721Transfer,
} from '../../../generated/schema';
import {ERC721} from '../../../generated/templates/DaoTemplateV1_0_0/ERC721';
import {getMethodSignature} from '../bytes';
import {supportsInterface} from '../erc165';
import {generateTokenEntityId} from '../ids';
import {DECODE_OFFSET, TransferType} from './common';
import {
  ERC721_safeTransferFromNoData,
  ERC721_safeTransferFromWithData,
  ERC721_transferFrom,
} from './common';
import {
  generateDaoEntityId,
  generateTransferEntityId,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes, ethereum} from '@graphprotocol/graph-ts';

function supportsERC721(token: Address): bool {
  // Double check that it's ERC721 by calling supportsInterface checks.
  let erc721 = ERC721.bind(token);
  let introspection_01ffc9a7 = supportsInterface(erc721, '01ffc9a7'); // ERC165
  let introspection_80ac58cd = supportsInterface(erc721, '80ac58cd'); // ERC721
  let introspection_ffffffff = supportsInterface(erc721, 'ffffffff', false);
  return (
    introspection_01ffc9a7 && introspection_80ac58cd && introspection_ffffffff
  );
}

export function fetchERC721(address: Address): ERC721Contract | null {
  let erc721 = ERC721.bind(address);

  // Try load entry
  let contract = ERC721Contract.load(address.toHexString());
  if (contract != null) {
    return contract;
  }

  // Detect using ERC165
  if (!supportsERC721(address)) {
    return null;
  }

  contract = new ERC721Contract(address.toHexString());

  let try_name = erc721.try_name();
  let try_symbol = erc721.try_symbol();
  contract.name = try_name.reverted ? '' : try_name.value;
  contract.symbol = try_symbol.reverted ? '' : try_symbol.value;

  contract.save();

  return contract;
}

export function updateERC721Balance(
  daoId: string,
  token: string,
  tokenId: BigInt,
  timestamp: BigInt,
  type: TransferType
): void {
  let balanceId = daoId.concat('_').concat(token);
  let erc721Balance = ERC721Balance.load(balanceId);

  if (!erc721Balance) {
    erc721Balance = new ERC721Balance(balanceId);
    erc721Balance.dao = daoId;
    erc721Balance.token = token;
    erc721Balance.tokenIds = [];
  }

  let tokenIds = erc721Balance.tokenIds;
  if (type == TransferType.Withdraw) {
    tokenIds.splice(tokenIds.indexOf(tokenId), 1);
  } else {
    tokenIds.push(tokenId);
  }

  erc721Balance.tokenIds = tokenIds;
  erc721Balance.lastUpdated = timestamp;
  erc721Balance.save();
}

export function handleERC721Received(
  token: Address,
  dao: Address,
  data: Bytes,
  event: ethereum.Event
): void {
  let contract = fetchERC721(token);
  if (!contract) {
    return;
  }

  let calldata = DECODE_OFFSET + data.toHexString().slice(10);
  let decodeABI = '(address,address,uint256,bytes)';

  let decoded = ethereum.decode(decodeABI, Bytes.fromHexString(calldata));

  if (!decoded) {
    return;
  }

  let tuple = decoded.toTuple();
  let from = tuple[1].toAddress();
  let tokenId = tuple[2].toBigInt();

  let daoEntityId = generateDaoEntityId(dao);

  updateERC721Balance(
    daoEntityId,
    generateTokenEntityId(token),
    tokenId,
    event.block.timestamp,
    TransferType.Deposit
  );

  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    0
  );

  let transfer = new ERC721Transfer(transferEntityId);
  transfer.from = from;
  transfer.to = dao;
  transfer.dao = daoEntityId;
  transfer.token = contract.id;
  transfer.tokenId = tokenId;
  transfer.txHash = event.transaction.hash;
  transfer.createdAt = event.block.timestamp;
  transfer.type = 'Deposit';
  transfer.save();
}

export function handleERC721Action(
  token: Address,
  dao: Address,
  data: Bytes,
  actionBatchId: string,
  actionIndex: number,
  event: ethereum.Event
): bool {
  let contract = fetchERC721(token);
  if (!contract) return false;

  let functionSelector = getMethodSignature(data);
  let decodeABI = determineERC721DecodeABI(functionSelector);

  if (!decodeABI) return false;

  let calldata = getCalldata(functionSelector, data);
  let decoded = ethereum.decode(
    decodeABI as string,
    Bytes.fromHexString(calldata)
  );
  if (!decoded) return false;

  let transfer = createERC721Transfer(
    decoded.toTuple(),
    contract,
    dao,
    event,
    actionBatchId,
    actionIndex
  );

  if (transfer.from == dao && transfer.to == dao) {
    transfer.type = 'Withdraw';
  } else if (transfer.from != dao && transfer.to != dao) {
    // If from/to both aren't equal to dao, it means
    // dao must have been approved for the `tokenId`
    // and played the role of transfering between 2 parties.
    transfer.type = 'ExternalTransfer';
  } else if (transfer.from != dao && transfer.to == dao) {
    // 1. some party `y` approved `x` tokenId to the dao.
    // 2. dao calls transferFrom as an action to transfer it from `y` to itself.
    transfer.type = 'Deposit';
    updateERC721Balance(
      transfer.dao,
      transfer.token,
      transfer.tokenId,
      event.block.timestamp,
      TransferType.Deposit
    );
  } else {
    transfer.type = 'Withdraw';
    updateERC721Balance(
      transfer.dao,
      transfer.token,
      transfer.tokenId,
      event.block.timestamp,
      TransferType.Withdraw
    );
  }

  transfer.save();
  return true;
}

function determineERC721DecodeABI(functionSelector: string): string | null {
  if (
    functionSelector == ERC721_transferFrom ||
    functionSelector == ERC721_safeTransferFromNoData
  ) {
    return '(address,address,uint256)';
  } else if (functionSelector == ERC721_safeTransferFromWithData) {
    return '(address,address,uint256,bytes)';
  }
  return null;
}

function getCalldata(functionSelector: string, data: Bytes): string {
  if (functionSelector == ERC721_safeTransferFromWithData) {
    return DECODE_OFFSET + data.toHexString().slice(10);
  }
  return data.toHexString().slice(10);
}

function createERC721Transfer(
  tuple: ethereum.Tuple,
  contract: ERC721Contract,
  dao: Address,
  event: ethereum.Event,
  actionBatchId: string,
  actionIndex: number
): ERC721Transfer {
  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    actionIndex as i32
  );
  let daoEntityId = generateDaoEntityId(dao);
  let transfer = new ERC721Transfer(transferEntityId);
  transfer.from = tuple[0].toAddress();
  transfer.to = tuple[1].toAddress();
  transfer.dao = daoEntityId;
  transfer.token = contract.id;
  transfer.tokenId = tuple[2].toBigInt();
  transfer.actionBatch = actionBatchId;
  transfer.txHash = event.transaction.hash;
  transfer.createdAt = event.block.timestamp;

  return transfer;
}


### File: /home/errick/core/packages/subgraph/src/utils/tokens/erc1155.ts ###
import {
  ERC1155Balance,
  ERC1155Contract,
  ERC1155TokenIdBalance,
  ERC1155Transfer,
} from '../../../generated/schema';
import {ERC1155} from '../../../generated/templates/DaoTemplateV1_0_0/ERC1155';
import {getMethodSignature} from '../bytes';
import {supportsInterface} from '../erc165';
import {generateTokenEntityId} from '../ids';
import {
  DECODE_OFFSET,
  ERC1155_INTERFACE_ID,
  ERC1155_safeBatchTransferFrom,
  ERC1155_safeTransferFrom,
  ERC165_INTERFACE_ID,
  TransferType,
  getBalanceId,
  getERC1155TransferId,
  getTokenIdBalanceId,
} from './common';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes, ethereum} from '@graphprotocol/graph-ts';

export function supportsERC1155(token: Address): bool {
  // Double check that it's ERC1155 by calling supportsInterface checks.
  let erc1155 = ERC1155.bind(token);
  let introspection_ERC165 = supportsInterface(erc1155, ERC165_INTERFACE_ID); // ERC165
  let introspection_ERC1155 = supportsInterface(erc1155, ERC1155_INTERFACE_ID); // ERC1155
  let introspection_ffffffff = supportsInterface(erc1155, 'ffffffff', false);
  return (
    introspection_ERC165 && introspection_ERC1155 && introspection_ffffffff
  );
}

export function fetchERC1155(address: Address): ERC1155Contract | null {
  // Try load entry
  let contract = ERC1155Contract.load(address.toHexString());
  if (contract != null) {
    return contract;
  }

  // Detect using ERC165
  if (!supportsERC1155(address)) {
    return null;
  }
  contract = new ERC1155Contract(address.toHexString());
  contract.save();

  return contract;
}

export function updateERC1155Balance(
  daoId: string,
  token: string,
  tokenId: BigInt,
  amount: BigInt,
  timestamp: BigInt,
  type: TransferType
): void {
  // generate unique balance id
  let balanceId = getBalanceId(daoId, token);
  // load balance
  let erc1155Balance = ERC1155Balance.load(balanceId);

  if (!erc1155Balance) {
    // if not exists create it
    erc1155Balance = new ERC1155Balance(balanceId);
    erc1155Balance.dao = daoId;
    erc1155Balance.token = token;
    let erc1155 = ERC1155.bind(Address.fromString(token));
    let metadataUri = erc1155.uri(tokenId);
    erc1155Balance.metadataUri = metadataUri;
  }
  // update lastUpdated
  erc1155Balance.lastUpdated = timestamp;
  // generate unique tokenIdBalanceId
  let tokenIdBalanceId = getTokenIdBalanceId(daoId, token, tokenId);
  // load tokenIdbalnce
  let erc1155TokenIdBalance = ERC1155TokenIdBalance.load(tokenIdBalanceId);
  // if not exists create it
  if (!erc1155TokenIdBalance) {
    erc1155TokenIdBalance = new ERC1155TokenIdBalance(tokenIdBalanceId);
    erc1155TokenIdBalance.amount = amount;
    erc1155TokenIdBalance.tokenId = tokenId;
    erc1155TokenIdBalance.balance = balanceId;
  } else {
    // if exists update it
    if (type == TransferType.Deposit) {
      erc1155TokenIdBalance.amount = erc1155TokenIdBalance.amount.plus(amount);
    } else {
      erc1155TokenIdBalance.amount = erc1155TokenIdBalance.amount.minus(amount);
    }
  }
  // update lastUpdated
  erc1155TokenIdBalance.lastUpdated = timestamp;
  // save
  erc1155Balance.save();
  erc1155TokenIdBalance.save();
}

export function handleERC1155Received(
  token: Address,
  dao: Address,
  data: Bytes,
  event: ethereum.Event
): void {
  let contract = fetchERC1155(token);
  if (!contract) {
    return;
  }
  let calldata = data.toHexString().slice(10);
  calldata = DECODE_OFFSET.concat(calldata);
  let decodeABI = '(address,address,uint256,uint256,bytes)';
  let decoded = ethereum.decode(decodeABI, Bytes.fromHexString(calldata));
  if (!decoded) {
    return;
  }
  let tuple = decoded.toTuple();
  let operator = tuple[0].toAddress();
  let from = tuple[1].toAddress();
  // in single transfer create a single transfer
  let tokenId = tuple[2].toBigInt();
  let amount = tuple[3].toBigInt();
  // generate unique transfer id
  let transferId = getERC1155TransferId(
    event.transaction.hash,
    event.transactionLogIndex,
    0,
    0
  );
  // create transfer
  createErc1155Transfer(
    transferId,
    operator,
    from,
    dao, // to field, the to field is going to be always the dao because is the one handling the onERC1155Received callback
    dao,
    token,
    tokenId,
    amount,
    null,
    event.transaction.hash,
    event.block.timestamp
  );
}

export function handleERC1155BatchReceived(
  token: Address,
  dao: Address,
  data: Bytes,
  event: ethereum.Event
): void {
  let contract = fetchERC1155(token);
  if (!contract) {
    return;
  }
  let calldata = data.toHexString().slice(10);
  calldata = DECODE_OFFSET.concat(calldata);

  let decodeABI = '(address,address,uint256[],uint256[],bytes)';
  let decoded = ethereum.decode(decodeABI, Bytes.fromHexString(calldata));
  if (!decoded) {
    return;
  }
  let tuple = decoded.toTuple();
  let operator = tuple[0].toAddress();
  let from = tuple[1].toAddress();
  let tokenIds = tuple[2].toBigIntArray();
  let amounts = tuple[3].toBigIntArray();
  // in batch transfer iterate over the tokenIds and create a transfer for each
  for (let i = 0; i < tokenIds.length; i++) {
    // generate unique transfer id by adding the index of the tokenIds array
    let transferId = getERC1155TransferId(
      event.transaction.hash,
      event.transactionLogIndex,
      0,
      i
    );
    // create transfer
    createErc1155Transfer(
      transferId,
      operator,
      from,
      dao, // to field, the to field is going to be always the dao because is the one handling the onERC1155Received callback
      dao,
      token,
      tokenIds[i],
      amounts[i],
      null,
      event.transaction.hash,
      event.block.timestamp
    );
  }
}

export function handleERC1155Action(
  token: Address,
  dao: Address,
  data: Bytes,
  actionBatchId: string,
  actionIndex: number,
  event: ethereum.Event
): bool {
  let contract = fetchERC1155(token);
  if (!contract) {
    return false;
  }

  let functionSelector = getMethodSignature(data);
  let decodeABI = determineERC1155DecodeABI(functionSelector);

  // If decodeABI is not determined, return false
  if (!decodeABI) return false;

  let calldata = DECODE_OFFSET + data.toHexString().slice(10);
  let bytes = Bytes.fromHexString(calldata);
  let decoded = ethereum.decode(decodeABI as string, bytes);

  if (!decoded) {
    return false;
  }

  let tuple = decoded.toTuple();

  if (functionSelector == ERC1155_safeTransferFrom) {
    handleERC1155SingleTransfer(
      tuple,
      dao,
      token,
      actionBatchId,
      event,
      actionIndex
    );
  } else if (functionSelector == ERC1155_safeBatchTransferFrom) {
    handleERC1155BatchTransfer(
      tuple,
      dao,
      token,
      actionBatchId,
      event,
      actionIndex
    );
  }

  return true;
}

function determineERC1155DecodeABI(functionSelector: string): string | null {
  if (functionSelector == ERC1155_safeTransferFrom) {
    return '(address,address,uint256,uint256,bytes)';
  }

  if (functionSelector == ERC1155_safeBatchTransferFrom) {
    return '(address,address,uint256[],uint256[],bytes)';
  }

  return null;
}

function handleERC1155SingleTransfer(
  tuple: ethereum.Tuple,
  dao: Address,
  token: Address,
  actionBatchId: string,
  event: ethereum.Event,
  actionIndex: number
): void {
  let tokenId = tuple[2].toBigInt();
  let amount = tuple[3].toBigInt();

  // generate unique transfer id
  let transferId = getERC1155TransferId(
    event.transaction.hash,
    event.transactionLogIndex,
    actionIndex,
    0
  );

  createErc1155Transfer(
    transferId,
    dao, // operator field, the operator is going to be the dao since is the one executing the action
    tuple[0].toAddress(),
    tuple[1].toAddress(),
    dao,
    token,
    tokenId,
    amount,
    actionBatchId,
    event.transaction.hash,
    event.block.timestamp
  );
}

function handleERC1155BatchTransfer(
  tuple: ethereum.Tuple,
  dao: Address,
  token: Address,
  proposalId: string,
  event: ethereum.Event,
  actionIndex: number
): void {
  let tokenIds = tuple[2].toBigIntArray();
  let amounts = tuple[3].toBigIntArray();

  // in batch transfer iterate over the tokenIds and create a transfer for each
  for (let i = 0; i < tokenIds.length; i++) {
    // generate unique transfer id by adding the index of the tokenIds array
    let transferId = getERC1155TransferId(
      event.transaction.hash,
      event.transactionLogIndex,
      actionIndex,
      i
    );

    createErc1155Transfer(
      transferId,
      dao, // operator field, the operator is going to be the dao since is the one executing the action
      tuple[0].toAddress(),
      tuple[1].toAddress(),
      dao,
      token,
      tokenIds[i],
      amounts[i],
      proposalId,
      event.transaction.hash,
      event.block.timestamp
    );
  }
}

function createErc1155Transfer(
  transferId: string,
  operator: Address,
  from: Address,
  to: Address,
  dao: Address,
  token: Address,
  tokenId: BigInt,
  amount: BigInt,
  actionBatchId: string | null,
  txHash: Bytes,
  timestamp: BigInt
): void {
  let daoEntityId = generateDaoEntityId(dao);
  let tokenEntityId = generateTokenEntityId(token);
  // create transfer
  let transfer = new ERC1155Transfer(transferId);
  transfer.from = from;
  transfer.to = to;
  transfer.operator = operator;
  transfer.dao = daoEntityId;
  transfer.token = tokenEntityId;
  transfer.amount = amount;
  transfer.tokenId = tokenId;
  transfer.actionBatch = actionBatchId;
  transfer.txHash = txHash;
  transfer.createdAt = timestamp;
  // check the transfer type
  if (from == dao && to == dao) {
    transfer.type = 'Withdraw';
    transfer.save();
    return;
  }
  // If from/to both aren't equal to dao, it means
  // dao must have been approved for the `tokenId`
  // and played the role of transfering between 2 parties.
  if (from != dao && to != dao) {
    transfer.type = 'ExternalTransfer';
    transfer.save();
    return;
  }
  if (from != dao && to == dao) {
    // 1. some party `y` approved `x` tokenId to the dao.
    // 2. dao calls transferFrom as an action to transfer it from `y` to itself.
    transfer.type = 'Deposit';
    updateERC1155Balance(
      daoEntityId,
      tokenEntityId,
      tokenId,
      amount,
      timestamp,
      TransferType.Deposit
    );
  } else {
    transfer.type = 'Withdraw';

    updateERC1155Balance(
      daoEntityId,
      tokenEntityId,
      tokenId,
      amount,
      timestamp,
      TransferType.Withdraw
    );
  }
  transfer.save();
}


### File: /home/errick/core/packages/subgraph/src/utils/tokens/eth.ts ###
import {NativeBalance, NativeTransfer} from '../../../generated/schema';
import {ADDRESS_ZERO} from '../constants';
import {TransferType} from './common';
import {
  generateBalanceEntityId,
  generateDaoEntityId,
  generateTransferEntityId,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, ethereum} from '@graphprotocol/graph-ts';

export function updateNativeBalance(
  dao: Address,
  amount: BigInt,
  timestamp: BigInt,
  type: TransferType
): void {
  let balanceEntityId = generateBalanceEntityId(
    dao,
    Address.fromString(ADDRESS_ZERO)
  );
  let daoEntityId = generateDaoEntityId(dao);
  let nativeBalance = NativeBalance.load(balanceEntityId);

  if (!nativeBalance) {
    nativeBalance = new NativeBalance(balanceEntityId);
    nativeBalance.dao = daoEntityId;
    nativeBalance.balance = BigInt.zero();
  }

  nativeBalance.balance =
    type == TransferType.Deposit
      ? nativeBalance.balance.plus(amount)
      : nativeBalance.balance.minus(amount);
  nativeBalance.lastUpdated = timestamp;
  nativeBalance.save();
}

export function handleNativeDeposit(
  dao: Address,
  from: Address,
  amount: BigInt,
  reference: string,
  event: ethereum.Event
): void {
  let daoEntityId = generateDaoEntityId(dao);

  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    0
  );

  let transfer = new NativeTransfer(transferEntityId);
  transfer.from = from;
  transfer.to = dao;
  transfer.dao = daoEntityId;
  transfer.amount = amount;
  transfer.reference = reference;
  transfer.txHash = event.transaction.hash;
  transfer.createdAt = event.block.timestamp;
  transfer.type = 'Deposit';
  transfer.save();

  if (from == dao) {
    return;
  }

  updateNativeBalance(dao, amount, event.block.timestamp, TransferType.Deposit);
}

export function handleNativeAction(
  dao: Address,
  to: Address,
  amount: BigInt,
  reference: string,
  actionBatchId: string,
  actionIndex: number,
  event: ethereum.Event
): void {
  let daoEntityId = generateDaoEntityId(dao);

  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    actionIndex as i32
  );

  let transfer = new NativeTransfer(transferEntityId);
  transfer.from = dao;
  transfer.to = to;
  transfer.dao = daoEntityId;
  transfer.amount = amount;
  transfer.reference = reference;
  transfer.txHash = event.transaction.hash;
  transfer.createdAt = event.block.timestamp;
  transfer.actionBatch = actionBatchId;
  transfer.type = 'Withdraw';
  transfer.save();

  if (dao == to) {
    return;
  }

  updateNativeBalance(
    dao,
    amount,
    event.block.timestamp,
    TransferType.Withdraw
  );
}


### File: /home/errick/core/packages/subgraph/src/utils/tokens/erc20.ts ###
import {
  ERC20Balance,
  ERC20Contract,
  ERC20Transfer,
} from '../../../generated/schema';
import {ERC20} from '../../../generated/templates/DaoTemplateV1_0_0/ERC20';
import {generateTokenEntityId} from '../ids';
import {ERC20_transfer, ERC20_transferFrom} from './common';
import {
  generateBalanceEntityId,
  generateDaoEntityId,
  generateTransferEntityId,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes, ethereum} from '@graphprotocol/graph-ts';

export function fetchOrCreateERC20Entity(
  address: Address
): ERC20Contract | null {
  const tokenEntityId = generateTokenEntityId(address);
  let erc20 = ERC20.bind(address);

  // Try load entry
  let contract = ERC20Contract.load(tokenEntityId);
  if (contract != null) {
    return contract;
  }

  contract = new ERC20Contract(tokenEntityId);

  let try_name = erc20.try_name();
  let try_symbol = erc20.try_symbol();
  let try_decimals = erc20.try_decimals();

  // Extra check to make sure contract is ERC20.
  let totalSupply = erc20.try_totalSupply();
  let balanceOf = erc20.try_balanceOf(address);
  if (totalSupply.reverted || balanceOf.reverted) {
    return null;
  }

  contract.name = try_name.reverted ? '' : try_name.value;
  contract.symbol = try_symbol.reverted ? '' : try_symbol.value;
  contract.decimals = try_decimals.reverted ? 18 : try_decimals.value;
  contract.save();

  return contract;
}

/**
 * @param token The address of the token
 * @return entityId The entity ID of the ERC20 token if it exists, null otherwise.
 */
export function fetchOrCreateERC20TokenEntity(token: Address): string | null {
  let contract = fetchOrCreateERC20Entity(token);
  if (!contract) {
    return null;
  }
  return contract.id;
}

export function updateERC20Balance(
  token: Address,
  dao: Address,
  timestamp: BigInt
): void {
  let erc20 = ERC20.bind(token);
  let balance = erc20.try_balanceOf(dao);

  // if reverted, means it's not ERC20.
  if (balance.reverted) {
    return;
  }

  let daoEntityId = generateDaoEntityId(dao);
  let balanceEntityId = generateBalanceEntityId(dao, token);
  let tokenEntityId = generateTokenEntityId(token);

  let erc20Balance = ERC20Balance.load(balanceEntityId);

  if (!erc20Balance) {
    erc20Balance = new ERC20Balance(balanceEntityId);
    erc20Balance.dao = daoEntityId;
    erc20Balance.token = tokenEntityId;
    erc20Balance.balance = BigInt.zero();
  }

  erc20Balance.balance = balance.value;
  erc20Balance.lastUpdated = timestamp;
  erc20Balance.save();
}

export function handleERC20Action(
  token: Address,
  dao: Address,
  actionBatchId: string,
  data: Bytes,
  actionIndex: number,
  event: ethereum.Event
): void {
  let tokenAddress = fetchOrCreateERC20TokenEntity(token);
  if (!tokenAddress) {
    return;
  }

  let decodeABI = '';

  let functionSelector = data.toHexString().substring(0, 10);
  let calldata = data.toHexString().slice(10);

  if (functionSelector == ERC20_transfer) {
    decodeABI = '(address,uint256)';
  }

  if (functionSelector == ERC20_transferFrom) {
    decodeABI = '(address,address,uint256)';
  }

  let decoded = ethereum.decode(decodeABI, Bytes.fromHexString(calldata));

  if (!decoded) {
    return;
  }

  let tuple = decoded.toTuple();

  let from = new Address(0);
  let to = new Address(0);
  let amount = BigInt.zero();

  if (functionSelector == ERC20_transfer) {
    from = dao;
    to = tuple[0].toAddress();
    amount = tuple[1].toBigInt();
  }

  if (functionSelector == ERC20_transferFrom) {
    from = tuple[0].toAddress();
    to = tuple[1].toAddress();
    amount = tuple[2].toBigInt();
  }

  let daoEntityId = generateDaoEntityId(dao);

  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    actionIndex as i32
  );

  let transfer = new ERC20Transfer(transferEntityId);

  transfer.from = from;
  transfer.to = to;
  transfer.dao = daoEntityId;
  transfer.amount = amount;
  transfer.txHash = event.transaction.hash;
  transfer.createdAt = event.block.timestamp;
  transfer.token = tokenAddress as string;
  transfer.actionBatch = actionBatchId;

  // If from/to both aren't equal to dao, it means
  // dao must have been approved for the `tokenId`
  // and played the role of transfering between 2 parties.
  if (from != dao && to != dao) {
    transfer.type = 'ExternalTransfer';
    transfer.save();
    return;
  }

  if (from != dao && to == dao) {
    // 1. some party `y` approved `x` tokenId to the dao.
    // 2. dao calls transferFrom as an action to transfer it from `y` to itself.
    transfer.type = 'Deposit';

    updateERC20Balance(token, dao, event.block.timestamp);
  } else {
    // from is dao address, to is some other address
    transfer.type = 'Withdraw';

    updateERC20Balance(token, dao, event.block.timestamp);
  }

  transfer.save();
}

export function handleERC20Deposit(
  dao: Address,
  token: Address,
  from: Address,
  amount: BigInt,
  event: ethereum.Event
): void {
  let tokenAddress = fetchOrCreateERC20TokenEntity(token);
  if (!tokenAddress) {
    return;
  }

  let daoEntityId = generateDaoEntityId(dao);

  let transferEntityId = generateTransferEntityId(
    event.transaction.hash,
    event.transactionLogIndex,
    0
  );

  let erc20Transfer = new ERC20Transfer(transferEntityId);

  erc20Transfer.from = from;
  erc20Transfer.to = dao;
  erc20Transfer.dao = daoEntityId;
  erc20Transfer.amount = amount;
  erc20Transfer.txHash = event.transaction.hash;
  erc20Transfer.createdAt = event.block.timestamp;
  erc20Transfer.token = tokenAddress as string;
  erc20Transfer.type = 'Deposit';

  erc20Transfer.save();

  updateERC20Balance(token, dao, event.block.timestamp);
}


### File: /home/errick/core/packages/subgraph/src/registries/daoRegistry.ts ###
import {DAORegistered} from '../../generated/DAORegistry/DAORegistry';
import {Dao} from '../../generated/schema';
import {DaoTemplateV1_0_0, DaoTemplateV1_3_0} from '../../generated/templates';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';
import {dataSource} from '@graphprotocol/graph-ts';

// blocklists of addresses for which we don't index the subdomain.
// Put the reason next to the address as a comment
const subdomain_blocklist_mainnet = [
  '0x16070493aa513f91fc8957f14b7b7c6c0c41fbac', // domain squatting lido.dao.eth
];

export function handleDAORegistered(event: DAORegistered): void {
  let daoAddress = event.params.dao; // use dao address as id, because it should not repeat
  let daoEntityId = generateDaoEntityId(daoAddress);
  let entity = new Dao(daoEntityId);

  if (!isInSubdomainBlocklist(daoEntityId)) {
    entity.subdomain = event.params.subdomain;
  }

  entity.creator = event.params.creator;
  entity.createdAt = event.block.timestamp;
  entity.txHash = event.transaction.hash;

  // subscribe to both templates for different execution handling
  // check manifest file for details on how event handling is
  // differentiated between templates
  DaoTemplateV1_0_0.create(daoAddress);
  DaoTemplateV1_3_0.create(daoAddress);

  entity.save();
}

// checks if a certain address is in the blocklist. Returns false by default
function isInSubdomainBlocklist(address: string): bool {
  // switch case doesn't work with assemblyscript
  if (dataSource.network() == 'mainnet') {
    return subdomain_blocklist_mainnet.includes(address);
  }

  return false;
}


### File: /home/errick/core/packages/subgraph/src/registries/pluginRepoRegistry.ts ###
import {PluginRepoRegistered} from '../../generated/PluginRepoRegistry/PluginRepoRegistry';
import {PluginRepo} from '../../generated/schema';
import {PluginRepoTemplate} from '../../generated/templates';
import {generatePluginRepoEntityId} from '@aragon/osx-commons-subgraph';

export function handlePluginRepoRegistered(event: PluginRepoRegistered): void {
  let pluginRepoAddress = event.params.pluginRepo;
  let pluginRepoEntityId = generatePluginRepoEntityId(pluginRepoAddress);
  let entity = new PluginRepo(pluginRepoEntityId);

  entity.subdomain = event.params.subdomain;

  // subscribe to templates
  PluginRepoTemplate.create(pluginRepoAddress);

  entity.save();
}


### File: /home/errick/core/packages/subgraph/src/dao/dao_v1_0_0.ts ###
import {
  Dao,
  Permission,
  StandardCallback,
  ActionBatch,
} from '../../generated/schema';
import {
  MetadataSet,
  Executed,
  Deposited,
  NativeTokenDeposited,
  Granted,
  Revoked,
  TrustedForwarderSet,
  StandardCallbackRegistered,
  CallbackReceived,
  NewURI,
} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {ADDRESS_ZERO} from '../utils/constants';
import {
  onERC1155BatchReceived,
  onERC1155Received,
  onERC721Received,
} from '../utils/tokens/common';
import {handleERC20Deposit} from '../utils/tokens/erc20';
import {handleERC721Received} from '../utils/tokens/erc721';
import {
  handleERC1155BatchReceived,
  handleERC1155Received,
} from '../utils/tokens/erc1155';
import {handleNativeDeposit} from '../utils/tokens/eth';
import {
  generateDeterministicActionBatchId,
  generateActionBatchEntityId,
} from './ids';
import {handleAction} from './utils';
import {
  generateDaoEntityId,
  generatePermissionEntityId,
  generateStandardCallbackEntityId,
} from '@aragon/osx-commons-subgraph';
import {BigInt, Bytes, store} from '@graphprotocol/graph-ts';

export function handleMetadataSet(event: MetadataSet): void {
  let daoId = generateDaoEntityId(event.address);
  let metadata = event.params.metadata.toString();
  _handleMetadataSet(daoId, metadata);
}

export function _handleMetadataSet(daoId: string, metadata: string): void {
  let entity = Dao.load(daoId);
  if (entity) {
    entity.metadata = metadata;
    entity.save();
  }
}

export function handleCallbackReceived(event: CallbackReceived): void {
  let functionSig = event.params.sig;

  if (functionSig.equals(Bytes.fromHexString(onERC721Received))) {
    handleERC721Received(
      event.params.sender,
      event.address,
      event.params.data,
      event
    );
  }
  if (functionSig.equals(Bytes.fromHexString(onERC1155Received))) {
    handleERC1155Received(
      event.params.sender,
      event.address,
      event.params.data,
      event
    );
  }
  if (functionSig.equals(Bytes.fromHexString(onERC1155BatchReceived))) {
    handleERC1155BatchReceived(
      event.params.sender,
      event.address,
      event.params.data,
      event
    );
  }
}

export function handleExecuted(event: Executed): void {
  const actionBatchEntityId = generateActionBatchEntityId(
    event.params.actor /* caller */,
    event.address /* daoAddress */,
    event.params.callId,
    event.transaction.hash,
    event.transactionLogIndex
  );

  const deterministicId = generateDeterministicActionBatchId(
    event.params.actor /* caller */,
    event.address /* daoAddress */,
    event.params.callId
  );

  const actionBatch = new ActionBatch(actionBatchEntityId);
  actionBatch.dao = generateDaoEntityId(event.address);
  actionBatch.deterministicId = deterministicId;
  actionBatch.createdAt = event.block.timestamp;
  actionBatch.creator = event.params.actor;
  actionBatch.executionTxHash = event.transaction.hash;
  // Since DAO v1.0.0 doesn't emit allowFailureMap by mistake, we got no choice now.
  // In such case, `allowFailureMap` shouldn't be fully trusted.
  actionBatch.allowFailureMap = BigInt.zero();
  actionBatch.executed = true;
  actionBatch.failureMap = event.params.failureMap;
  actionBatch.save();

  let actions = event.params.actions;

  for (let index = 0; index < actions.length; index++) {
    handleAction(actions[index], actionBatchEntityId, index, event);
  }
}

// ERC20 + Native
export function handleDeposited(event: Deposited): void {
  if (event.params.token.toHexString() != ADDRESS_ZERO) {
    handleERC20Deposit(
      event.address,
      event.params.token,
      event.params.sender,
      event.params.amount,
      event
    );
    return;
  }
  handleNativeDeposit(
    event.address,
    event.params.sender,
    event.params.amount,
    event.params._reference,
    event
  );
}

export function handleNativeTokenDeposited(event: NativeTokenDeposited): void {
  handleNativeDeposit(
    event.address,
    event.params.sender,
    event.params.amount,
    'Native Deposit',
    event
  );
}

export function handleGranted(event: Granted): void {
  const contractAddress = event.address;
  const where = event.params.where;
  const permissionId = event.params.permissionId;
  const who = event.params.who;

  const permissionEntityId = generatePermissionEntityId(
    contractAddress,
    permissionId,
    where,
    who
  );

  // Permission
  let permissionEntity = Permission.load(permissionEntityId);
  if (!permissionEntity) {
    permissionEntity = new Permission(permissionEntityId);
    permissionEntity.where = where;
    permissionEntity.permissionId = permissionId;
    permissionEntity.who = who;
    permissionEntity.actor = event.params.here;
    permissionEntity.condition = event.params.condition;

    permissionEntity.dao = generateDaoEntityId(contractAddress);
    permissionEntity.save();
  }
}

export function handleRevoked(event: Revoked): void {
  // permission
  const contractAddress = event.address;
  const where = event.params.where;
  const permissionId = event.params.permissionId;
  const who = event.params.who;

  const permissionEntityId = generatePermissionEntityId(
    contractAddress,
    permissionId,
    where,
    who
  );

  let permissionEntity = Permission.load(permissionEntityId);
  if (permissionEntity) {
    store.remove('Permission', permissionEntityId);
  }
}

export function handleTrustedForwarderSet(event: TrustedForwarderSet): void {
  let daoId = generateDaoEntityId(event.address);
  let entity = Dao.load(daoId);
  if (entity) {
    entity.trustedForwarder = event.params.forwarder;
    entity.save();
  }
}

export function handleStandardCallbackRegistered(
  event: StandardCallbackRegistered
): void {
  let daoAddress = event.address;
  let interfaceId = event.params.interfaceId;

  let daoId = generateDaoEntityId(daoAddress);
  let entityId = generateStandardCallbackEntityId(daoAddress, interfaceId);
  let entity = StandardCallback.load(entityId);
  if (!entity) {
    entity = new StandardCallback(entityId);
    entity.dao = daoId;
  }
  entity.interfaceId = interfaceId;
  entity.callbackSelector = event.params.callbackSelector;
  entity.magicNumber = event.params.magicNumber;
  entity.save();
}

export function handleNewURI(event: NewURI): void {
  let daoEntityId = generateDaoEntityId(event.address);
  let entity = Dao.load(daoEntityId);
  if (entity) {
    entity.daoURI = event.params.daoURI;
    entity.save();
  }
}


### File: /home/errick/core/packages/subgraph/src/dao/dao_v1_3_0.ts ###
import {ActionBatch} from '../../generated/schema';
import {
  Executed,
  ExecutedActionsStruct,
} from '../../generated/templates/DaoTemplateV1_3_0/DAO';
import {
  generateDeterministicActionBatchId,
  generateActionBatchEntityId,
} from './ids';
import {handleAction} from './utils';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';

export function handleExecuted(event: Executed): void {
  let actionBatchEntityId = generateActionBatchEntityId(
    event.params.actor,
    event.address,
    event.params.callId,
    event.transaction.hash,
    event.transactionLogIndex
  );

  let deterministicId = generateDeterministicActionBatchId(
    event.params.actor,
    event.address,
    event.params.callId
  );

  let actionBatch = new ActionBatch(actionBatchEntityId);

  actionBatch.dao = generateDaoEntityId(event.address);
  actionBatch.deterministicId = deterministicId;
  actionBatch.createdAt = event.block.timestamp;
  actionBatch.creator = event.params.actor;
  actionBatch.executionTxHash = event.transaction.hash;
  actionBatch.allowFailureMap = event.params.allowFailureMap;
  actionBatch.executed = true;
  actionBatch.failureMap = event.params.failureMap;
  actionBatch.save();

  let actions = event.params.actions;

  for (let index = 0; index < actions.length; index++) {
    handleAction<ExecutedActionsStruct, Executed>(
      actions[index],
      actionBatchEntityId,
      index,
      event
    );
  }
}


### File: /home/errick/core/packages/subgraph/src/dao/utils.ts ###
import {Action} from '../../generated/schema';
import {
  Executed,
  ExecutedActionsStruct,
} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {getMethodSignature} from '../utils/bytes';
import {
  ERC721_transferFrom,
  ERC721_safeTransferFromNoData,
  ERC721_safeTransferFromWithData,
  ERC20_transfer,
  ERC20_transferFrom,
  ERC1155_safeBatchTransferFrom,
  ERC1155_safeTransferFrom,
} from '../utils/tokens/common';
import {handleERC20Action} from '../utils/tokens/erc20';
import {handleERC721Action} from '../utils/tokens/erc721';
import {handleERC1155Action} from '../utils/tokens/erc1155';
import {handleNativeAction} from '../utils/tokens/eth';
import {generateActionEntityId, generateDeterministicActionId} from './ids';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';
import {BigInt} from '@graphprotocol/graph-ts';

export function handleAction<
  T extends ExecutedActionsStruct,
  R extends Executed
>(action: T, actionBatchId: string, index: i32, event: R): void {
  let actionEntity = getOrCreateActionEntity(
    action,
    actionBatchId,
    index,
    event
  );
  actionEntity.execResult = event.params.execResults[index];
  actionEntity.save();

  if (isNativeTokenAction(action)) {
    handleNativeAction(
      event.address,
      action.to,
      action.value,
      'Native Token Withdraw',
      actionBatchId,
      index,
      event
    );
    return;
  }

  handleTokenTransfers(action, actionBatchId, index, event);
}

function getOrCreateActionEntity<
  T extends ExecutedActionsStruct,
  R extends Executed
>(action: T, actionBatchId: string, index: i32, event: R): Action {
  const deterministicActionId = generateDeterministicActionId(
    event.params.actor,
    event.address,
    event.params.callId,
    index
  );
  const actionId = generateActionEntityId(
    event.params.actor,
    event.address,
    event.params.callId,
    index,
    event.transaction.hash,
    event.transactionLogIndex
  );

  const entity = new Action(actionId);
  entity.deterministicId = deterministicActionId;
  entity.to = action.to;
  entity.value = action.value;
  entity.data = action.data;
  entity.actionBatch = actionBatchId;
  entity.dao = generateDaoEntityId(event.address);

  return entity;
}

/**
 * Determines if the action is an ERC20, ERC721 or ERC1155 transfer and calls the appropriate handler if so.
 * Does nothing if the action is not a recognised token transfer.
 * @param action the action to validate
 * @param actionBatchId the id container for a single set of executed actions
 * @param actionIndex the index number of the action inside the executed batch
 * @param event the Executed event emitting the event
 */
function handleTokenTransfers<
  T extends ExecutedActionsStruct,
  R extends Executed
>(action: T, actionBatchId: string, actionIndex: i32, event: R): void {
  const methodSig = getMethodSignature(action.data);

  let handledByErc721: bool = false;
  let handledByErc1155: bool = false;

  if (isERC721Transfer(methodSig)) {
    handledByErc721 = handleERC721Action(
      action.to,
      event.address,
      action.data,
      actionBatchId,
      actionIndex,
      event
    );
  }

  if (isERC1155TransferMethod(methodSig)) {
    handledByErc1155 = handleERC1155Action(
      action.to,
      event.address,
      action.data,
      actionBatchId,
      actionIndex,
      event
    );
  }

  if (isERC20Transfer(methodSig) && !handledByErc721 && !handledByErc1155) {
    handleERC20Action(
      action.to,
      event.address,
      actionBatchId,
      action.data,
      actionIndex,
      event
    );
  }
}

function isERC721Transfer(methodSig: string): bool {
  return [
    ERC721_transferFrom,
    ERC721_safeTransferFromNoData,
    ERC721_safeTransferFromWithData,
  ].includes(methodSig);
}

function isERC20Transfer(methodSig: string): bool {
  return [ERC20_transfer, ERC20_transferFrom].includes(methodSig);
}

function isNativeTokenAction<T extends ExecutedActionsStruct>(action: T): bool {
  return action.data.toHexString() === '0x' && action.value.gt(BigInt.zero());
}

function isERC1155TransferMethod(methodSig: string): bool {
  return [ERC1155_safeBatchTransferFrom, ERC1155_safeTransferFrom].includes(
    methodSig
  );
}


### File: /home/errick/core/packages/subgraph/src/dao/ids.ts ###
import {Address, BigInt, Bytes} from '@graphprotocol/graph-ts';

/**
 * @param caller - The address (plugin or otherwise) that called `execute`
 * @param daoAddress - The address of the DAO in which the actions were executed
 * @param callId - The bytes32 ID of the call, passed by the caller - should be unique but not guaranteed
 * @returns A string representing a deterministic identifier for the transaction action entity.
 * This should be unique but due to callId being passed by the user, it is not guaranteed.
 * Clients can use this ID to filter to specific executions, but should check for duplicates.
 */
export function generateDeterministicActionBatchId(
  caller: Address,
  daoAddress: Address,
  callId: Bytes
): string {
  return [
    caller.toHexString(),
    daoAddress.toHexString(),
    callId.toHexString(),
  ].join('_');
}

/**
 * @param caller - The address (plugin or otherwise) that called `execute`
 * @param daoAddress - The address of the DAO in which the actions were executed
 * @param callId - The ID of the call, passed by the caller - should be unique but not guaranteed
 * @param txHash - The hash of the transaction.
 * @param transactionLogIndex - The index of the log within the transaction.
 * We don't need the logIndex because the Tx hash is unique enough.
 * @returns A string representing the unique identifier for the transaction action entity.
 * This will be globally unique to avoid data loss but cannot be known ahead of execution due
 * to inclusion of Tx data.
 */
export function generateActionBatchEntityId(
  caller: Address,
  daoAddress: Address,
  callId: Bytes,
  txHash: Bytes,
  transactionLogIndex: BigInt
): string {
  return [
    generateDeterministicActionBatchId(caller, daoAddress, callId),
    txHash.toHexString(),
    transactionLogIndex.toHexString(),
  ].join('_');
}

/**
 * @param caller - The address (plugin or otherwise) that called `execute`
 * @param daoAddress - The address of the DAO in which the actions were executed
 * @param callId - The bytes32 ID of the call, passed by the caller - should be unique but not guaranteed
 * @param actionIndex - The index of the action within the call
 * @returns A string representing a deterministic identifier for the action entity.
 * This should be unique but due to callId being passed by the user, it is not guaranteed.
 * Clients can use this ID to filter to specific executions, but should check for duplicates.
 */
export function generateDeterministicActionId(
  caller: Address,
  daoAddress: Address,
  callId: Bytes,
  actionIndex: i32
): string {
  return [
    caller.toHexString(),
    daoAddress.toHexString(),
    callId.toHexString(),
    actionIndex.toString(),
  ].join('_');
}

/**
 * @param caller - The address (plugin or otherwise) that called `execute`
 * @param daoAddress - The address of the DAO in which the actions were executed
 * @param callId - The bytes32 ID of the call, passed by the caller - should be unique but not guaranteed
 * @param actionIndex - The index of the action within the call
 * @param txHash - The hash of the transaction.
 * @param transactionLogIndex - The index of the log within the transaction.
 * We don't need the logIndex because the Tx hash is unique enough.
 * @returns A string representing the unique identifier for the  action entity.
 * This will be globally unique to avoid data loss but cannot be known ahead of execution due
 * to inclusion of Tx data.
 */
export function generateActionEntityId(
  caller: Address,
  daoAddress: Address,
  callId: Bytes,
  actionIndex: i32,
  txHash: Bytes,
  transactionLogIndex: BigInt
): string {
  return [
    generateDeterministicActionId(caller, daoAddress, callId, actionIndex),
    txHash.toHexString(),
    transactionLogIndex.toString(),
  ].join('_');
}


### File: /home/errick/core/packages/subgraph/tests/schema-extender.ts ###
import {CodeBlockWriter, Project} from 'ts-morph';

function main() {
  const project = new Project();
  const sourceFile = project.addSourceFileAtPath('./generated/schema.ts');
  const sourceMethodFile = project.addSourceFileAtPath(
    './tests/helpers/method-classes.ts'
  );

  const outputFile = project.createSourceFile(
    './tests/helpers/extended-schema.ts',
    '',
    {
      overwrite: true,
    }
  );

  // Get original Entity classes
  const sourceClasses = sourceFile.getClasses();

  // Get additional method classes
  const sourceMethodClasses = sourceMethodFile.getClasses();

  // Add all imports from sourcemethod-classes
  const methodsImportDeclarations = sourceMethodFile.getImportDeclarations();
  methodsImportDeclarations.forEach(importDeclaration => {
    if (
      importDeclaration.getModuleSpecifierValue() !== '../../generated/schema'
    ) {
      outputFile.addImportDeclaration(importDeclaration.getStructure());
    }
  });

  // Import assert into generated file
  outputFile.addImportDeclaration({
    namedImports: ['assert', 'log'],
    moduleSpecifier: `matchstick-as`,
  });

  // Add import statements for the original classes
  const sourceFileNameWithoutExtension =
    sourceFile.getBaseNameWithoutExtension();
  outputFile.addImportDeclaration({
    namedImports: sourceClasses.map(
      classDeclaration => classDeclaration.getName() as string
    ),
    moduleSpecifier: `../../generated/${sourceFileNameWithoutExtension}`,
  });

  // Iterate through the classes in the source file
  sourceClasses.forEach(classDeclaration => {
    // Create a new class based on the original one
    const originalClassName = classDeclaration.getName() as string;
    const newClassName = `Extended${originalClassName}`;
    const newClass = outputFile.addClass({
      name: newClassName,
      isExported: true,
      extends: originalClassName,
    });

    // Create a new constructor that calls super() with a default id.
    newClass.addConstructor({
      parameters: [],
      statements: (writer: CodeBlockWriter) => {
        const defaultEntityId = '0x1';
        writer.writeLine(`super('${defaultEntityId}');`);
      },
    });

    // add methods to generated classes
    sourceMethodClasses.forEach(classDeclaration => {
      if (classDeclaration.getName() === `${originalClassName}Methods`) {
        const methods = classDeclaration.getMethods();

        methods.forEach(method => {
          let returnType = method.getReturnTypeNode()?.getText() || '';
          if (returnType === `${originalClassName}Methods`) {
            returnType = `Extended${originalClassName}`;
          }

          // Get the type parameters
          const typeParameters = method
            .getTypeParameters()
            .map(param => param.getText());

          const newMethod = newClass.addMethod({
            name: method.getName(),
            returnType: returnType,
            typeParameters: typeParameters, // Add the type parameters to the new method
          });

          const parameters = method.getParameters().map(parameter => {
            return {
              name: parameter.getName(),
              type: parameter.getTypeNode()?.getText() || '',
              hasQuestionToken: parameter.hasQuestionToken(),
              initializer: parameter.getInitializer()?.getText(),
              decorators: parameter
                .getDecorators()
                .map(decorator => decorator.getStructure()),
            };
          });

          newMethod.addParameters(parameters);

          const statements = method
            .getStatements()
            .map(statement => statement.getText());
          newMethod.addStatements(statements);
        });
      }
    });

    newClass.addMethod({
      name: 'buildOrUpdate',
      returnType: 'void',
      statements: (writer: CodeBlockWriter) => {
        writer.writeLine('this.save();');
      },
    });

    newClass.addMethod({
      name: 'assertEntity',
      returnType: 'void',
      parameters: [
        {
          name: 'debug',
          type: 'boolean',
          initializer: 'false',
        },
      ],
      statements: (writer: CodeBlockWriter) => {
        writer.writeLine(`let entity = ${originalClassName}.load(this.id);`);
        writer.writeLine(`if (!entity) throw new Error("Entity not found");`);
        writer.writeLine(`let entries = entity.entries;`);
        writer.write('for (let i = 0; i < entries.length; i++)').block(() => {
          writer.writeLine(`let key = entries[i].key;`);

          writer.write('if (debug)').block(() => {
            writer.writeLine(`log.debug('asserting for key: {}', [key]);`);
          });

          writer.writeLine(`let value = this.get(key);`);

          writer
            .write('if (!value)')
            .block(() => {
              writer.write('if (debug)').block(() => {
                writer.writeLine(
                  `log.debug('value is null for key: {}', [key]);`
                );
              });
            })
            .write('else')
            .block(() => {
              writer.write('if (debug)').block(() => {
                writer.writeLine(
                  `log.debug('asserting with value: {}', [value.displayData()]);`
                );
              });

              writer.writeLine(
                `assert.fieldEquals("${originalClassName}", this.id, key, value.displayData());`
              );
            });
        });
      },
    });
  });

  // Save the changes
  outputFile.saveSync();
}

main();


### File: /home/errick/core/packages/subgraph/tests/constants.ts ###
import {generateActionBatchEntityId} from '../src/dao/ids';
import {
  generatePluginEntityId,
  generateProposalEntityId,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes} from '@graphprotocol/graph-ts';

export const ADDRESS_ZERO = '0x0000000000000000000000000000000000000000';
export const ADDRESS_ONE = '0x0000000000000000000000000000000000000001';
export const ADDRESS_TWO = '0x0000000000000000000000000000000000000002';
export const ADDRESS_THREE = '0x0000000000000000000000000000000000000003';
export const ADDRESS_FOUR = '0x0000000000000000000000000000000000000004';
export const ADDRESS_FIVE = '0x0000000000000000000000000000000000000005';
export const ADDRESS_SIX = '0x0000000000000000000000000000000000000006';
export const ADDRESS_SEVEN = '0x0000000000000000000000000000000000000007';
export const DAO_ADDRESS = '0x00000000000000000000000000000000000000da';
export const CONTRACT_ADDRESS = '0x00000000000000000000000000000000000000Ad';
export const DAO_TOKEN_ADDRESS = '0x6B175474E89094C44Da98b954EedeAC495271d0F';
export const DEFAULT_MOCK_EVENT_ADDRESS =
  '0xA16081F360e3847006dB660bae1c6d1b2e17eC2A';

export const ZERO = '0';
export const ONE = '1';
export const TWO = '2';
export const THREE = '3';

export const PLUGIN_PROPOSAL_ID = ZERO;

export const STRING_DATA = 'Some String Data ...';

export const ONE_ETH = '1000000000000000000';
export const HALF_ETH = '500000000000000000';

export const ERC20_AMOUNT_HALF = '10000';
export const ERC20_AMOUNT_FULL = '20000';
export const ERC20_TOTAL_SUPPLY = '10';
export const ERC20_DECIMALS = '6';
export const TOKEN_SYMBOL = 'symbol';
export const TOKEN_NAME = 'name';

export const HOUR = '3600';
export const SNAPSHOT_BLOCK = '100';

// Use 1 for testing as default value is anyways 0
// and test might succeed even though it shouldn't
export const ALLOW_FAILURE_MAP = '1';
export const CREATED_AT = ONE;

export const ZERO_BYTES32 =
  '0x0000000000000000000000000000000000000000000000000000000000000000';
export const ONE_BYTES32 =
  '0x0000000000000000000000000000000000000000000000000000000000000001';

export const HALF_UINT256_BYTES32 =
  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';
export const MAX_UINT256_BYTES32 =
  '0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff';

export const MAX_UINT256_NUMBER_STRING =
  '115792089237316195423570985008687907853269984665640564039457584007913129639935';

export const PLUGIN_SETUP_ID =
  '0xfb3fd2c4cd4e19944dd3f8437e67476240cd9e3efb2294ebd10c59c8f1d6817c';
export const APPLIED_PLUGIN_SETUP_ID =
  '0x00000000cd4e19944dd3f8437e67476240cd9e3efb2294ebd10c59c8f1d6817c';

export const ACTION_BATCH_ID = generateActionBatchEntityId(
  Address.fromString(CONTRACT_ADDRESS),
  Address.fromString(DAO_ADDRESS),
  Bytes.fromHexString(ONE_BYTES32),
  Bytes.fromHexString(HALF_UINT256_BYTES32),
  BigInt.fromString('1')
);

export const PROPOSAL_ENTITY_ID = generateProposalEntityId(
  Address.fromString(CONTRACT_ADDRESS),
  BigInt.fromString(PLUGIN_PROPOSAL_ID)
);

export const PLUGIN_ENTITY_ID = generatePluginEntityId(
  Address.fromString(CONTRACT_ADDRESS)
);


### File: /home/errick/core/packages/subgraph/tests/utils.ts ###
import {Address, BigInt, ethereum} from '@graphprotocol/graph-ts';
import {createMockedFunction} from 'matchstick-as/assembly/index';

export function createMockGetter(
  contractAddress: string,
  funcName: string,
  funcSignature: string,
  returns: ethereum.Value[]
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    funcName,
    funcSignature
  )
    .withArgs([])
    .returns(returns);
}

export function createGetProposalCall(
  contractAddress: string,
  proposalId: string,
  open: boolean,
  executed: boolean,

  votingMode: string,
  supportThreshold: string,
  minVotingPower: string,
  startDate: string,
  endDate: string,
  snapshotBlock: string,

  abstain: string,
  yes: string,
  no: string,

  actions: ethereum.Tuple[],
  allowFailureMap: string
): void {
  let parameters = new ethereum.Tuple();

  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(votingMode))
  );
  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(supportThreshold))
  );
  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(startDate))
  );
  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(endDate))
  );
  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(snapshotBlock))
  );
  parameters.push(
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(minVotingPower))
  );

  let tally = new ethereum.Tuple();

  tally.push(ethereum.Value.fromUnsignedBigInt(BigInt.fromString(abstain)));
  tally.push(ethereum.Value.fromUnsignedBigInt(BigInt.fromString(yes)));
  tally.push(ethereum.Value.fromUnsignedBigInt(BigInt.fromString(no)));

  createMockedFunction(
    Address.fromString(contractAddress),
    'getProposal',
    'getProposal(uint256):(bool,bool,(uint8,uint32,uint64,uint64,uint64,uint256),(uint256,uint256,uint256),(address,uint256,bytes)[],uint256)'
  )
    .withArgs([
      ethereum.Value.fromUnsignedBigInt(BigInt.fromString(proposalId)),
    ])
    .returns([
      ethereum.Value.fromBoolean(open),
      ethereum.Value.fromBoolean(executed),

      // ProposalParameters
      ethereum.Value.fromTuple(parameters),

      // Tally
      ethereum.Value.fromTuple(tally),

      ethereum.Value.fromTupleArray(actions),

      ethereum.Value.fromUnsignedBigInt(BigInt.fromString(allowFailureMap)),
    ]);
}

export function createTotalVotingPowerCall(
  contractAddress: string,
  blockNumber: string,

  totalVotingPower: string
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'totalVotingPower',
    'totalVotingPower(uint256):(uint256)'
  )
    .withArgs([
      ethereum.Value.fromUnsignedBigInt(BigInt.fromString(blockNumber)),
    ])
    .returns([
      ethereum.Value.fromUnsignedBigInt(BigInt.fromString(totalVotingPower)),
    ]);
}


### File: /home/errick/core/packages/subgraph/tests/permission-manager/utils.ts ###
import {Address, Bytes, ethereum} from '@graphprotocol/graph-ts';
import {newMockEvent} from 'matchstick-as';

export function createNewGrantedEvent<T>(
  contractPermissionId: Bytes,
  actor: string,
  where: string,
  who: string,
  condition: string,
  contractAddress: string
): T {
  let newGrantedEvent = changetype<T>(newMockEvent());

  newGrantedEvent.address = Address.fromString(contractAddress);
  newGrantedEvent.parameters = [];

  let contractPermissionIdParam = new ethereum.EventParam(
    'contractPermissionId',
    ethereum.Value.fromBytes(contractPermissionId)
  );
  let actorParam = new ethereum.EventParam(
    'actor',
    ethereum.Value.fromAddress(Address.fromString(actor))
  );
  let whereParam = new ethereum.EventParam(
    'where',
    ethereum.Value.fromAddress(Address.fromString(where))
  );
  let whoParam = new ethereum.EventParam(
    'who',
    ethereum.Value.fromAddress(Address.fromString(who))
  );
  let conditionParam = new ethereum.EventParam(
    'condition',
    ethereum.Value.fromAddress(Address.fromString(condition))
  );

  newGrantedEvent.parameters.push(contractPermissionIdParam);
  newGrantedEvent.parameters.push(actorParam);
  newGrantedEvent.parameters.push(whereParam);
  newGrantedEvent.parameters.push(whoParam);
  newGrantedEvent.parameters.push(conditionParam);

  return newGrantedEvent as T;
}

export function createNewRevokedEvent<T>(
  contractPermissionId: Bytes,
  actor: string,
  where: string,
  who: string,
  contractAddress: string
): T {
  let newGrantedEvent = changetype<T>(newMockEvent());

  newGrantedEvent.address = Address.fromString(contractAddress);
  newGrantedEvent.parameters = [];

  let contractPermissionIdParam = new ethereum.EventParam(
    'contractPermissionId',
    ethereum.Value.fromBytes(contractPermissionId)
  );
  let actorParam = new ethereum.EventParam(
    'actor',
    ethereum.Value.fromAddress(Address.fromString(actor))
  );
  let whereParam = new ethereum.EventParam(
    'where',
    ethereum.Value.fromAddress(Address.fromString(where))
  );
  let whoParam = new ethereum.EventParam(
    'who',
    ethereum.Value.fromAddress(Address.fromString(who))
  );

  newGrantedEvent.parameters.push(contractPermissionIdParam);
  newGrantedEvent.parameters.push(actorParam);
  newGrantedEvent.parameters.push(whereParam);
  newGrantedEvent.parameters.push(whoParam);

  return newGrantedEvent as T;
}


### File: /home/errick/core/packages/subgraph/tests/permission-manager/permission-manager.test.ts ###
import {
  Granted as DaoGrantedEvent,
  Revoked as DaoRevokedEvent,
} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {
  Granted as RepoGrantedEvent,
  Revoked as RepoRevokedEvent,
} from '../../generated/templates/PluginRepoTemplate/PluginRepo';
import {
  handleGranted as daoHandleGranted,
  handleRevoked as daoHandleRevoked,
} from '../../src/dao/dao_v1_0_0';
import {
  handleGranted as repoHandleGranted,
  handleRevoked as repoHandleRevoked,
} from '../../src/plugin/pluginRepo';
import {CONTRACT_ADDRESS, DAO_ADDRESS} from '../constants';
import {ExtendedPermission} from '../helpers/extended-schema';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';
import {Address} from '@graphprotocol/graph-ts';
import {assert, clearStore, test} from 'matchstick-as/assembly/index';

const daoAddress = Address.fromString(DAO_ADDRESS);
const pluginRepoAddress = Address.fromString(CONTRACT_ADDRESS);
const daoEntityId = generateDaoEntityId(daoAddress);
const pluginRepoEntityId = generateDaoEntityId(pluginRepoAddress);

// DAO
test('Run dao (handleGranted) mappings with mock event', () => {
  let permission = new ExtendedPermission().withDefaultValues(daoEntityId);
  permission.dao = daoEntityId;

  let grantedEvent =
    permission.createEvent_Granted<DaoGrantedEvent>(daoEntityId);

  // handle event
  daoHandleGranted(grantedEvent);

  // checks
  permission.assertEntity();

  clearStore();
});

test('Run dao (handleRevoked) mappings with mock event', () => {
  let permission = new ExtendedPermission().withDefaultValues(daoEntityId);
  permission.dao = daoEntityId;

  permission.save();

  // check state exist
  permission.assertEntity();

  // create event and run it's handler
  let revokedEvent =
    permission.createEvent_Revoked<DaoRevokedEvent>(daoEntityId);

  // handle event
  daoHandleRevoked(revokedEvent);

  // checks
  assert.notInStore('Permission', permission.id);

  clearStore();
});

// PluginRepo
test('Run PluginRepo (handleGranted) mappings with mock event', () => {
  let permission = new ExtendedPermission().withDefaultValues(
    pluginRepoEntityId
  );
  permission.pluginRepo = pluginRepoEntityId;

  let grantedEvent =
    permission.createEvent_Granted<RepoGrantedEvent>(pluginRepoEntityId);

  // handle event
  repoHandleGranted(grantedEvent);

  // checks
  permission.assertEntity();

  clearStore();
});

test('Run PluginRepo (handleRevoked) mappings with mock event', () => {
  let permission = new ExtendedPermission().withDefaultValues(
    pluginRepoEntityId
  );
  permission.pluginRepo = pluginRepoEntityId;

  permission.save();

  // check state exist
  permission.assertEntity();

  // create event and run it's handler
  let revokedEvent =
    permission.createEvent_Revoked<RepoRevokedEvent>(pluginRepoEntityId);

  // handle event
  repoHandleRevoked(revokedEvent);

  // checks
  assert.notInStore('Permission', permission.id);

  clearStore();
});


### File: /home/errick/core/packages/subgraph/tests/plugin/pluginRepo.test.ts ###
import {
  handleReleaseMetadataUpdated,
  handleVersionCreated,
} from '../../src/plugin/pluginRepo';
import {ADDRESS_ONE, ONE} from '../constants';
import {createReleaseMetadataUpdatedEvent, createVersionCreated} from './utils';
import {
  generatePluginReleaseEntityId,
  generatePluginRepoEntityId,
  generatePluginVersionEntityId,
} from '@aragon/osx-commons-subgraph';
import {Bytes} from '@graphprotocol/graph-ts';
import {assert, clearStore, test} from 'matchstick-as/assembly/index';

test('PluginRepo (handleVersionCreated) mappings with mock event', () => {
  let release = ONE;
  let build = ONE;
  let pluginSetup = ADDRESS_ONE;
  let buildMetadata = 'Qm1234';

  let event = createVersionCreated(
    release,
    build,
    pluginSetup,
    Bytes.fromUTF8(buildMetadata)
  );

  handleVersionCreated(event);

  let pluginVersionEntityId = generatePluginVersionEntityId(
    event.address,
    parseInt(release) as i32,
    parseInt(build) as i32
  );

  let pluginReleaseEntityId = generatePluginReleaseEntityId(
    event.address,
    parseInt(release) as i32
  );

  assert.entityCount('PluginVersion', 1);
  assert.fieldEquals(
    'PluginVersion',
    pluginVersionEntityId,
    'id',
    pluginVersionEntityId
  );
  assert.fieldEquals(
    'PluginVersion',
    pluginVersionEntityId,
    'pluginRepo',
    event.address.toHexString()
  );
  assert.fieldEquals(
    'PluginVersion',
    pluginVersionEntityId,
    'release',
    pluginReleaseEntityId
  );
  assert.fieldEquals('PluginVersion', pluginVersionEntityId, 'build', build);
  assert.fieldEquals(
    'PluginVersion',
    pluginVersionEntityId,
    'pluginSetup',
    pluginSetup
  );
  assert.fieldEquals(
    'PluginVersion',
    pluginVersionEntityId,
    'metadata',
    buildMetadata
  );

  assert.entityCount('PluginSetup', 1);
  assert.fieldEquals('PluginSetup', pluginSetup, 'id', pluginSetup);

  clearStore();
});

test('PluginRepo (handleReleaseMetadataUpdated) mappings with mock event', () => {
  let release = ONE;
  let releaseMetadata = 'Qm1234';

  let event = createReleaseMetadataUpdatedEvent(
    release,
    Bytes.fromUTF8(releaseMetadata)
  );

  handleReleaseMetadataUpdated(event);

  assert.entityCount('PluginRelease', 1);

  let pluginRepoEntityId = generatePluginRepoEntityId(event.address);
  let pluginReleaseEntityId = generatePluginReleaseEntityId(
    event.address,
    parseInt(release) as i32
  );

  assert.fieldEquals(
    'PluginRelease',
    pluginReleaseEntityId,
    'id',
    pluginReleaseEntityId
  );
  assert.fieldEquals(
    'PluginRelease',
    pluginReleaseEntityId,
    'pluginRepo',
    pluginRepoEntityId
  );
  assert.fieldEquals(
    'PluginRelease',
    pluginReleaseEntityId,
    'release',
    release
  );
  assert.fieldEquals(
    'PluginRelease',
    pluginReleaseEntityId,
    'metadata',
    releaseMetadata
  );

  // simulated update of release metadata
  let updatedMetadata = 'Qm5678';
  let updatingMetadataEvent = createReleaseMetadataUpdatedEvent(
    release,
    Bytes.fromUTF8(updatedMetadata)
  );
  handleReleaseMetadataUpdated(updatingMetadataEvent);

  assert.entityCount('PluginRelease', 1);

  assert.fieldEquals(
    'PluginRelease',
    pluginReleaseEntityId,
    'metadata',
    updatedMetadata
  );
});


### File: /home/errick/core/packages/subgraph/tests/plugin/utils.ts ###
import {
  InstallationApplied,
  InstallationPrepared,
  InstallationPreparedPreparedSetupDataStruct,
  UninstallationApplied,
  UninstallationPrepared,
  UpdateApplied,
  UpdatePrepared,
  UpdatePreparedPreparedSetupDataStruct,
  UpdatePreparedSetupPayloadStruct,
} from '../../generated/PluginSetupProcessor/PluginSetupProcessor';
import {
  ReleaseMetadataUpdated,
  VersionCreated,
} from '../../generated/templates/PluginRepoTemplate/PluginRepo';
import {Address, BigInt, Bytes, ethereum} from '@graphprotocol/graph-ts';
import {newMockEvent} from 'matchstick-as';

export function createReleaseMetadataUpdatedEvent(
  release: string,
  buildMetadata: Bytes
): ReleaseMetadataUpdated {
  let newEvent = changetype<ReleaseMetadataUpdated>(newMockEvent());

  newEvent.parameters = [];

  let releaseParam = new ethereum.EventParam(
    'release',
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(release))
  );
  let buildMetadataParam = new ethereum.EventParam(
    'buildMetadata',
    ethereum.Value.fromBytes(buildMetadata)
  );

  newEvent.parameters.push(releaseParam);
  newEvent.parameters.push(buildMetadataParam);

  return newEvent;
}

export function createVersionCreated(
  release: string,
  build: string,
  pluginSetup: string,
  buildMetadata: Bytes
): VersionCreated {
  let newEvent = changetype<VersionCreated>(newMockEvent());

  newEvent.parameters = [];

  let releaseParam = new ethereum.EventParam(
    'release',
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(release))
  );

  let buildParam = new ethereum.EventParam(
    'build',
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(build))
  );
  let pluginSetupParam = new ethereum.EventParam(
    'pluginSetup',
    ethereum.Value.fromAddress(Address.fromString(pluginSetup))
  );

  let buildMetadataParam = new ethereum.EventParam(
    'buildMetadata',
    ethereum.Value.fromBytes(buildMetadata)
  );

  newEvent.parameters.push(releaseParam);
  newEvent.parameters.push(buildParam);
  newEvent.parameters.push(pluginSetupParam);
  newEvent.parameters.push(buildMetadataParam);

  return newEvent;
}

export function createInstallationPreparedEvent(
  sender: string,
  dao: string,
  plugin: string,
  preparedSetupId: Bytes,
  pluginSetupRepo: string,
  versionTag: ethereum.Tuple,
  data: Bytes,
  helpers: string[],
  requestedPermissions: ethereum.Value[][]
): InstallationPrepared {
  let newEvent = changetype<InstallationPrepared>(newMockEvent());
  newEvent.parameters = [];

  let permissions: ethereum.Tuple[] = [];
  for (let i = 0; i < requestedPermissions.length; i++) {
    let permissionTuple = new ethereum.Tuple();
    for (let a = 0; a < requestedPermissions[i].length; a++) {
      permissionTuple.push(requestedPermissions[i][a]);
    }
    permissions.push(permissionTuple);
  }

  let helpersArray: Address[] = [];
  for (let i = 0; i < helpers.length; i++) {
    helpersArray.push(Address.fromString(helpers[i]));
  }

  let preparedSetupData = new InstallationPreparedPreparedSetupDataStruct();
  preparedSetupData.push(ethereum.Value.fromAddressArray(helpersArray));
  preparedSetupData.push(ethereum.Value.fromTupleArray(permissions));

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(preparedSetupId)
  );
  let pluginSetupRepoParam = new ethereum.EventParam(
    'pluginSetupRepo',
    ethereum.Value.fromAddress(Address.fromString(pluginSetupRepo))
  );
  let versionTagParam = new ethereum.EventParam(
    'versionTag',
    ethereum.Value.fromTuple(versionTag)
  );
  let dataParam = new ethereum.EventParam(
    'data',
    ethereum.Value.fromBytes(data)
  );
  let pluginParam = new ethereum.EventParam(
    'plugin',
    ethereum.Value.fromAddress(Address.fromString(plugin))
  );
  let preparedSetupDataParam = new ethereum.EventParam(
    'preparedSetupData',
    ethereum.Value.fromTuple(preparedSetupData)
  );

  newEvent.parameters.push(senderParam);
  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(preparedSetupIdParam);
  newEvent.parameters.push(pluginSetupRepoParam);
  newEvent.parameters.push(versionTagParam);
  newEvent.parameters.push(dataParam);
  newEvent.parameters.push(pluginParam);
  newEvent.parameters.push(preparedSetupDataParam);
  return newEvent;
}

export function createInstallationAppliedEvent(
  dao: string,
  plugin: string,
  preparedSetupId: Bytes,
  appliedSetupId: Bytes
): InstallationApplied {
  let newEvent = changetype<InstallationApplied>(newMockEvent);
  newEvent.parameters = [];

  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let pluginParam = new ethereum.EventParam(
    'plugin',
    ethereum.Value.fromAddress(Address.fromString(plugin))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(preparedSetupId)
  );
  let appliedSetupIdParam = new ethereum.EventParam(
    'appliedSetupId',
    ethereum.Value.fromBytes(appliedSetupId)
  );

  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(pluginParam);
  newEvent.parameters.push(preparedSetupIdParam);
  newEvent.parameters.push(appliedSetupIdParam);
  return newEvent;
}

export function createUpdatePreparedEvent(
  sender: string,
  dao: string,
  plugin: string,
  preparedSetupId: Bytes,
  pluginSetupRepo: string,
  versionTag: ethereum.Tuple,
  currentHelpers: string[],
  helpers: string[],
  requestedPermissions: ethereum.Value[][],
  data: Bytes,
  initData: Bytes
): UpdatePrepared {
  let newEvent = changetype<UpdatePrepared>(newMockEvent());
  newEvent.parameters = [];

  let permissions: ethereum.Tuple[] = [];
  for (let i = 0; i < requestedPermissions.length; i++) {
    let permissionTuple = new ethereum.Tuple();
    for (let a = 0; a < requestedPermissions[i].length; a++) {
      permissionTuple.push(requestedPermissions[i][a]);
    }
    permissions.push(permissionTuple);
  }

  let helpersArray: Address[] = [];
  for (let i = 0; i < helpers.length; i++) {
    helpersArray.push(Address.fromString(helpers[i]));
  }

  let preparedSetupData = new UpdatePreparedPreparedSetupDataStruct();
  preparedSetupData.push(ethereum.Value.fromAddressArray(helpersArray));
  preparedSetupData.push(ethereum.Value.fromTupleArray(permissions));

  let currentHelpersArray: Address[] = [];
  for (let i = 0; i < currentHelpers.length; i++) {
    currentHelpersArray.push(Address.fromString(currentHelpers[i]));
  }
  let setupPayload = new UpdatePreparedSetupPayloadStruct();
  setupPayload.push(ethereum.Value.fromAddress(Address.fromString(plugin)));
  setupPayload.push(ethereum.Value.fromAddressArray(currentHelpersArray));
  setupPayload.push(ethereum.Value.fromBytes(data));

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(preparedSetupId)
  );
  let pluginSetupRepoParam = new ethereum.EventParam(
    'pluginSetupRepo',
    ethereum.Value.fromAddress(Address.fromString(pluginSetupRepo))
  );
  let versionTagParam = new ethereum.EventParam(
    'versionTag',
    ethereum.Value.fromTuple(versionTag)
  );
  let initDataParam = new ethereum.EventParam(
    'initData',
    ethereum.Value.fromBytes(initData)
  );
  let setupPayloadParam = new ethereum.EventParam(
    'setupPayload',
    ethereum.Value.fromTuple(setupPayload)
  );
  let preparedSetupDataParam = new ethereum.EventParam(
    'preparedSetupData',
    ethereum.Value.fromTuple(preparedSetupData)
  );

  newEvent.parameters.push(senderParam);
  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(preparedSetupIdParam);
  newEvent.parameters.push(pluginSetupRepoParam);
  newEvent.parameters.push(versionTagParam);
  newEvent.parameters.push(setupPayloadParam);
  newEvent.parameters.push(preparedSetupDataParam);
  newEvent.parameters.push(initDataParam);
  return newEvent;
}

export function createUpdateAppliedEvent(
  dao: string,
  plugin: string,
  preparedSetupId: Bytes,
  appliedSetupId: Bytes
): UpdateApplied {
  let newEvent = changetype<UpdateApplied>(newMockEvent);
  newEvent.parameters = [];

  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let pluginParam = new ethereum.EventParam(
    'plugin',
    ethereum.Value.fromAddress(Address.fromString(plugin))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(preparedSetupId)
  );
  let appliedSetupIdParam = new ethereum.EventParam(
    'appliedSetupId',
    ethereum.Value.fromBytes(appliedSetupId)
  );

  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(pluginParam);
  newEvent.parameters.push(preparedSetupIdParam);
  newEvent.parameters.push(appliedSetupIdParam);
  return newEvent;
}

export function createUninstallationPreparedEvent(
  sender: string,
  dao: string,
  preparedSetupId: Bytes,
  pluginSetupRepo: string,
  versionTag: ethereum.Tuple,
  plugin: string,
  currentHelpers: string[],
  data: Bytes,
  requestedPermissions: ethereum.Value[][]
): UninstallationPrepared {
  let newEvent = changetype<UninstallationPrepared>(newMockEvent());
  newEvent.parameters = [];

  let permissions: ethereum.Tuple[] = [];
  for (let i = 0; i < requestedPermissions.length; i++) {
    let permissionTuple = new ethereum.Tuple();
    for (let a = 0; a < requestedPermissions[i].length; a++) {
      permissionTuple.push(requestedPermissions[i][a]);
    }
    permissions.push(permissionTuple);
  }

  let currentHelpersArray: Address[] = [];
  for (let i = 0; i < currentHelpers.length; i++) {
    currentHelpersArray.push(Address.fromString(currentHelpers[i]));
  }
  let setupPayload = new UpdatePreparedSetupPayloadStruct();
  setupPayload.push(ethereum.Value.fromAddress(Address.fromString(plugin)));
  setupPayload.push(ethereum.Value.fromAddressArray(currentHelpersArray));
  setupPayload.push(ethereum.Value.fromBytes(data));

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(preparedSetupId)
  );
  let pluginSetupRepoParam = new ethereum.EventParam(
    'pluginSetupRepo',
    ethereum.Value.fromAddress(Address.fromString(pluginSetupRepo))
  );
  let versionTagParam = new ethereum.EventParam(
    'versionTag',
    ethereum.Value.fromTuple(versionTag)
  );
  let setupPayloadParam = new ethereum.EventParam(
    'setupPayload',
    ethereum.Value.fromTuple(setupPayload)
  );
  let permissionsParam = new ethereum.EventParam(
    'permissions',
    ethereum.Value.fromTupleArray(permissions)
  );

  newEvent.parameters.push(senderParam);
  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(preparedSetupIdParam);
  newEvent.parameters.push(pluginSetupRepoParam);
  newEvent.parameters.push(versionTagParam);
  newEvent.parameters.push(setupPayloadParam);
  newEvent.parameters.push(permissionsParam);

  return newEvent;
}

export function createUninstallationAppliedEvent(
  dao: string,
  plugin: string,
  preparedSetupId: string
): UninstallationApplied {
  let newEvent = changetype<UninstallationApplied>(newMockEvent);
  newEvent.parameters = [];

  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let pluginParam = new ethereum.EventParam(
    'plugin',
    ethereum.Value.fromAddress(Address.fromString(plugin))
  );
  let preparedSetupIdParam = new ethereum.EventParam(
    'preparedSetupId',
    ethereum.Value.fromBytes(Bytes.fromHexString(preparedSetupId))
  );

  newEvent.parameters.push(daoParam);
  newEvent.parameters.push(pluginParam);
  newEvent.parameters.push(preparedSetupIdParam);
  return newEvent;
}


### File: /home/errick/core/packages/subgraph/tests/plugin/pluginSetupProcessor.test.ts ###
import {PluginPreparation} from '../../generated/schema';
import {
  handleInstallationApplied,
  handleInstallationPrepared,
  handleUninstallationApplied,
  handleUninstallationPrepared,
  handleUpdateApplied,
  handleUpdatePrepared,
} from '../../src/plugin/pluginSetupProcessor';
import {PERMISSION_OPERATIONS} from '../../src/plugin/utils';
import {getSupportsInterface} from '../../tests/dao/utils';
import {
  ADDRESS_TWO,
  ADDRESS_THREE,
  DAO_ADDRESS,
  ADDRESS_FOUR,
  ADDRESS_FIVE,
  ADDRESS_ZERO,
  PLUGIN_SETUP_ID,
  ADDRESS_SIX,
  APPLIED_PLUGIN_SETUP_ID,
  CONTRACT_ADDRESS,
} from '../constants';
import {
  createInstallationAppliedEvent,
  createInstallationPreparedEvent,
  createUninstallationAppliedEvent,
  createUninstallationPreparedEvent,
  createUpdateAppliedEvent,
  createUpdatePreparedEvent,
} from './utils';
import {
  generateDaoEntityId,
  generatePluginEntityId,
  generatePluginInstallationEntityId,
  generatePluginPermissionEntityId,
  generatePluginPreparationEntityId,
  generatePluginRepoEntityId,
  generatePluginVersionEntityId,
} from '@aragon/osx-commons-subgraph';
import {Address, BigInt, Bytes, ethereum} from '@graphprotocol/graph-ts';
import {assert, clearStore, test} from 'matchstick-as';

const daoAddress = Address.fromString(DAO_ADDRESS);
const daoEntityId = generateDaoEntityId(daoAddress);
const pluginAddress = Address.fromString(CONTRACT_ADDRESS);
const pluginEntityId = generatePluginEntityId(pluginAddress);
const setupId = PLUGIN_SETUP_ID;
const pluginRepoAddress = Address.fromString(ADDRESS_TWO);
const pluginRepoEntityId = generatePluginRepoEntityId(pluginRepoAddress);

test('InstallationPrepared event', function () {
  let pluginVersionId = generatePluginVersionEntityId(pluginRepoAddress, 1, 1);
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get installationId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  let pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );

  let versionTuple = new ethereum.Tuple();
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromString('1')));
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromString('1')));

  let permissions = [
    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('0')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_ZERO)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x1234')),
    ],

    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('2')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_SIX)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x5678')),
    ],
  ];

  getSupportsInterface(pluginEntityId, '0xffffffff', false);

  let event = createInstallationPreparedEvent(
    ADDRESS_THREE,
    daoEntityId,
    pluginEntityId,
    Bytes.fromHexString(setupId),
    pluginRepoEntityId,
    versionTuple,
    Bytes.fromHexString('0x00'),
    [ADDRESS_FOUR, ADDRESS_FIVE],
    permissions
  );

  handleInstallationPrepared(event);

  assert.entityCount('PluginPreparation', 1);
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'id',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'installation',
    pluginInstallationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'creator',
    ADDRESS_THREE
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'preparedSetupId',
    setupId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginRepo',
    pluginRepoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginVersion',
    pluginVersionId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'data',
    '0x00'
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginAddress',
    pluginEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'type',
    'Installation'
  );

  let helpers = [
    Address.fromString(ADDRESS_FOUR),
    Address.fromString(ADDRESS_FIVE),
  ];
  let pluginPreparation = PluginPreparation.load(pluginPreparationEntityId);
  if (!pluginPreparation) {
    throw new Error(
      `PluginPrepation with id ${pluginPreparationEntityId} not found`
    );
  }

  assert.equals(
    ethereum.Value.fromBytesArray(pluginPreparation.helpers),
    ethereum.Value.fromAddressArray(helpers)
  );

  assert.entityCount('PluginPermission', permissions.length);
  for (let i = 0; i < permissions.length; i++) {
    let permission = permissions[i];
    let operation = permission[0].toI32();
    let pluginPermissionEntityId = generatePluginPermissionEntityId(
      pluginPreparationEntityId,
      operation,
      permission[1].toAddress(),
      permission[2].toAddress(),
      permission[4].toBytes()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'id',
      pluginPermissionEntityId
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'operation',
      PERMISSION_OPERATIONS.get(operation) || ''
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'where',
      permission[1].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'who',
      permission[2].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'permissionId',
      permission[4].toBytes().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'condition',
      permission[3].toAddress().toHexString()
    );
  }

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'InstallationPrepared'
  );

  // TODO: once matchstick can support polymorphism, we should have a test like:
  // @dev: create a DAO in state so that we can check if IPlugin will be linked to the DAO
  // let daoEntity = createDaoEntityState()
  // assert.i32Equals(daoEntity.plugins.length, 1);

  clearStore();
});

test('InstallationApplied event', function () {
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get installationId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  let pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );

  let event = createInstallationAppliedEvent(
    daoEntityId,
    pluginEntityId,
    Bytes.fromHexString(setupId),
    Bytes.fromHexString(APPLIED_PLUGIN_SETUP_ID)
  );
  handleInstallationApplied(event);

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'id',
    pluginInstallationEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'plugin',
    pluginEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'appliedPreparation',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'appliedSetupId',
    APPLIED_PLUGIN_SETUP_ID
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'Installed'
  );

  clearStore();
});

test('UpdatePrepared event', function () {
  const build = 1;
  const release = 2;
  const pluginVersionEntityId = generatePluginVersionEntityId(
    pluginRepoAddress,
    build,
    release
  );
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get installationId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  const pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );

  let versionTuple = new ethereum.Tuple();
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromI32(build)));
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromI32(release)));

  let permissions = [
    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('0')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_ZERO)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x1234')),
    ],

    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('2')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_SIX)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x5678')),
    ],
  ];

  let event = createUpdatePreparedEvent(
    ADDRESS_THREE,
    daoEntityId,
    pluginEntityId,
    Bytes.fromHexString(setupId),
    pluginRepoEntityId,
    versionTuple,
    [],
    [ADDRESS_FOUR, ADDRESS_FIVE],
    permissions,
    Bytes.fromHexString('0x00'),
    Bytes.fromHexString('0x12')
  );
  handleUpdatePrepared(event);

  assert.entityCount('PluginPreparation', 1);
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'id',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'installation',
    pluginInstallationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'creator',
    ADDRESS_THREE
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'preparedSetupId',
    setupId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginRepo',
    pluginRepoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginVersion',
    pluginVersionEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'data',
    '0x12'
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'type',
    'Update'
  );

  let helpers = [
    Address.fromString(ADDRESS_FOUR),
    Address.fromString(ADDRESS_FIVE),
  ];
  let pluginPreparation = PluginPreparation.load(pluginPreparationEntityId);
  if (!pluginPreparation) {
    throw new Error(
      `PluginPrepation with id ${pluginPreparationEntityId} not found`
    );
  }

  assert.equals(
    ethereum.Value.fromBytesArray(pluginPreparation.helpers),
    ethereum.Value.fromAddressArray(helpers)
  );

  assert.entityCount('PluginPermission', 2);

  for (let i = 0; i < permissions.length; i++) {
    let permission = permissions[i];
    let operation = permission[0].toI32();
    const pluginPermissionEntityId = generatePluginPermissionEntityId(
      pluginPreparationEntityId,
      operation,
      permission[1].toAddress(),
      permission[2].toAddress(),
      permission[4].toBytes()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'id',
      pluginPermissionEntityId
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'operation',
      PERMISSION_OPERATIONS.get(operation) || ''
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'where',
      permission[1].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'who',
      permission[2].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'permissionId',
      permission[4].toBytes().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'condition',
      permission[3].toAddress().toHexString()
    );
  }

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'UpdatePrepared'
  );

  clearStore();
});

test('UpdateApplied event', function () {
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get installationId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  const pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );

  getSupportsInterface(pluginEntityId, '0xffffffff', false);

  let event = createUpdateAppliedEvent(
    daoEntityId,
    pluginEntityId,
    Bytes.fromHexString(setupId),
    Bytes.fromHexString(APPLIED_PLUGIN_SETUP_ID)
  );
  handleUpdateApplied(event);

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'id',
    pluginInstallationEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'plugin',
    pluginEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'appliedPreparation',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'appliedSetupId',
    APPLIED_PLUGIN_SETUP_ID
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'Installed'
  );

  clearStore();
});

test('UninstallationPrepared event', function () {
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get installationId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  const build = 1;
  const release = 2;
  const pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );
  const pluginVersionEntityId = generatePluginVersionEntityId(
    pluginRepoAddress,
    build,
    release
  );
  let versionTuple = new ethereum.Tuple();
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromI32(build)));
  versionTuple.push(ethereum.Value.fromSignedBigInt(BigInt.fromI32(release)));

  let permissions = [
    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('0')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_ZERO)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x1234')),
    ],

    [
      ethereum.Value.fromSignedBigInt(BigInt.fromString('2')),
      ethereum.Value.fromAddress(daoAddress),
      ethereum.Value.fromAddress(pluginAddress),
      ethereum.Value.fromAddress(Address.fromString(ADDRESS_SIX)),
      ethereum.Value.fromBytes(Bytes.fromHexString('0x5678')),
    ],
  ];

  let event = createUninstallationPreparedEvent(
    ADDRESS_THREE,
    daoEntityId,
    Bytes.fromHexString(setupId),
    pluginRepoEntityId,
    versionTuple,
    pluginEntityId,
    [ADDRESS_FOUR, ADDRESS_FIVE],
    Bytes.fromHexString('0x00'),
    permissions
  );
  handleUninstallationPrepared(event);

  assert.entityCount('PluginPreparation', 1);
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'id',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'installation',
    pluginInstallationEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'creator',
    ADDRESS_THREE
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'preparedSetupId',
    setupId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginRepo',
    pluginRepoEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'pluginVersion',
    pluginVersionEntityId
  );
  assert.fieldEquals(
    'PluginPreparation',
    pluginPreparationEntityId,
    'type',
    'Uninstallation'
  );

  let pluginPreparation = PluginPreparation.load(pluginPreparationEntityId);
  if (!pluginPreparation) {
    throw new Error(
      `PluginPrepation with id ${pluginPreparationEntityId} not found`
    );
  }
  assert.equals(
    ethereum.Value.fromBytesArray(pluginPreparation.helpers),
    ethereum.Value.fromAddressArray([])
  );

  assert.entityCount('PluginPermission', 2);

  for (let i = 0; i < permissions.length; i++) {
    const permission = permissions[i];
    const operation = permission[0].toI32();
    const pluginPermissionEntityId = generatePluginPermissionEntityId(
      pluginPreparationEntityId,
      operation,
      permission[1].toAddress(),
      permission[2].toAddress(),
      permission[4].toBytes()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'id',
      pluginPermissionEntityId
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'operation',
      PERMISSION_OPERATIONS.get(operation) || ''
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'where',
      permission[1].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'who',
      permission[2].toAddress().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'permissionId',
      permission[4].toBytes().toHexString()
    );
    assert.fieldEquals(
      'PluginPermission',
      pluginPermissionEntityId,
      'condition',
      permission[3].toAddress().toHexString()
    );
  }

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'UninstallPrepared'
  );

  clearStore();
});

test('UninstallationApplied event', function () {
  let pluginInstallationEntityId = generatePluginInstallationEntityId(
    daoAddress,
    pluginAddress
  );
  if (!pluginInstallationEntityId) {
    throw new Error('Failed to get pluginInstallationEntityId');
  }
  pluginInstallationEntityId = pluginInstallationEntityId as string;
  const pluginPreparationEntityId = generatePluginPreparationEntityId(
    pluginInstallationEntityId,
    Bytes.fromHexString(setupId)
  );

  let event = createUninstallationAppliedEvent(
    daoEntityId,
    pluginEntityId,
    setupId
  );
  handleUninstallationApplied(event);

  assert.entityCount('PluginInstallation', 1);
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'dao',
    daoEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'appliedPreparation',
    pluginPreparationEntityId
  );
  assert.fieldEquals(
    'PluginInstallation',
    pluginInstallationEntityId,
    'state',
    'Uninstalled'
  );
});


### File: /home/errick/core/packages/subgraph/tests/utils/utils.test.ts ###
import {bigIntToBytes32} from '../../src/utils/bytes';
import {
  ZERO,
  ONE,
  TWO,
  MAX_UINT256_NUMBER_STRING,
  ZERO_BYTES32,
  ONE_BYTES32,
  HALF_UINT256_BYTES32,
  MAX_UINT256_BYTES32,
} from '../constants';
import {BigInt} from '@graphprotocol/graph-ts';
import {assert, describe, test} from 'matchstick-as/assembly/index';

describe('Test bytes', function () {
  test('`bigIntToBytes32` with a range of `bigInt`s', function () {
    const MAX_UINT256 = BigInt.fromString(MAX_UINT256_NUMBER_STRING);

    assert.stringEquals(bigIntToBytes32(BigInt.fromString(ZERO)), ZERO_BYTES32);
    assert.stringEquals(bigIntToBytes32(BigInt.fromString(ONE)), ONE_BYTES32);
    assert.stringEquals(
      bigIntToBytes32(MAX_UINT256.div(BigInt.fromString(TWO))),
      HALF_UINT256_BYTES32
    );
    assert.stringEquals(bigIntToBytes32(MAX_UINT256), MAX_UINT256_BYTES32);
  });
});


### File: /home/errick/core/packages/subgraph/tests/helpers/method-classes.ts ###
/**
 * IMPORTANT: Do not export classes from this file.
 * The classes of this file are meant to be incorporated into the classes of ./extended-schema.ts
 */
import {
  Dao,
  ERC20Balance,
  ERC20Contract,
  ERC20Transfer,
  ERC721Balance,
  ERC721Contract,
  ERC721Transfer,
  ERC1155Contract,
  ERC1155Transfer,
  ERC1155Balance,
  ERC1155TokenIdBalance,
  NativeBalance,
  NativeTransfer,
  Permission,
} from '../../generated/schema';
import {
  CallbackReceived,
  Deposited,
  NativeTokenDeposited,
  NewURI,
} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {
  getBalanceId,
  getERC1155TransferId,
  getTokenIdBalanceId,
  getTransferId,
} from '../../src/utils/tokens/common';
import {
  ADDRESS_ONE,
  CONTRACT_ADDRESS,
  CREATED_AT,
  DAO_ADDRESS,
  DAO_TOKEN_ADDRESS,
  STRING_DATA,
  ADDRESS_TWO,
  ADDRESS_THREE,
  ADDRESS_ZERO,
  ADDRESS_FOUR,
  ACTION_BATCH_ID,
} from '../constants';
import {
  createCallbackReceivedEvent,
  createNewDepositedEvent,
  createNewNativeTokenDepositedEvent,
  createNewURIEvent,
  getBalanceOf,
  getSupportsInterface,
} from '../dao/utils';
import {
  createNewGrantedEvent,
  createNewRevokedEvent,
} from '../permission-manager/utils';
import {
  generatePermissionEntityId,
  createERC20TokenCalls,
  createERC1155TokenCalls,
  createTokenCalls,
} from '@aragon/osx-commons-subgraph';
import {
  Address,
  BigInt,
  ByteArray,
  Bytes,
  crypto,
} from '@graphprotocol/graph-ts';

/* eslint-disable  @typescript-eslint/no-unused-vars */
// PermissionManager
class PermissionMethods extends Permission {
  withDefaultValues(
    emittingContract: string = Address.fromString(
      CONTRACT_ADDRESS
    ).toHexString()
  ): PermissionMethods {
    const permissionId = Bytes.fromByteArray(
      crypto.keccak256(ByteArray.fromUTF8('EXECUTE_PERMISSION'))
    );

    const emittingContractAddress = Address.fromString(emittingContract);
    const whereAddress = Address.fromString(ADDRESS_ONE);
    const whoAddress = Address.fromString(ADDRESS_TWO);
    const actorAddress = Address.fromString(ADDRESS_THREE);
    const conditionAddress = Address.fromString(ADDRESS_FOUR);

    this.id = generatePermissionEntityId(
      emittingContractAddress,
      permissionId,
      whereAddress,
      whoAddress
    );
    this.where = whereAddress;
    this.permissionId = permissionId;
    this.who = whoAddress;
    this.actor = actorAddress;
    this.condition = conditionAddress;

    this.dao = null;
    this.pluginRepo = null;

    return this;
  }

  // events
  createEvent_Granted<T>(
    emittingContract: string = Address.fromString(
      CONTRACT_ADDRESS
    ).toHexString()
  ): T {
    if (this.condition === null) {
      throw new Error('Condition is null');
    }

    let event = createNewGrantedEvent<T>(
      this.permissionId,
      this.actor.toHexString(),
      this.where.toHexString(),
      this.who.toHexString(),
      (this.condition as Bytes).toHexString(),
      emittingContract
    );

    return event as T;
  }

  createEvent_Revoked<T>(
    emittingContract: string = Address.fromString(
      CONTRACT_ADDRESS
    ).toHexString()
  ): T {
    let event = createNewRevokedEvent<T>(
      this.permissionId,
      this.actor.toHexString(),
      this.where.toHexString(),
      this.who.toHexString(),
      emittingContract
    );

    return event as T;
  }
}

//  ERC1155Contract
class ERC1155ContractMethods extends ERC1155Contract {
  withDefaultValues(): ERC1155ContractMethods {
    this.id = Address.fromHexString(DAO_TOKEN_ADDRESS).toHexString();
    return this;
  }
  mockCall_createERC1155TokenCalls(): void {
    createERC1155TokenCalls(this.id, '0', 'https://example.org/0.json');
  }
}

class ERC1155BalanceMethods extends ERC1155Balance {
  withDefaultValues(): ERC1155BalanceMethods {
    let daoId = Address.fromString(DAO_ADDRESS).toHexString();
    let tokenId = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    let balanceId = getBalanceId(daoId, tokenId);

    this.id = balanceId;
    this.token = tokenId;
    this.dao = daoId;
    this.metadataUri = 'https://example.org/{id}.json';
    this.lastUpdated = BigInt.zero();
    return this;
  }
}
class ERC1155TokenIdBalanceMethods extends ERC1155TokenIdBalance {
  withDefaultValues(): ERC1155TokenIdBalanceMethods {
    let daoId = Address.fromString(DAO_ADDRESS).toHexString();
    let tokenId = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    let balanceId = getBalanceId(daoId, tokenId);

    this.id = getTokenIdBalanceId(daoId, tokenId, BigInt.zero());
    this.amount = BigInt.zero();
    this.balance = balanceId;
    this.tokenId = BigInt.zero();
    this.lastUpdated = BigInt.zero();
    return this;
  }
}

class ERC1155TransferMethods extends ERC1155Transfer {
  withDefaultValues(
    id: string = getERC1155TransferId(Bytes.empty(), BigInt.zero(), 0, 0)
  ): ERC1155TransferMethods {
    this.id = id;
    this.dao = DAO_ADDRESS;
    this.token = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    this.tokenId = BigInt.zero();
    this.from = Address.fromHexString(ADDRESS_ONE);
    this.to = Address.fromHexString(DAO_ADDRESS);
    this.actionBatch = 'null';
    this.type = 'Deposit';
    this.txHash = Bytes.empty();
    this.createdAt = BigInt.fromString(CREATED_AT);

    return this;
  }
}

// ERC721Contract
class ERC721ContractMethods extends ERC721Contract {
  withDefaultValues(): ERC721ContractMethods {
    this.id = Address.fromHexString(DAO_TOKEN_ADDRESS).toHexString();
    this.name = 'name';
    this.symbol = 'symbol';
    return this;
  }

  // calls
  mockCall_createTokenCalls(): void {
    if (!this.name) {
      throw new Error('Name is null');
    }
    if (!this.symbol) {
      throw new Error('Symbol is null');
    }
    // we cast to string only for stopping rust compiler complaints.
    createTokenCalls(
      DAO_TOKEN_ADDRESS,
      this.name as string,
      this.symbol as string
    );
  }
}

// ERC721Balance
class ERC721BalanceMethods extends ERC721Balance {
  withDefaultValues(): ERC721BalanceMethods {
    let daoId = Address.fromString(DAO_ADDRESS).toHexString();
    let tokenId = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    let balanceId = daoId.concat('_').concat(tokenId);

    this.id = balanceId;
    this.token = Address.fromHexString(DAO_TOKEN_ADDRESS).toHexString();
    this.dao = DAO_ADDRESS;
    this.tokenIds = [BigInt.zero()];
    this.lastUpdated = BigInt.zero();
    return this;
  }
}

// ERC721Transfer
class ERC721TransferMethods extends ERC721Transfer {
  withDefaultValues(
    id: string = getTransferId(Bytes.empty(), BigInt.zero(), 0)
  ): ERC721TransferMethods {
    this.id = id;
    this.dao = DAO_ADDRESS;
    this.token = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    this.tokenId = BigInt.zero();
    this.from = Address.fromHexString(ADDRESS_ONE);
    this.to = Address.fromHexString(DAO_ADDRESS);
    this.actionBatch = ACTION_BATCH_ID;
    this.type = 'Deposit';
    this.txHash = Bytes.empty();
    this.createdAt = BigInt.fromString(CREATED_AT);
    return this;
  }
}

// ERC20Contract

class ERC20ContractMethods extends ERC20Contract {
  withDefaultValues(): ERC20ContractMethods {
    this.id = Address.fromHexString(DAO_TOKEN_ADDRESS).toHexString();
    this.name = 'DAO Token';
    this.symbol = 'DAOT';
    this.decimals = 6;

    return this;
  }

  // calls
  mockCall_createTokenCalls(totalSupply: string | null = null): void {
    if (!this.name) {
      throw new Error('Name is null');
    }
    if (!this.symbol) {
      throw new Error('Symbol is null');
    }
    let supply = '10';
    if (totalSupply) {
      supply = totalSupply;
    }
    // we cast to string only for stoping rust compiler complaints.
    createERC20TokenCalls(
      this.id,
      supply,
      this.name as string,
      this.symbol as string,
      this.decimals.toString()
    );
  }

  mockCall_supportsInterface(interfaceId: string, value: boolean): void {
    getSupportsInterface(this.id, interfaceId, value);
  }

  mockCall_balanceOf(account: string, amount: string): void {
    getBalanceOf(this.id, account, amount);
  }
}

// ERC20Balance
class ERC20BalanceMethods extends ERC20Balance {
  withDefaultValues(): ERC20BalanceMethods {
    let daoId = Address.fromString(DAO_ADDRESS).toHexString();
    let tokenId = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    let balanceId = daoId.concat('_').concat(tokenId);

    this.id = balanceId;
    this.token = Address.fromHexString(DAO_TOKEN_ADDRESS).toHexString();
    this.dao = DAO_ADDRESS;
    this.balance = BigInt.zero();
    this.lastUpdated = BigInt.zero();
    return this;
  }
}

class ERC20TransferMethods extends ERC20Transfer {
  withDefaultValue(
    id: string = getTransferId(Bytes.empty(), BigInt.zero(), 0)
  ): ERC20TransferMethods {
    this.id = id;
    this.dao = DAO_ADDRESS;
    this.token = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    this.amount = BigInt.zero();
    this.from = Address.fromHexString(ADDRESS_ONE);
    this.to = Address.fromHexString(DAO_ADDRESS);
    this.actionBatch = ACTION_BATCH_ID;
    this.type = 'Deposit';
    this.txHash = Bytes.empty();
    this.createdAt = BigInt.fromString(CREATED_AT);

    return this;
  }
}

// NativeTransfer
class NativeTransferMethods extends NativeTransfer {
  withDefaultValues(
    id: string = getTransferId(Bytes.empty(), BigInt.zero(), 0)
  ): NativeTransferMethods {
    this.id = id;
    this.dao = DAO_ADDRESS;
    this.amount = BigInt.zero();
    this.from = Address.fromHexString(ADDRESS_ONE);
    this.to = Address.fromHexString(DAO_ADDRESS);
    this.reference = 'Native Deposit';
    this.actionBatch = ACTION_BATCH_ID;
    this.type = 'Deposit';
    this.txHash = Bytes.empty();
    this.createdAt = BigInt.fromString(CREATED_AT);

    return this;
  }
}

// NativeBalance
class NativeBalanceMethods extends NativeBalance {
  withDefaultValues(): NativeBalanceMethods {
    this.id = DAO_ADDRESS.concat('_').concat(ADDRESS_ZERO);
    this.dao = DAO_ADDRESS;
    this.balance = BigInt.zero();
    this.lastUpdated = BigInt.zero();

    return this;
  }
}

// DAO
class DaoMethods extends Dao {
  withDefaultValues(): DaoMethods {
    this.id = DAO_ADDRESS;
    this.subdomain = '';
    this.creator = Address.fromHexString(ADDRESS_ONE);
    this.metadata = STRING_DATA;
    this.daoURI = STRING_DATA;
    this.createdAt = BigInt.fromString(CREATED_AT);
    this.token = Address.fromString(DAO_TOKEN_ADDRESS).toHexString();
    this.trustedForwarder = Address.fromHexString(ADDRESS_TWO);
    this.signatureValidator = Address.fromHexString(ADDRESS_THREE);
    // random tx hash for testing purposes only
    this.txHash = Bytes.fromHexString('0x01');
    return this;
  }

  // events
  createEvent_NativeTokenDeposited(
    senderAddress: string,
    amount: string
  ): NativeTokenDeposited {
    let event = createNewNativeTokenDepositedEvent(
      senderAddress,
      amount,
      this.id
    );

    return event;
  }

  createEvent_Deposited(
    senderAddress: string,
    amount: string,
    reference: string
  ): Deposited {
    if (!this.token) {
      throw new Error('Token is null');
    }

    // we cast to string only for stoping rust compiler complaints.
    let event = createNewDepositedEvent(
      senderAddress,
      this.token as string,
      amount,
      reference,
      this.id
    );

    return event;
  }

  createEvent_CallbackReceived(
    onERC721Received: string,
    functionData: Bytes
  ): CallbackReceived {
    if (!this.token) {
      throw new Error('Token is null');
    }

    // we cast to string only for stoping rust compiler complaints.
    let event = createCallbackReceivedEvent(
      this.id,
      Bytes.fromHexString(onERC721Received),
      this.token as string,
      functionData
    );

    return event;
  }

  createEvent_NewURI(newURI: string): NewURI {
    let event = createNewURIEvent(newURI, this.id);

    return event;
  }
}


### File: /home/errick/core/packages/subgraph/tests/dao/dao_v1_0_0.test.ts ###
import {ERC721Balance} from '../../generated/schema';
import {Executed} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {
  handleNativeTokenDeposited,
  handleDeposited,
  handleExecuted,
  _handleMetadataSet,
  handleTrustedForwarderSet,
  handleStandardCallbackRegistered,
  handleCallbackReceived,
  handleNewURI,
} from '../../src/dao/dao_v1_0_0';
import {
  generateDeterministicActionId,
  generateActionEntityId,
  generateDeterministicActionBatchId,
  generateActionBatchEntityId,
} from '../../src/dao/ids';
import {
  generateERC1155TransferEntityId,
  generateTokenEntityId,
} from '../../src/utils/ids';
import {
  ERC1155_INTERFACE_ID,
  ERC165_INTERFACE_ID,
  ERC20_transfer,
  ERC20_transferFrom,
  ERC721_safeTransferFromWithData,
  ERC721_transferFrom,
  onERC1155BatchReceived,
  onERC1155Received,
  onERC721Received,
} from '../../src/utils/tokens/common';
import {
  DAO_ADDRESS,
  ADDRESS_ONE,
  DAO_TOKEN_ADDRESS,
  ONE_ETH,
  STRING_DATA,
  ADDRESS_ZERO,
  CONTRACT_ADDRESS,
  ZERO_BYTES32,
  ADDRESS_THREE,
  ADDRESS_FOUR,
  ERC20_AMOUNT_HALF,
  ERC20_AMOUNT_FULL,
  ERC20_TOTAL_SUPPLY,
  TOKEN_NAME,
  TOKEN_SYMBOL,
  ERC20_DECIMALS,
} from '../constants';
import {
  ExtendedDao,
  ExtendedERC1155Balance,
  ExtendedERC1155Contract,
  ExtendedERC1155TokenIdBalance,
  ExtendedERC1155Transfer,
  ExtendedERC20Balance,
  ExtendedERC20Contract,
  ExtendedERC20Transfer,
  ExtendedERC721Balance,
  ExtendedERC721Contract,
  ExtendedERC721Transfer,
  ExtendedNativeBalance,
  ExtendedNativeTransfer,
} from '../helpers/extended-schema';
import {
  getBalanceOf,
  createNewExecutedEvent,
  createDaoEntityState,
  createTrustedForwarderSetEvent,
  createStandardCallbackRegisteredEvent,
  getSupportsInterface,
  encodeWithFunctionSelector,
} from './utils';
import {
  generateBalanceEntityId,
  generateDaoEntityId,
  generateTokenIdBalanceEntityId,
  generateTransferEntityId,
  createDummyAction,
  createERC20TokenCalls,
  createERC1155TokenCalls,
} from '@aragon/osx-commons-subgraph';
import {Address, Bytes, BigInt, ethereum} from '@graphprotocol/graph-ts';
import {
  afterEach,
  assert,
  beforeAll,
  beforeEach,
  clearStore,
  describe,
  test,
} from 'matchstick-as/assembly/index';

const eq = assert.fieldEquals;

let daoAddress = Address.fromString(DAO_ADDRESS);
let tokenAddress = Address.fromString(DAO_TOKEN_ADDRESS);
let daoEntityId = generateDaoEntityId(daoAddress);
let tokenEntityId = generateTokenEntityId(tokenAddress);
let balanceEntityId = generateBalanceEntityId(daoAddress, tokenAddress);

let daoTokenContract: ExtendedERC20Contract;
let erc721Contract: ExtendedERC721Contract;

// create Executed event with multiple actions
function createExecutedEvent(
  tuple: ethereum.Value[][],
  selectors: string[],
  isDynamic: boolean,
  execResults: Bytes[],
  failureMap: string
): Executed {
  let actions: ethereum.Tuple[] = [];
  for (let i = 0; i < selectors.length; i++) {
    let functionData = encodeWithFunctionSelector(
      tuple[i],
      selectors[i],
      isDynamic
    );

    let action = createDummyAction(
      DAO_TOKEN_ADDRESS,
      '0',
      functionData.toHexString()
    );

    actions.push(action as ethereum.Tuple);
  }

  if (execResults.length == 0) {
    for (let i = 0; i < actions.length; i++) {
      execResults[i] = Bytes.fromHexString('0x11');
    }
  }

  let event = createNewExecutedEvent<Executed>(
    Address.fromHexString(CONTRACT_ADDRESS).toHexString(),
    ZERO_BYTES32,
    actions,
    BigInt.fromString(failureMap),
    execResults,
    Address.fromHexString(DAO_ADDRESS).toHexString(),
    null
  );

  return event;
}

test('Run dao (handleNewURI) mappings with mock event', () => {
  // Create state
  let dao = new ExtendedDao().withDefaultValues();
  dao.buildOrUpdate();

  let newDAOURI = 'new-uri';

  // create event
  const event = dao.createEvent_NewURI(newDAOURI);

  // handle event
  handleNewURI(event);

  // Checks
  // Expected changes
  dao.daoURI = newDAOURI;

  // Assert dao entity
  dao.assertEntity();

  clearStore();
});

test('Run dao (handleMetadataSet) mappings with mock event', () => {
  // Create state
  let dao = new ExtendedDao().withDefaultValues();
  dao.buildOrUpdate();

  let newMetadata = 'new-metadata';

  // Handle event
  _handleMetadataSet(dao.id, newMetadata);

  // Checks
  // Expected changes
  dao.metadata = newMetadata;

  // Assert dao entity
  dao.assertEntity();

  clearStore();
});

describe('handleNativeTokenDeposited', () => {
  test('create entities with correct values', () => {
    let dao = new ExtendedDao().withDefaultValues();

    // create event
    let newEvent = dao.createEvent_NativeTokenDeposited(ADDRESS_ONE, ONE_ETH);

    // handle event
    handleNativeTokenDeposited(newEvent);

    // check NativeBalance entity
    let nativeBalance = new ExtendedNativeBalance().withDefaultValues();

    // expected changes
    let balance = BigInt.fromString(ONE_ETH);
    nativeBalance.balance = balance;
    nativeBalance.lastUpdated = newEvent.block.timestamp;
    // assert
    nativeBalance.assertEntity();

    // check NativeTransfer entity
    let txHash = newEvent.transaction.hash;
    let logIndex = newEvent.transactionLogIndex;

    let transferEntityId = generateTransferEntityId(txHash, logIndex, 0);
    let nativeTransfer = new ExtendedNativeTransfer().withDefaultValues(
      transferEntityId
    );
    // expected changes
    nativeTransfer.amount = balance;
    nativeTransfer.txHash = txHash;

    nativeTransfer.assertEntity();

    clearStore();
  });
  test('correctly handles multiple events and updates balance', () => {
    let dao = new ExtendedDao().withDefaultValues();

    // create event
    let newEvent = dao.createEvent_NativeTokenDeposited(ADDRESS_ONE, ONE_ETH);

    newEvent.transactionLogIndex = BigInt.fromI32(2);
    handleNativeTokenDeposited(newEvent);

    newEvent.transactionLogIndex = BigInt.fromI32(3);
    handleNativeTokenDeposited(newEvent);

    assert.entityCount('NativeTransfer', 2);
    assert.entityCount('NativeBalance', 1);

    // check NativeBalance entity
    let nativeBalance = new ExtendedNativeBalance().withDefaultValues();

    // expected changes
    let eachAmount = BigInt.fromString(ONE_ETH);
    let finalAmount = eachAmount.plus(eachAmount);
    nativeBalance.balance = finalAmount;
    nativeBalance.lastUpdated = newEvent.block.timestamp;
    // assert
    nativeBalance.assertEntity();

    clearStore();
  });
});

describe('handleDeposited: ', () => {
  beforeAll(() => {
    daoTokenContract = new ExtendedERC20Contract().withDefaultValues();
    let totalSupply = '10';
    daoTokenContract.mockCall_createTokenCalls(totalSupply);
    daoTokenContract.mockCall_balanceOf(DAO_ADDRESS, ERC20_AMOUNT_HALF);
    daoTokenContract.mockCall_balanceOf(DAO_TOKEN_ADDRESS, ERC20_AMOUNT_HALF);

    getSupportsInterface(DAO_TOKEN_ADDRESS, ERC165_INTERFACE_ID, true);
    getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
  });

  afterEach(() => {
    clearStore();
  });

  test('ERC20: creates entities with correct values', () => {
    let dao = new ExtendedDao().withDefaultValues();

    let newEvent = dao.createEvent_Deposited(
      ADDRESS_ONE,
      ERC20_AMOUNT_HALF,
      STRING_DATA
    );

    let txHash = newEvent.transaction.hash;
    let logIndex = newEvent.transactionLogIndex;
    let timestamp = newEvent.block.timestamp;

    handleDeposited(newEvent);

    let transferEntityId = generateTransferEntityId(txHash, logIndex, 0);

    // check ERC20Contract entity
    daoTokenContract.assertEntity();
    assert.entityCount('ERC20Contract', 1);

    // check ERC20Balance entity
    let erc20Balance = new ExtendedERC20Balance().withDefaultValues();
    // expected changes
    let balance = BigInt.fromString(ERC20_AMOUNT_HALF);
    erc20Balance.balance = balance;
    erc20Balance.lastUpdated = timestamp;
    // assert
    erc20Balance.assertEntity();
    assert.entityCount('ERC20Contract', 1);

    // Check ERC20Transfer
    let erc20Transfer = new ExtendedERC20Transfer().withDefaultValue(
      transferEntityId
    );
    // expected changes
    erc20Transfer.amount = balance;
    erc20Transfer.txHash = txHash;
    // assert
    erc20Transfer.assertEntity();
    assert.entityCount('ERC20Transfer', 1);
  });

  test('ERC20: creates multiple events and updates balance', () => {
    let dao = new ExtendedDao().withDefaultValues();

    let newEvent = dao.createEvent_Deposited(
      ADDRESS_ONE,
      ERC20_AMOUNT_HALF,
      STRING_DATA
    );

    handleDeposited(newEvent);

    // check ERC20Balance entity
    let erc20Balance = new ExtendedERC20Balance().withDefaultValues();
    // expected changes
    let balance = BigInt.fromString(ERC20_AMOUNT_HALF);
    erc20Balance.balance = balance;
    erc20Balance.lastUpdated = newEvent.block.timestamp;
    // assert
    erc20Balance.assertEntity();

    daoTokenContract.mockCall_balanceOf(DAO_ADDRESS, ERC20_AMOUNT_FULL);

    newEvent.transactionLogIndex = BigInt.fromI32(2);
    handleDeposited(newEvent);

    // check ERC20Balance entity for updated balance
    // expected changes
    let balance2 = BigInt.fromString(ERC20_AMOUNT_FULL);
    erc20Balance.balance = balance2;
    // assert
    erc20Balance.assertEntity();
    assert.entityCount('ERC20Transfer', 2);
  });

  test('ETH: creates entities with correct values', () => {
    let token = ADDRESS_ZERO;

    let dao = new ExtendedDao().withDefaultValues();
    dao.token = token;

    let newEvent = dao.createEvent_Deposited(ADDRESS_ONE, ONE_ETH, STRING_DATA);

    let txHash = newEvent.transaction.hash;
    let logIndex = newEvent.transactionLogIndex;
    handleDeposited(newEvent);

    // check NativeBalance entity
    let nativeBalance = new ExtendedNativeBalance().withDefaultValues();

    // expected changes
    let balance = BigInt.fromString(ONE_ETH);
    nativeBalance.balance = balance;
    nativeBalance.lastUpdated = newEvent.block.timestamp;
    // assert
    nativeBalance.assertEntity();

    // Check NativeTransfer
    let transferEntityId = generateTransferEntityId(txHash, logIndex, 0);
    let nativeTransfer = new ExtendedNativeTransfer().withDefaultValues(
      transferEntityId
    );
    // expected changes
    nativeTransfer.amount = balance;
    nativeTransfer.txHash = txHash;
    nativeTransfer.reference = STRING_DATA;

    nativeTransfer.assertEntity();
  });

  test('ETH: correctly handles multiple events and updates balance', () => {
    // create event
    let token = ADDRESS_ZERO;

    let dao = new ExtendedDao().withDefaultValues();
    dao.token = token;

    let newEvent = dao.createEvent_Deposited(ADDRESS_ONE, ONE_ETH, STRING_DATA);

    handleDeposited(newEvent);

    newEvent.transactionLogIndex = BigInt.fromI32(2);
    handleDeposited(newEvent);

    let eachAmount = BigInt.fromString(ONE_ETH);
    let finalAmount = eachAmount.plus(eachAmount);

    // check NativeBalance entity
    let nativeBalance = new ExtendedNativeBalance().withDefaultValues();
    // expected changes
    nativeBalance.balance = finalAmount;
    nativeBalance.lastUpdated = newEvent.block.timestamp;
    // assert
    nativeBalance.assertEntity();

    assert.entityCount('NativeTransfer', 2);
    assert.entityCount('NativeBalance', 1);
  });
});

describe('handleCallbackReceived: ', () => {
  describe('ERC721 Received: ', () => {
    beforeAll(() => {
      erc721Contract = new ExtendedERC721Contract().withDefaultValues();
      erc721Contract.mockCall_createTokenCalls();

      getSupportsInterface(DAO_TOKEN_ADDRESS, '0x01ffc9a7', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, '80ac58cd', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });
    test('create entities with correct values', () => {
      let tokenId = BigInt.fromU32(1);
      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_FOUR)),
        ethereum.Value.fromUnsignedBigInt(tokenId),
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')),
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC721Received,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC721Received,
        functionData
      );
      handleCallbackReceived(newEvent);

      let txHash = newEvent.transaction.hash;
      let logIndex = newEvent.transactionLogIndex;
      let timestamp = newEvent.block.timestamp;

      let transferId = generateTransferEntityId(txHash, logIndex, 0);

      // // check ERC721Contract entity
      erc721Contract.assertEntity();
      assert.entityCount('ERC721Contract', 1);

      // check ERC721Balance entity
      let erc721Balance = new ExtendedERC721Balance().withDefaultValues();
      // expexted changes
      erc721Balance.tokenIds = [tokenId];
      erc721Balance.lastUpdated = timestamp;
      erc721Balance.assertEntity();
      assert.entityCount('ERC721Balance', 1);

      // Check ERC721Transfer
      let erc721Transfer = new ExtendedERC721Transfer().withDefaultValues(
        transferId
      );
      // expected changes
      erc721Transfer.from = Address.fromHexString(ADDRESS_FOUR);
      erc721Transfer.tokenId = tokenId;
      erc721Transfer.txHash = txHash;
      erc721Transfer.createdAt = timestamp;
      // assert
      erc721Transfer.assertEntity();

      clearStore();
    });

    test('correctly handles multiple events and updates balance', () => {
      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_FOUR)),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(1)),
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')),
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC721Received,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC721Received,
        functionData
      );

      handleCallbackReceived(newEvent);

      tupleArray[2] = ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(2));
      functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC721Received,
        true
      );
      newEvent = dao.createEvent_CallbackReceived(
        onERC721Received,
        functionData
      );

      // After 1st event
      assert.entityCount('ERC721Contract', 1);
      assert.entityCount('ERC721Transfer', 1);
      assert.entityCount('ERC721Balance', 1);
      // check ERC721Balance entity
      let erc721Balance = new ExtendedERC721Balance().withDefaultValues();
      // expexted changes
      erc721Balance.tokenIds = [BigInt.fromU32(1)];
      erc721Balance.lastUpdated = newEvent.block.timestamp;
      erc721Balance.assertEntity();

      // Change log index so it will enforce to generate new transferId
      // to make sure we can assert ERC721Transfer to be 2.
      newEvent.transactionLogIndex = BigInt.fromI32(2);

      handleCallbackReceived(newEvent);

      // After 1st event
      assert.entityCount('ERC721Contract', 1);
      assert.entityCount('ERC721Transfer', 2);
      assert.entityCount('ERC721Balance', 1);
      // check ERC721Balance entity
      // expexted changes
      erc721Balance.tokenIds = [BigInt.fromU32(1), BigInt.fromU32(2)];
      erc721Balance.assertEntity();
    });
  });
  describe('ERC1155 Received: ', () => {
    beforeAll(() => {
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '0',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '1',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '2',
        'https://example.org/{id}.json'
      );
      getSupportsInterface(DAO_TOKEN_ADDRESS, ERC1155_INTERFACE_ID, true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });
    beforeEach(() => {
      clearStore();
    });
    test('create entities with correct values', () => {
      let transferToken = BigInt.fromU32(0);
      let amount = BigInt.fromU32(10);

      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // operator
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // from
        ethereum.Value.fromUnsignedBigInt(transferToken), // tokenId
        ethereum.Value.fromUnsignedBigInt(amount), // amount
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC1155Received,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC1155Received,
        functionData
      );
      handleCallbackReceived(newEvent);
      // check ERC1155Contract entity
      assert.entityCount('ERC1155Contract', 1);
      let erc1155Contract = new ExtendedERC1155Contract().withDefaultValues();
      erc1155Contract.assertEntity();
      // check ERC1155Transfer entity
      let timestamp = newEvent.block.timestamp;
      let txHash = newEvent.transaction.hash;
      let logIndex = newEvent.transactionLogIndex;
      let transferId = generateERC1155TransferEntityId(txHash, logIndex, 0, 0);
      assert.entityCount('ERC1155Transfer', 1);
      let erc1155Transfer = new ExtendedERC1155Transfer().withDefaultValues();
      erc1155Transfer.id = transferId;
      erc1155Transfer.from = Address.fromString(ADDRESS_THREE);
      erc1155Transfer.to = Address.fromString(DAO_ADDRESS);
      erc1155Transfer.operator = Address.fromString(ADDRESS_THREE);
      erc1155Transfer.amount = amount;
      erc1155Transfer.txHash = txHash;
      erc1155Transfer.createdAt = timestamp;
      erc1155Transfer.assertEntity();
      // check ERC1155Balance entity
      assert.entityCount('ERC1155Balance', 1);
      let erc1155Balance = new ExtendedERC1155Balance().withDefaultValues();
      erc1155Balance.lastUpdated = timestamp;
      erc1155Balance.assertEntity();
      // check ERC1155TokenIdBalance entity
      assert.entityCount('ERC1155TokenIdBalance', 1);
      let erc1155TokenIdBalance =
        new ExtendedERC1155TokenIdBalance().withDefaultValues();
      erc1155TokenIdBalance.amount = amount;
      erc1155TokenIdBalance.lastUpdated = timestamp;
      erc1155TokenIdBalance.balance = balanceEntityId;
      erc1155TokenIdBalance.assertEntity();
    });
    test('correctly handles multiple events and updates balance', () => {
      let transferToken = BigInt.fromU32(0);
      let amount = BigInt.fromU32(10);

      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // operator
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // from
        ethereum.Value.fromUnsignedBigInt(transferToken), // tokenId
        ethereum.Value.fromUnsignedBigInt(amount), // amount
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC1155Received,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC1155Received,
        functionData
      );
      handleCallbackReceived(newEvent);

      assert.entityCount('ERC1155Contract', 1);
      assert.entityCount('ERC1155Transfer', 1);
      assert.entityCount('ERC1155Balance', 1);
      assert.entityCount('ERC1155TokenIdBalance', 1);

      newEvent.transactionLogIndex = BigInt.fromI32(2);

      handleCallbackReceived(newEvent);

      assert.entityCount('ERC1155Contract', 1);
      assert.entityCount('ERC1155Transfer', 2);
      assert.entityCount('ERC1155Balance', 1);
      assert.entityCount('ERC1155TokenIdBalance', 1);
      let erc1155TokenIdBalance =
        new ExtendedERC1155TokenIdBalance().withDefaultValues();
      erc1155TokenIdBalance.amount = amount.times(BigInt.fromU32(2));
      erc1155TokenIdBalance.lastUpdated = newEvent.block.timestamp;
      erc1155TokenIdBalance.assertEntity();
    });
  });
  describe('ERC1155 Batch Received: ', () => {
    beforeAll(() => {
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '0',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '1',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '2',
        'https://example.org/{id}.json'
      );
      getSupportsInterface(DAO_TOKEN_ADDRESS, ERC1155_INTERFACE_ID, true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });
    beforeEach(() => {
      clearStore();
    });
    test('create entities with correct values', () => {
      let transferToken = [BigInt.fromU32(0), BigInt.fromU32(1)];
      let amount = [BigInt.fromU32(10), BigInt.fromU32(20)];

      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // operator
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // from
        ethereum.Value.fromUnsignedBigIntArray(transferToken), // tokenId
        ethereum.Value.fromUnsignedBigIntArray(amount), // amount
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC1155BatchReceived,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC1155BatchReceived,
        functionData
      );
      handleCallbackReceived(newEvent);

      let erc1155TokenIdBalances: string[] = [];
      for (let i = 0; i < transferToken.length; i++) {
        erc1155TokenIdBalances.push(
          generateTokenIdBalanceEntityId(
            daoAddress,
            tokenAddress,
            transferToken[i]
          )
        );
      }
      // check ERC1155Contract entity
      assert.entityCount('ERC1155Contract', 1);
      let erc1155Contract = new ExtendedERC1155Contract().withDefaultValues();
      erc1155Contract.assertEntity();
      // check ERC1155Transfer entity
      assert.entityCount('ERC1155Transfer', 2);
      let timestamp = newEvent.block.timestamp;
      let txHash = newEvent.transaction.hash;
      let logIndex = newEvent.transactionLogIndex;
      for (let i = 0; i < transferToken.length; i++) {
        let erc1155Transfer = new ExtendedERC1155Transfer().withDefaultValues();
        erc1155Transfer.id = generateERC1155TransferEntityId(
          txHash,
          logIndex,
          0,
          i
        );
        erc1155Transfer.from = Address.fromString(ADDRESS_THREE);
        erc1155Transfer.to = Address.fromString(DAO_ADDRESS);
        erc1155Transfer.operator = Address.fromString(ADDRESS_THREE);
        erc1155Transfer.amount = amount[i];
        erc1155Transfer.txHash = txHash;
        erc1155Transfer.createdAt = timestamp;
        erc1155Transfer.tokenId = transferToken[i];
        erc1155Transfer.assertEntity();
      }

      // check ERC1155Balance entity
      assert.entityCount('ERC1155Balance', 1);
      let erc1155Balance = new ExtendedERC1155Balance().withDefaultValues();
      erc1155Balance.lastUpdated = timestamp;
      // check ERC1155TokenIdBalance entity
      assert.entityCount('ERC1155TokenIdBalance', 2);
      for (let i = 0; i < transferToken.length; i++) {
        let erc1155TokenIdBalance =
          new ExtendedERC1155TokenIdBalance().withDefaultValues();
        erc1155TokenIdBalance.balance = balanceEntityId;
        erc1155TokenIdBalance.id = erc1155TokenIdBalances[i];
        erc1155TokenIdBalance.amount = amount[i];
        erc1155TokenIdBalance.tokenId = transferToken[i];
        erc1155TokenIdBalance.lastUpdated = timestamp;
        erc1155TokenIdBalance.assertEntity();
      }
    });
    test('correctly handles multiple events and updates balance', () => {
      let transferToken = [BigInt.fromU32(0), BigInt.fromU32(1)];
      let amount = [BigInt.fromU32(10), BigInt.fromU32(20)];

      let tupleArray: Array<ethereum.Value> = [
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // operator
        ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // from
        ethereum.Value.fromUnsignedBigIntArray(transferToken), // tokenId
        ethereum.Value.fromUnsignedBigIntArray(amount), // amount
        ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
      ];

      let functionData = encodeWithFunctionSelector(
        tupleArray,
        onERC1155BatchReceived,
        true
      );

      let dao = new ExtendedDao().withDefaultValues();

      let newEvent = dao.createEvent_CallbackReceived(
        onERC1155BatchReceived,
        functionData
      );
      handleCallbackReceived(newEvent);
      assert.entityCount('ERC1155Contract', 1);
      assert.entityCount('ERC1155Transfer', 2);
      assert.entityCount('ERC1155Balance', 1);
      assert.entityCount('ERC1155TokenIdBalance', 2);

      newEvent.transactionLogIndex = BigInt.fromI32(2);
      handleCallbackReceived(newEvent);
      assert.entityCount('ERC1155Contract', 1);
      assert.entityCount('ERC1155Transfer', 4);
      assert.entityCount('ERC1155Balance', 1);
      assert.entityCount('ERC1155TokenIdBalance', 2);
      for (let i = 0; i < transferToken.length; i++) {
        let erc1155TokenIdBalance =
          new ExtendedERC1155TokenIdBalance().withDefaultValues();
        erc1155TokenIdBalance.id = generateTokenIdBalanceEntityId(
          daoAddress,
          tokenAddress,
          transferToken[i]
        );
        erc1155TokenIdBalance.tokenId = transferToken[i];
        erc1155TokenIdBalance.balance = balanceEntityId;
        erc1155TokenIdBalance.amount = amount[i].times(BigInt.fromU32(2));
        erc1155TokenIdBalance.lastUpdated = newEvent.block.timestamp;
        erc1155TokenIdBalance.assertEntity();
      }
    });
  });
});

describe('handleExecuted', () => {
  afterEach(() => {
    clearStore();
  });

  test('successfuly creates action and actionBatch', () => {
    let tuple: Array<ethereum.Value> = [ethereum.Value.fromString('')];
    let selector = '0x11111111';

    let execResults = [
      Bytes.fromHexString('0x11'),
      Bytes.fromHexString('0x22'),
    ];

    let failureMap = '2';

    let event = createExecutedEvent(
      [tuple, tuple],
      [selector, selector],
      false,
      execResults,
      failureMap
    );

    handleExecuted(event);

    let deterministicId = generateDeterministicActionBatchId(
      event.params.actor,
      event.address,
      event.params.callId
    );

    let actionBatchEntityId = generateActionBatchEntityId(
      event.params.actor,
      event.address,
      event.params.callId,
      event.transaction.hash,
      event.transactionLogIndex
    );

    assert.entityCount('ActionBatch', 1);
    assert.entityCount('Action', 2);

    eq('ActionBatch', actionBatchEntityId, 'id', actionBatchEntityId);
    eq('ActionBatch', actionBatchEntityId, 'failureMap', failureMap);
    eq('ActionBatch', actionBatchEntityId, 'dao', DAO_ADDRESS);
    eq('ActionBatch', actionBatchEntityId, 'deterministicId', deterministicId);

    for (let i = 0; i < event.params.actions.length; i++) {
      const deterministicActionId = generateDeterministicActionId(
        event.params.actor,
        event.address,
        event.params.callId,
        i
      );
      let actionEntityId = generateActionEntityId(
        event.params.actor,
        event.address,
        event.params.callId,
        i,
        event.transaction.hash,
        event.transactionLogIndex
      );

      eq('Action', actionEntityId, 'id', actionEntityId);
      eq('Action', actionEntityId, 'execResult', execResults[i].toHexString());
      eq('Action', actionEntityId, 'dao', DAO_ADDRESS);
      eq('Action', actionEntityId, 'deterministicId', deterministicActionId);
      eq('Action', actionEntityId, 'actionBatch', actionBatchEntityId);
      eq(
        'Action',
        actionEntityId,
        'data',
        encodeWithFunctionSelector(tuple, selector).toHexString()
      );
    }
  });

  test('Duplicate deterministic ids will point to different proposals and actions', () => {
    let tuple: Array<ethereum.Value> = [ethereum.Value.fromString('')];
    let selector = '0x11111111';
    let execResult = Bytes.fromHexString('0x11');
    let failureMap = '2';

    let event0 = createExecutedEvent(
      [tuple],
      [selector],
      false,
      [execResult],
      failureMap
    );

    let event1 = createExecutedEvent(
      [tuple],
      [selector],
      false,
      [execResult],
      failureMap
    );

    // increment the log index to make sure the transaction actions are different
    // for the two events even if they are in the same block
    event1.logIndex = event1.logIndex.plus(BigInt.fromI32(1));
    event1.transactionLogIndex = event1.logIndex;

    assert.entityCount('Action', 0);
    assert.entityCount('ActionBatch', 0);

    handleExecuted(event0);
    handleExecuted(event1);

    // The action and proposal count should be the same.
    assert.entityCount('Action', 2);
    assert.entityCount('ActionBatch', 2);
  });

  describe('ERC20 action', () => {
    beforeAll(() => {
      createERC20TokenCalls(
        DAO_TOKEN_ADDRESS,
        ERC20_TOTAL_SUPPLY,
        TOKEN_NAME,
        TOKEN_SYMBOL,
        ERC20_DECIMALS
      );
      getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      getBalanceOf(DAO_TOKEN_ADDRESS, DAO_TOKEN_ADDRESS, ERC20_AMOUNT_HALF);

      // Even though for ERC20, there's no need to be mocking supportsInterface of ERC721,
      // The below is still required. This is caused by the fact that ERC20's transferFrom
      // And ERC721 transferFrom exactly have the same signature and mapping can't detect,
      // So the test should be agnostic even if ERC721 check gets called first from mapping.
      // Otherwise, without the below mock and if ERC721 check is called from mapping, the test
      // Would fail. https://github.com/LimeChain/matchstick/issues/278#issuecomment-1426884510
      getSupportsInterface(DAO_TOKEN_ADDRESS, '0x01ffc9a7', false);
      getSupportsInterface(DAO_TOKEN_ADDRESS, '80ac58cd', false);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });

    describe('ERC20 transfer action', () => {
      test('creates entities with correct values', () => {
        let transferToken = BigInt.fromU32(10);
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToken),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transfer],
          false,
          [],
          '0'
        );

        handleExecuted(event);
        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferEntityId = generateTransferEntityId(txHash, logIndex, 0);

        // check ERC20Contract entity
        eq('ERC20Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC20Contract', tokenEntityId, 'name', 'name');
        eq('ERC20Contract', tokenEntityId, 'symbol', 'symbol');
        assert.entityCount('ERC20Contract', 1);

        // check ERC20Balance entity
        eq('ERC20Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC20Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC20Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);
        eq(
          'ERC20Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC20Balance', 1);

        // Check ERC20Transfer
        eq('ERC20Transfer', transferEntityId, 'id', transferEntityId);
        eq('ERC20Transfer', transferEntityId, 'dao', daoEntityId);
        eq(
          'ERC20Transfer',
          transferEntityId,
          'amount',
          transferToken.toString()
        );
        eq('ERC20Transfer', transferEntityId, 'from', DAO_ADDRESS);
        eq('ERC20Transfer', transferEntityId, 'to', ADDRESS_THREE);
        eq(
          'ERC20Transfer',
          transferEntityId,
          'actionBatch',
          actionBatchEntityId
        );
        eq('ERC20Transfer', transferEntityId, 'type', 'Withdraw');
        eq('ERC20Transfer', transferEntityId, 'txHash', txHash.toHexString());
        eq(
          'ERC20Transfer',
          transferEntityId,
          'createdAt',
          timestamp.toString()
        );
        assert.entityCount('ERC20Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(10)),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transfer],
          false,
          [],
          '0'
        );

        handleExecuted(event);

        // After 1st event
        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Transfer', 1);
        assert.entityCount('ERC20Balance', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);

        // Mock balance of with different amount
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_FULL);

        // Change log index so it will enforce to generate new transferId
        // to make sure we can aserst ERC20Transfer to be 2.
        event.transactionLogIndex = BigInt.fromI32(2);
        handleExecuted(event);

        // After 2nd event
        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Transfer', 2);
        assert.entityCount('ERC20Balance', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_FULL);

        // Mock balance to get it back to the same before running this test
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      });
    });

    describe('ERC20(transferFrom) action', () => {
      test('creates entities with correct values', () => {
        let transferToken = BigInt.fromU32(10);
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToken),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transferFrom],
          false,
          [],
          '0'
        );

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        // check ERC20Contract entity
        eq('ERC20Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC20Contract', tokenEntityId, 'name', 'name');
        eq('ERC20Contract', tokenEntityId, 'symbol', 'symbol');
        assert.entityCount('ERC20Contract', 1);

        // check ERC20Balance entity
        eq('ERC20Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC20Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC20Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);
        eq(
          'ERC20Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC20Balance', 1);

        // Check ERC20Transfer
        eq('ERC20Transfer', transferId, 'id', transferId);
        eq('ERC20Transfer', transferId, 'dao', daoEntityId);
        eq('ERC20Transfer', transferId, 'amount', transferToken.toString());
        eq('ERC20Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC20Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC20Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC20Transfer', transferId, 'type', 'Withdraw');
        eq('ERC20Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC20Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC20Transfer', 1);
      });

      test('correctly handles multiple events and update balance', () => {
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(10)),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transferFrom],
          false,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Balance', 1);
        assert.entityCount('ERC20Transfer', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);

        // Mock balance of with different amount
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_FULL);

        // Change log index so it will enforce to generate new transferId
        // to make sure we can aserst ERC20Transfer to be 2.
        event.transactionLogIndex = BigInt.fromI32(2);
        handleExecuted(event);

        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Balance', 1);
        assert.entityCount('ERC20Transfer', 2);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_FULL);

        // Mock balance to get it back to the same before running this test
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      });
    });
  });

  describe('ERC721 action', () => {
    beforeAll(() => {
      createERC20TokenCalls(
        DAO_TOKEN_ADDRESS,
        ERC20_TOTAL_SUPPLY,
        TOKEN_NAME,
        TOKEN_SYMBOL
      );

      getSupportsInterface(DAO_TOKEN_ADDRESS, '0x01ffc9a7', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, '80ac58cd', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });

    beforeEach(() => {
      let entity = new ERC721Balance(balanceEntityId);
      entity.dao = daoEntityId;
      entity.tokenIds = [
        BigInt.fromI32(4),
        BigInt.fromI32(8),
        BigInt.fromI32(12),
      ];
      entity.lastUpdated = BigInt.fromI32(2);
      entity.token = tokenEntityId;
      entity.save();
    });

    describe('ERC721 transferFrom', () => {
      test('create entities with correct values', () => {
        let transferToKen = BigInt.fromU32(8);

        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToKen),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC721_transferFrom],
          false,
          [],
          '0'
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        // check ERC721Contract entity
        eq('ERC721Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC721Contract', tokenEntityId, 'name', 'name');
        eq('ERC721Contract', tokenEntityId, 'symbol', 'symbol');
        assert.entityCount('ERC721Contract', 1);

        // check ERC721Balance entity
        eq('ERC721Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC721Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC721Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4, 12]');
        eq(
          'ERC721Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC721Balance', 1);

        // Check ERC721Transfer
        eq('ERC721Transfer', transferId, 'id', transferId);
        eq('ERC721Transfer', transferId, 'dao', daoEntityId);
        eq('ERC721Transfer', transferId, 'tokenId', transferToKen.toString());
        eq('ERC721Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC721Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC721Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC721Transfer', transferId, 'type', 'Withdraw');
        eq('ERC721Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC721Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC721Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let from = ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS));
        let to = ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE));
        let transferToken1 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(8)
        );
        let transferToken2 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(12)
        );

        let tuple1: Array<ethereum.Value> = [from, to, transferToken1];
        let tuple2: Array<ethereum.Value> = [from, to, transferToken2];

        let event = createExecutedEvent(
          [tuple1, tuple2],
          [ERC721_transferFrom, ERC721_transferFrom],
          false,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC721Contract', 1);
        assert.entityCount('ERC721Balance', 1);
        assert.entityCount('ERC721Transfer', 2);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4]');
      });
    });

    describe('ERC721 safeTransferFrom with data', () => {
      test('create entities with correct values', () => {
        let transferToKen = BigInt.fromU32(8);

        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToKen),
          ethereum.Value.fromBytes(Bytes.fromHexString('0x')),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC721_safeTransferFromWithData],
          true,
          [],
          '0'
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );

        // check ERC721Contract entity
        eq('ERC721Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC721Contract', tokenEntityId, 'name', 'name');
        eq('ERC721Contract', tokenEntityId, 'symbol', 'symbol');
        assert.entityCount('ERC721Contract', 1);

        // check ERC721Balance entity
        eq('ERC721Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC721Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC721Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4, 12]');
        eq(
          'ERC721Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC721Balance', 1);

        // Check ERC721Transfer
        eq('ERC721Transfer', transferId, 'id', transferId);
        eq('ERC721Transfer', transferId, 'dao', daoEntityId);
        eq('ERC721Transfer', transferId, 'tokenId', transferToKen.toString());
        eq('ERC721Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC721Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC721Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC721Transfer', transferId, 'type', 'Withdraw');
        eq('ERC721Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC721Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC721Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let from = ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS));
        let to = ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE));
        let data = ethereum.Value.fromBytes(Bytes.fromHexString('0x'));

        let transferToken1 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(8)
        );
        let transferToken2 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(12)
        );

        let tuple1: Array<ethereum.Value> = [from, to, transferToken1, data];
        let tuple2: Array<ethereum.Value> = [from, to, transferToken2, data];

        let event = createExecutedEvent(
          [tuple1, tuple2],
          [ERC721_safeTransferFromWithData, ERC721_safeTransferFromWithData],
          true,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC721Contract', 1);
        assert.entityCount('ERC721Balance', 1);
        assert.entityCount('ERC721Transfer', 2);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4]');
      });
    });
  });
});

test('Run dao (handleTrustedForwarderSet) mappings with mock event', () => {
  // create state
  let entityID = Address.fromString(DAO_ADDRESS).toHexString();
  createDaoEntityState(entityID, ADDRESS_ONE, DAO_TOKEN_ADDRESS);

  let trustedForwarder = ADDRESS_ONE;

  let newEvent = createTrustedForwarderSetEvent(trustedForwarder, DAO_ADDRESS);
  // handle event
  handleTrustedForwarderSet(newEvent);

  // checks
  assert.fieldEquals('Dao', entityID, 'id', entityID);
  assert.fieldEquals(
    'Dao',
    entityID,
    'trustedForwarder',
    Address.fromString(ADDRESS_ONE).toHexString()
  );

  clearStore();
});

test('Run dao (handleStandardCallbackRegistered) mappings with mock event', () => {
  // create state
  let daoAddress = Address.fromString(DAO_ADDRESS).toHexString();
  createDaoEntityState(daoAddress, ADDRESS_ONE, DAO_TOKEN_ADDRESS);

  let newEvent = createStandardCallbackRegisteredEvent(
    '0xaaaaaaaa',
    '0xaaaaaaab',
    '0xaaaaaaac',
    DAO_ADDRESS
  );
  // handle event
  handleStandardCallbackRegistered(newEvent);

  newEvent = createStandardCallbackRegisteredEvent(
    '0xbbaaaaaa',
    '0xbbaaaaab',
    '0xbbaaaaac',
    DAO_ADDRESS
  );

  // handle event
  handleStandardCallbackRegistered(newEvent);

  // checks
  let entityID = `${daoAddress}_0xaaaaaaaa`;
  assert.fieldEquals('StandardCallback', entityID, 'id', entityID);
  assert.fieldEquals('StandardCallback', entityID, 'interfaceId', '0xaaaaaaaa');
  assert.fieldEquals(
    'StandardCallback',
    entityID,
    'callbackSelector',
    '0xaaaaaaab'
  );
  assert.fieldEquals('StandardCallback', entityID, 'magicNumber', '0xaaaaaaac');

  entityID = `${daoAddress}_0xbbaaaaaa`;
  assert.fieldEquals('StandardCallback', entityID, 'id', entityID);
  assert.fieldEquals('StandardCallback', entityID, 'interfaceId', '0xbbaaaaaa');
  assert.fieldEquals(
    'StandardCallback',
    entityID,
    'callbackSelector',
    '0xbbaaaaab'
  );
  assert.fieldEquals('StandardCallback', entityID, 'magicNumber', '0xbbaaaaac');

  clearStore();
});


### File: /home/errick/core/packages/subgraph/tests/dao/utils.ts ###
import {Dao} from '../../generated/schema';
import {
  MetadataSet,
  NativeTokenDeposited,
  Deposited,
  Executed,
  TrustedForwarderSet,
  StandardCallbackRegistered,
  CallbackReceived,
  NewURI,
} from '../../generated/templates/DaoTemplateV1_0_0/DAO';
import {ethereum, Bytes, Address, BigInt, log} from '@graphprotocol/graph-ts';
import {createMockedFunction, newMockEvent} from 'matchstick-as/assembly/index';

// events

export function createNewURIEvent(
  newURI: string,
  contractAddress: string
): NewURI {
  let newNewURIEvent = changetype<NewURI>(newMockEvent());

  newNewURIEvent.address = Address.fromString(contractAddress);

  newNewURIEvent.parameters = [];

  let daoURIParam = new ethereum.EventParam(
    'daoURI',
    ethereum.Value.fromString(newURI)
  );

  newNewURIEvent.parameters.push(daoURIParam);

  return newNewURIEvent;
}

export function createNewMetadataSetEvent(
  metadata: string,
  contractAddress: string
): MetadataSet {
  let newMetadataSetEvent = changetype<MetadataSet>(newMockEvent());

  newMetadataSetEvent.address = Address.fromString(contractAddress);
  newMetadataSetEvent.parameters = [];

  let metadataParam = new ethereum.EventParam(
    'metadata',
    ethereum.Value.fromBytes(Bytes.fromUTF8(metadata))
  );

  newMetadataSetEvent.parameters.push(metadataParam);

  return newMetadataSetEvent;
}

export function createCallbackReceivedEvent(
  dao: string,
  functionSig: Bytes,
  sender: string,
  data: Bytes
): CallbackReceived {
  let callBackEvent = changetype<CallbackReceived>(newMockEvent());

  callBackEvent.address = Address.fromString(dao);
  callBackEvent.parameters = [];

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let sigParam = new ethereum.EventParam(
    'sig',
    ethereum.Value.fromBytes(functionSig)
  );
  let dataParam = new ethereum.EventParam(
    'data',
    ethereum.Value.fromBytes(data)
  );

  callBackEvent.parameters.push(senderParam);
  callBackEvent.parameters.push(sigParam);
  callBackEvent.parameters.push(dataParam);

  return callBackEvent;
}

export function createTrustedForwarderSetEvent(
  trustedForwarder: string,
  contractAddress: string
): TrustedForwarderSet {
  let newTrustedForwarderSetEvent = changetype<TrustedForwarderSet>(
    newMockEvent()
  );

  newTrustedForwarderSetEvent.address = Address.fromString(contractAddress);
  newTrustedForwarderSetEvent.parameters = [];

  let trustedForwarderParam = new ethereum.EventParam(
    'trustedForwarder',
    ethereum.Value.fromAddress(Address.fromString(trustedForwarder))
  );

  newTrustedForwarderSetEvent.parameters.push(trustedForwarderParam);

  return newTrustedForwarderSetEvent;
}

export function createNewNativeTokenDepositedEvent(
  sender: string,
  amount: string,
  contractAddress: string
): NativeTokenDeposited {
  let newEvent = changetype<NativeTokenDeposited>(newMockEvent());

  newEvent.address = Address.fromString(contractAddress);
  newEvent.parameters = [];

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let amountParam = new ethereum.EventParam(
    'amount',
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(amount))
  );

  newEvent.parameters.push(senderParam);
  newEvent.parameters.push(amountParam);

  return newEvent;
}

export function createNewDepositedEvent(
  sender: string,
  token: string,
  amount: string,
  reference: string,
  contractAddress: string
): Deposited {
  let newEvent = changetype<Deposited>(newMockEvent());

  newEvent.address = Address.fromString(contractAddress);
  newEvent.parameters = [];

  let senderParam = new ethereum.EventParam(
    'sender',
    ethereum.Value.fromAddress(Address.fromString(sender))
  );
  let tokenParam = new ethereum.EventParam(
    'token',
    ethereum.Value.fromAddress(Address.fromString(token))
  );
  let amountParam = new ethereum.EventParam(
    'amount',
    ethereum.Value.fromUnsignedBigInt(BigInt.fromString(amount))
  );
  let referenceParam = new ethereum.EventParam(
    '_reference',
    ethereum.Value.fromString(reference)
  );

  newEvent.parameters.push(senderParam);
  newEvent.parameters.push(tokenParam);
  newEvent.parameters.push(amountParam);
  newEvent.parameters.push(referenceParam);

  return newEvent;
}

export function createNewExecutedEvent<T extends Executed>(
  actor: string,
  callId: string,
  actions: ethereum.Tuple[],
  failureMap: BigInt,
  execResults: Bytes[],
  contractAddress: string,
  allowFailureMap: BigInt | null // used from DAO V1.2 and higher
): T {
  let newExecutedEvent = changetype<T>(newMockEvent());

  newExecutedEvent.address = Address.fromString(contractAddress);
  newExecutedEvent.parameters = [];

  let actorParam = new ethereum.EventParam(
    'actor',
    ethereum.Value.fromAddress(Address.fromString(actor))
  );
  let callIdParam = new ethereum.EventParam(
    'callId',
    ethereum.Value.fromBytes(Bytes.fromHexString(callId))
  );
  let actionsParam = new ethereum.EventParam(
    'actions',
    ethereum.Value.fromTupleArray(actions)
  );

  let allowFailureMapParam: ethereum.EventParam | null = null;
  if (allowFailureMap) {
    allowFailureMapParam = new ethereum.EventParam(
      'allowFailureMap',
      ethereum.Value.fromUnsignedBigInt(allowFailureMap)
    );
  }

  let failureMapParam = new ethereum.EventParam(
    'failureMap',
    ethereum.Value.fromUnsignedBigInt(failureMap)
  );

  let execResultsParams = new ethereum.EventParam(
    'execResults',
    ethereum.Value.fromBytesArray(execResults)
  );

  newExecutedEvent.parameters.push(actorParam);
  newExecutedEvent.parameters.push(callIdParam);
  newExecutedEvent.parameters.push(actionsParam);

  if (allowFailureMapParam) {
    newExecutedEvent.parameters.push(allowFailureMapParam);
  }

  newExecutedEvent.parameters.push(failureMapParam);
  newExecutedEvent.parameters.push(execResultsParams);

  return newExecutedEvent;
}

export function createStandardCallbackRegisteredEvent(
  interfaceId: string,
  callbackSelector: string,
  magicNumber: string,
  contractAddress: string
): StandardCallbackRegistered {
  let newStandardCallbackEvent = changetype<StandardCallbackRegistered>(
    newMockEvent()
  );

  newStandardCallbackEvent.address = Address.fromString(contractAddress);
  newStandardCallbackEvent.parameters = [];

  let interfaceIdParam = new ethereum.EventParam(
    'interfaceId',
    ethereum.Value.fromFixedBytes(Bytes.fromHexString(interfaceId) as Bytes)
  );

  let callbackSelectorParam = new ethereum.EventParam(
    'callbackSelector',
    ethereum.Value.fromFixedBytes(
      Bytes.fromHexString(callbackSelector) as Bytes
    )
  );

  let magicNumberParam = new ethereum.EventParam(
    'magicNumber',
    ethereum.Value.fromFixedBytes(Bytes.fromHexString(magicNumber) as Bytes)
  );

  newStandardCallbackEvent.parameters.push(interfaceIdParam);
  newStandardCallbackEvent.parameters.push(callbackSelectorParam);
  newStandardCallbackEvent.parameters.push(magicNumberParam);

  return newStandardCallbackEvent;
}

// calls

export function getBalanceOf(
  contractAddress: string,
  account: string,
  returns: string
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'balanceOf',
    'balanceOf(address):(uint256)'
  )
    .withArgs([ethereum.Value.fromAddress(Address.fromString(account))])
    .returns([ethereum.Value.fromSignedBigInt(BigInt.fromString(returns))]);
}

export function getEXECUTE_PERMISSION_ID(
  contractAddress: string,
  returns: Bytes
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'EXECUTE_PERMISSION_ID',
    'EXECUTE_PERMISSION_ID():(bytes32)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromBytes(returns)]);
}

export function getEXECUTE_PERMISSION_IDreverted(
  contractAddress: string
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'EXECUTE_PERMISSION_ID',
    'EXECUTE_PERMISSION_ID():(bytes32)'
  )
    .withArgs([])
    .reverts();
}

export function getSupportThreshold(
  contractAddress: string,
  returns: BigInt
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'supportThreshold',
    'supportThreshold():(uint32)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromSignedBigInt(returns)]);
}

export function getMinimalParticipation(
  contractAddress: string,
  returns: BigInt
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'minParticipation',
    'minParticipation():(uint32)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromSignedBigInt(returns)]);
}

export function getMinDuration(contractAddress: string, returns: BigInt): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'minDuration',
    'minDuration():(uint64)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromSignedBigInt(returns)]);
}

export function getProposalCount(
  contractAddress: string,
  returns: BigInt
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'proposalCount',
    'proposalCount():(uint256)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromSignedBigInt(returns)]);
}

export function getVotingToken(contractAddress: string, returns: string): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'getVotingToken',
    'getVotingToken():(address)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromAddress(Address.fromString(returns))]);
}

export function getIsUserAllowed(
  contractAddress: string,
  address: string,
  returns: boolean
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'isListed',
    'isListedAtBlock(address,uint256):(bool)'
  )
    .withArgs([
      ethereum.Value.fromAddress(Address.fromString(address)),
      ethereum.Value.fromUnsignedBigInt(BigInt.zero()),
    ])
    .returns([ethereum.Value.fromBoolean(returns)]);
}

export function getAllowedLength(
  contractAddress: string,
  returns: string
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'allowedLength',
    'allowedLength():(uint64)'
  )
    .withArgs([])
    .returns([ethereum.Value.fromUnsignedBigInt(BigInt.fromString(returns))]);
}

export function getSupportsInterface(
  contractAddress: string,
  interfaceId: string,
  returns: boolean
): void {
  createMockedFunction(
    Address.fromString(contractAddress),
    'supportsInterface',
    'supportsInterface(bytes4):(bool)'
  )
    .withArgs([
      ethereum.Value.fromFixedBytes(Bytes.fromHexString(interfaceId) as Bytes),
    ])
    .returns([ethereum.Value.fromBoolean(returns)]);
}

// state

export function createDaoEntityState(
  entityID: string,
  creator: string,
  token: string
): Dao {
  let daoEntity = new Dao(entityID);
  daoEntity.creator = Address.fromString(creator);
  daoEntity.createdAt = BigInt.zero();
  daoEntity.token = Address.fromString(token).toHexString();
  // random tx hash for testing purposes only
  daoEntity.txHash = Bytes.fromHexString('0x01');
  daoEntity.save();

  return daoEntity;
}

export function encodeWithFunctionSelector(
  tuple: Array<ethereum.Value>,
  funcSelector: string,
  isDynamic: boolean = false
): Bytes {
  // ethereum.decode inside subgraph doesn't append 0x00...20 while the actual event
  // thrown from the real network includes this appended offset. Due to this, mappings contain
  // extra logic(appending the offset to the actual calldata in order to do ethereum.decode).
  // Due to this, from the tests, we need to append it as well. Note that this rule only applies
  // when the emitted event contains at least 1 dynamic type.
  let index = isDynamic == true ? 66 : 2;

  let encoded = ethereum.encode(
    ethereum.Value.fromTuple(changetype<ethereum.Tuple>(tuple))
  );

  // warning to satisfy eslint but not introduce a breaking change
  if (!encoded)
    log.warning(
      'encodeWithFunctionSelector::Could not encode ethereum tuple',
      []
    );

  let calldata = (encoded as Bytes).toHexString().substring(index);
  let functionData = funcSelector.concat(calldata);

  return Bytes.fromHexString(functionData);
}


### File: /home/errick/core/packages/subgraph/tests/dao/dao_v1_3_0.test.ts ###
import {ERC721Balance} from '../../generated/schema';
import {Executed} from '../../generated/templates/DaoTemplateV1_3_0/DAO';
import {handleExecuted} from '../../src/dao/dao_v1_3_0';
import {
  generateActionEntityId,
  generateDeterministicActionId,
  generateDeterministicActionBatchId,
  generateActionBatchEntityId,
} from '../../src/dao/ids';
import {
  generateERC1155TransferEntityId,
  generateTokenEntityId,
} from '../../src/utils/ids';
import {
  ERC20_transfer,
  ERC20_transferFrom,
  ERC721_transferFrom,
  ERC721_safeTransferFromWithData,
  ERC1155_safeTransferFrom,
  ERC1155_safeBatchTransferFrom,
  ERC1155_INTERFACE_ID,
  ERC165_INTERFACE_ID,
} from '../../src/utils/tokens/common';
import {
  DAO_ADDRESS,
  DAO_TOKEN_ADDRESS,
  ERC20_AMOUNT_HALF,
  ADDRESS_THREE,
  ERC20_AMOUNT_FULL,
  CONTRACT_ADDRESS,
  ZERO_BYTES32,
  TOKEN_NAME,
  TOKEN_SYMBOL,
  ERC20_TOTAL_SUPPLY,
  ERC20_DECIMALS,
  ADDRESS_ONE,
  ADDRESS_TWO,
} from '../constants';
import {
  ExtendedERC1155Balance,
  ExtendedERC1155Contract,
  ExtendedERC1155TokenIdBalance,
  ExtendedERC1155Transfer,
} from '../helpers/extended-schema';
import {
  createNewExecutedEvent,
  encodeWithFunctionSelector,
  getBalanceOf,
  getSupportsInterface,
} from './utils';
import {
  generateBalanceEntityId,
  generateDaoEntityId,
  generateTokenIdBalanceEntityId,
  generateTransferEntityId,
  createDummyAction,
  createERC20TokenCalls,
  createERC1155TokenCalls,
} from '@aragon/osx-commons-subgraph';
import {ethereum, Bytes, Address, BigInt} from '@graphprotocol/graph-ts';
import {
  describe,
  test,
  beforeEach,
  afterEach,
  clearStore,
  assert,
  beforeAll,
} from 'matchstick-as';

const eq = assert.fieldEquals;
let daoAddress = Address.fromString(DAO_ADDRESS);
let tokenAddress = Address.fromString(DAO_TOKEN_ADDRESS);
let daoEntityId = generateDaoEntityId(daoAddress);
let tokenEntityId = generateTokenEntityId(tokenAddress);
let balanceEntityId = generateBalanceEntityId(daoAddress, tokenAddress);

describe('handleExecuted', () => {
  afterEach(() => {
    clearStore();
  });

  test('successfuly creates action and actionBatch', () => {
    let tuple: Array<ethereum.Value> = [ethereum.Value.fromString('')];
    let selector = '0x11111111';

    let execResults = [
      Bytes.fromHexString('0x11'),
      Bytes.fromHexString('0x22'),
    ];

    let allowFailureMap = '2';
    let failureMap = '2';

    let event = createExecutedEvent(
      [tuple, tuple],
      [selector, selector],
      allowFailureMap,
      false,
      execResults,
      failureMap
    );

    handleExecuted(event);

    const deterministicID = generateDeterministicActionBatchId(
      event.params.actor,
      event.address,
      event.params.callId
    );

    let actionBatchEntityId = generateActionBatchEntityId(
      event.params.actor,
      event.address,
      event.params.callId,
      event.transaction.hash,
      event.transactionLogIndex
    );

    assert.entityCount('ActionBatch', 1);
    assert.entityCount('Action', 2);

    eq('ActionBatch', actionBatchEntityId, 'id', actionBatchEntityId);
    eq('ActionBatch', actionBatchEntityId, 'failureMap', failureMap);
    eq('ActionBatch', actionBatchEntityId, 'allowFailureMap', allowFailureMap);

    assert.fieldEquals(
      'ActionBatch',
      actionBatchEntityId,
      'deterministicId',
      deterministicID
    );

    for (let i = 0; i < event.params.actions.length; i++) {
      const deterministicActionID = generateDeterministicActionId(
        event.params.actor,
        event.address,
        event.params.callId,
        i
      );

      let actionEntityId = generateActionEntityId(
        event.params.actor,
        event.address,
        event.params.callId,
        i,
        event.transaction.hash,
        event.transactionLogIndex
      );

      eq('Action', actionEntityId, 'id', actionEntityId);
      eq('Action', actionEntityId, 'execResult', execResults[i].toHexString());
      eq('Action', actionEntityId, 'dao', DAO_ADDRESS);
      eq('Action', actionEntityId, 'actionBatch', actionBatchEntityId);
      eq('Action', actionEntityId, 'deterministicId', deterministicActionID);
      eq(
        'Action',
        actionEntityId,
        'data',
        encodeWithFunctionSelector(tuple, selector).toHexString()
      );
    }
  });

  test('Duplicate deterministic ids will point to different proposals and actions', () => {
    let tuple: Array<ethereum.Value> = [ethereum.Value.fromString('')];
    let selector = '0x11111111';

    let execResults = [
      Bytes.fromHexString('0x11'),
      Bytes.fromHexString('0x22'),
    ];

    let allowFailureMap = '2';
    let failureMap = '2';

    // event 0 has 2 actions
    let event0 = createExecutedEvent(
      [tuple, tuple],
      [selector, selector],
      allowFailureMap,
      false,
      execResults,
      failureMap
    );

    // event1 has 1 action
    let event1 = createExecutedEvent(
      [tuple],
      [selector],
      allowFailureMap,
      false,
      execResults,
      failureMap
    );

    // increment the log index to make sure the transaction actions are different
    // for the two events even if they are in the same block
    event1.logIndex = event1.logIndex.plus(BigInt.fromI32(1));
    event1.transactionLogIndex = event1.logIndex;

    assert.entityCount('Action', 0);
    assert.entityCount('ActionBatch', 0);

    handleExecuted(event0);
    handleExecuted(event1);

    // The action and proposal count should be the same.
    assert.entityCount('ActionBatch', 2);
    assert.entityCount('Action', 3);
  });

  describe('ERC20 action', () => {
    beforeAll(() => {
      createERC20TokenCalls(
        DAO_TOKEN_ADDRESS,
        ERC20_TOTAL_SUPPLY,
        TOKEN_NAME,
        TOKEN_SYMBOL,
        ERC20_DECIMALS
      );
      getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      getBalanceOf(DAO_TOKEN_ADDRESS, DAO_TOKEN_ADDRESS, ERC20_AMOUNT_HALF);

      // Even though for ERC20, there's no need to be mocking supportsInterface of ERC721,
      // The below is still required. This is caused by the fact that ERC20's transferFrom
      // And ERC721 transferFrom exactly have the same signature and mapping can't detect,
      // So the test should be agnostic even if ERC721 check gets called first from mapping.
      // Otherwise, without the below mock and if ERC721 check is called from mapping, the test
      // Would fail. https://github.com/LimeChain/matchstick/issues/278#issuecomment-1426884510
      getSupportsInterface(DAO_TOKEN_ADDRESS, '0x01ffc9a7', false);
      getSupportsInterface(DAO_TOKEN_ADDRESS, '80ac58cd', false);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });

    describe('ERC20 transfer action', () => {
      beforeAll(() => {
        createERC20TokenCalls(
          DAO_TOKEN_ADDRESS,
          ERC20_TOTAL_SUPPLY,
          TOKEN_NAME,
          TOKEN_SYMBOL
        );

        getSupportsInterface(DAO_TOKEN_ADDRESS, ERC165_INTERFACE_ID, true);
        getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
      });

      test('creates entities with correct values', () => {
        let transferToken = BigInt.fromU32(10);
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToken),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transfer],
          '0',
          false,
          [],
          '0'
        );

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        // check ERC20Contract entity
        eq('ERC20Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC20Contract', tokenEntityId, 'name', TOKEN_NAME);
        eq('ERC20Contract', tokenEntityId, 'symbol', TOKEN_SYMBOL);
        assert.entityCount('ERC20Contract', 1);

        // check ERC20Balance entity
        eq('ERC20Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC20Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC20Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);
        eq(
          'ERC20Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC20Balance', 1);

        // Check ERC20Transfer
        eq('ERC20Transfer', transferId, 'id', transferId);
        eq('ERC20Transfer', transferId, 'dao', daoEntityId);
        eq('ERC20Transfer', transferId, 'amount', transferToken.toString());
        eq('ERC20Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC20Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC20Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC20Transfer', transferId, 'type', 'Withdraw');
        eq('ERC20Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC20Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC20Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(10)),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transfer],
          '0',
          false,
          [],
          '0'
        );

        handleExecuted(event);

        // After 1st event
        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Transfer', 1);
        assert.entityCount('ERC20Balance', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);

        // Mock balance of with different amount
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_FULL);

        // Change log index so it will enforce to generate new transferId
        // to make sure we can aserst ERC20Transfer to be 2.
        event.transactionLogIndex = BigInt.fromI32(2);
        handleExecuted(event);

        // After 2nd event
        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Transfer', 2);
        assert.entityCount('ERC20Balance', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_FULL);

        // Mock balance to get it back to the same before running this test
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      });
    });

    describe('ERC20(transferFrom) action', () => {
      test('creates entities with correct values', () => {
        let transferToken = BigInt.fromU32(10);
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToken),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transferFrom],
          '0',
          false,
          [],
          '0'
        );

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        // check ERC20Contract entity
        eq('ERC20Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC20Contract', tokenEntityId, 'name', TOKEN_NAME);
        eq('ERC20Contract', tokenEntityId, 'symbol', TOKEN_SYMBOL);
        assert.entityCount('ERC20Contract', 1);

        // check ERC20Balance entity
        eq('ERC20Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC20Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC20Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);
        eq(
          'ERC20Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC20Balance', 1);

        // Check ERC20Transfer
        eq('ERC20Transfer', transferId, 'id', transferId);
        eq('ERC20Transfer', transferId, 'dao', daoEntityId);
        eq('ERC20Transfer', transferId, 'amount', transferToken.toString());
        eq('ERC20Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC20Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC20Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC20Transfer', transferId, 'type', 'Withdraw');
        eq('ERC20Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC20Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC20Transfer', 1);
      });

      test('correctly handles multiple events and update balance', () => {
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(BigInt.fromU32(10)),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC20_transferFrom],
          '0',
          false,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Balance', 1);
        assert.entityCount('ERC20Transfer', 1);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_HALF);

        // Mock balance of with different amount
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_FULL);

        // Change log index so it will enforce to generate new transferId
        // to make sure we can aserst ERC20Transfer to be 2.
        event.transactionLogIndex = BigInt.fromI32(2);
        handleExecuted(event);

        assert.entityCount('ERC20Contract', 1);
        assert.entityCount('ERC20Balance', 1);
        assert.entityCount('ERC20Transfer', 2);
        eq('ERC20Balance', balanceEntityId, 'balance', ERC20_AMOUNT_FULL);

        // Mock balance to get it back to the same before running this test
        getBalanceOf(DAO_TOKEN_ADDRESS, DAO_ADDRESS, ERC20_AMOUNT_HALF);
      });
    });
  });

  describe('ERC721 action', () => {
    beforeAll(() => {
      createERC20TokenCalls(
        DAO_TOKEN_ADDRESS,
        ERC20_TOTAL_SUPPLY,
        TOKEN_NAME,
        TOKEN_SYMBOL
      );

      getSupportsInterface(DAO_TOKEN_ADDRESS, '0x01ffc9a7', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, '80ac58cd', true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });

    beforeEach(() => {
      let entity = new ERC721Balance(balanceEntityId);
      entity.dao = daoEntityId;
      entity.tokenIds = [
        BigInt.fromI32(4),
        BigInt.fromI32(8),
        BigInt.fromI32(12),
      ];
      entity.lastUpdated = BigInt.fromI32(2);
      entity.token = tokenEntityId;
      entity.save();
    });

    describe('ERC721 transferFrom', () => {
      test('create entities with correct values', () => {
        let transferToKen = BigInt.fromU32(8);

        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToKen),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC721_transferFrom],
          '0',
          false,
          [],
          '0'
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );

        // check ERC721Contract entity
        eq('ERC721Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC721Contract', tokenEntityId, 'name', TOKEN_NAME);
        eq('ERC721Contract', tokenEntityId, 'symbol', TOKEN_SYMBOL);
        assert.entityCount('ERC721Contract', 1);

        // check ERC721Balance entity
        eq('ERC721Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC721Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC721Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4, 12]');
        eq(
          'ERC721Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC721Balance', 1);

        // Check ERC721Transfer
        eq('ERC721Transfer', transferId, 'id', transferId);
        eq('ERC721Transfer', transferId, 'dao', daoEntityId);
        eq('ERC721Transfer', transferId, 'tokenId', transferToKen.toString());
        eq('ERC721Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC721Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC721Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC721Transfer', transferId, 'type', 'Withdraw');
        eq('ERC721Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC721Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC721Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let from = ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS));
        let to = ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE));
        let transferToken1 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(8)
        );
        let transferToken2 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(12)
        );

        let tuple1: Array<ethereum.Value> = [from, to, transferToken1];
        let tuple2: Array<ethereum.Value> = [from, to, transferToken2];

        let event = createExecutedEvent(
          [tuple1, tuple2],
          [ERC721_transferFrom, ERC721_transferFrom],
          '0',
          false,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC721Contract', 1);
        assert.entityCount('ERC721Balance', 1);
        assert.entityCount('ERC721Transfer', 2);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4]');
      });
    });

    describe('ERC721 safeTransferFrom with data', () => {
      test('create entities with correct values', () => {
        let transferToKen = BigInt.fromU32(8);

        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
          ethereum.Value.fromUnsignedBigInt(transferToKen),
          ethereum.Value.fromBytes(Bytes.fromHexString('0x')),
        ];

        let event = createExecutedEvent(
          [tupleArray],
          [ERC721_safeTransferFromWithData],
          '0',
          true,
          [],
          '0'
        );

        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let timestamp = event.block.timestamp;

        let transferId = generateTransferEntityId(txHash, logIndex, 0);

        handleExecuted(event);

        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        // check ERC721Contract entity
        eq('ERC721Contract', tokenEntityId, 'id', tokenEntityId);
        eq('ERC721Contract', tokenEntityId, 'name', TOKEN_NAME);
        eq('ERC721Contract', tokenEntityId, 'symbol', TOKEN_SYMBOL);
        assert.entityCount('ERC721Contract', 1);

        // check ERC721Balance entity
        eq('ERC721Balance', balanceEntityId, 'id', balanceEntityId);
        eq('ERC721Balance', balanceEntityId, 'token', tokenEntityId);
        eq('ERC721Balance', balanceEntityId, 'dao', daoEntityId);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4, 12]');
        eq(
          'ERC721Balance',
          balanceEntityId,
          'lastUpdated',
          timestamp.toString()
        );
        assert.entityCount('ERC721Balance', 1);

        // Check ERC721Transfer
        eq('ERC721Transfer', transferId, 'id', transferId);
        eq('ERC721Transfer', transferId, 'dao', daoEntityId);
        eq('ERC721Transfer', transferId, 'tokenId', transferToKen.toString());
        eq('ERC721Transfer', transferId, 'from', DAO_ADDRESS);
        eq('ERC721Transfer', transferId, 'to', ADDRESS_THREE);
        eq('ERC721Transfer', transferId, 'actionBatch', actionBatchEntityId);
        eq('ERC721Transfer', transferId, 'type', 'Withdraw');
        eq('ERC721Transfer', transferId, 'txHash', txHash.toHexString());
        eq('ERC721Transfer', transferId, 'createdAt', timestamp.toString());
        assert.entityCount('ERC721Transfer', 1);
      });

      test('correctly handles multiple events and updates balance', () => {
        let from = ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS));
        let to = ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE));
        let data = ethereum.Value.fromBytes(Bytes.fromHexString('0x'));

        let transferToken1 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(8)
        );
        let transferToken2 = ethereum.Value.fromUnsignedBigInt(
          BigInt.fromU32(12)
        );

        let tuple1: Array<ethereum.Value> = [from, to, transferToken1, data];
        let tuple2: Array<ethereum.Value> = [from, to, transferToken2, data];

        let event = createExecutedEvent(
          [tuple1, tuple2],
          [ERC721_safeTransferFromWithData, ERC721_safeTransferFromWithData],
          '0',
          true,
          [],
          '0'
        );

        handleExecuted(event);

        assert.entityCount('ERC721Contract', 1);
        assert.entityCount('ERC721Balance', 1);
        assert.entityCount('ERC721Transfer', 2);
        eq('ERC721Balance', balanceEntityId, 'tokenIds', '[4]');
      });
    });
  });
  describe('ERC1155 action', () => {
    beforeAll(() => {
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '0',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '1',
        'https://example.org/{id}.json'
      );
      createERC1155TokenCalls(
        DAO_TOKEN_ADDRESS,
        '2',
        'https://example.org/{id}.json'
      );
      getSupportsInterface(DAO_TOKEN_ADDRESS, ERC1155_INTERFACE_ID, true);
      getSupportsInterface(DAO_TOKEN_ADDRESS, 'ffffffff', false);
    });
    beforeEach(() => {
      clearStore();
    });

    describe('ERC1155 safeTransferFrom', () => {
      test('create entities with correct values', () => {
        let transferToken = BigInt.fromU32(0);
        let amount = BigInt.fromU32(10);

        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)), // from
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // to
          ethereum.Value.fromUnsignedBigInt(transferToken), // tokenId
          ethereum.Value.fromUnsignedBigInt(amount), // amount
          ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
        ];
        let event = createExecutedEvent(
          [tupleArray],
          [ERC1155_safeTransferFrom],
          '0',
          true,
          [],
          '0'
        );
        handleExecuted(event);

        let timestamp = event.block.timestamp;

        // check ERC1155Contract entity
        assert.entityCount('ERC1155Contract', 1);
        let erc1155Contract = new ExtendedERC1155Contract().withDefaultValues();
        erc1155Contract.assertEntity();

        // check ERC1155Balance entity
        assert.entityCount('ERC1155Balance', 1);
        let erc1155Balance = new ExtendedERC1155Balance().withDefaultValues();
        erc1155Balance.lastUpdated = timestamp;
        erc1155Balance.assertEntity();

        // check ERC1155TokenIdBalance entity
        assert.entityCount('ERC1155TokenIdBalance', 1);
        let erc1155TokenIdBalance =
          new ExtendedERC1155TokenIdBalance().withDefaultValues();
        erc1155TokenIdBalance.amount = amount;
        erc1155TokenIdBalance.lastUpdated = timestamp;
        erc1155TokenIdBalance.assertEntity();

        // check ERC1155Transfer entity
        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let transferId = generateERC1155TransferEntityId(
          txHash,
          logIndex,
          0,
          0
        );
        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        assert.entityCount('ERC1155Transfer', 1);
        let erc1155Transfer = new ExtendedERC1155Transfer().withDefaultValues();
        erc1155Transfer.id = transferId;
        erc1155Transfer.amount = amount;
        erc1155Transfer.from = Address.fromHexString(daoEntityId);
        erc1155Transfer.to = Address.fromHexString(ADDRESS_THREE);
        erc1155Transfer.actionBatch = actionBatchEntityId;
        erc1155Transfer.type = 'Withdraw';
        erc1155Transfer.txHash = txHash;
        erc1155Transfer.createdAt = timestamp;
        erc1155Transfer.assertEntity();
      });
      test('correctly handles multiple events and updates balance', () => {
        let amount = BigInt.fromU32(10);
        let transferTokens = [BigInt.fromU32(0), BigInt.fromU32(1)];
        let tuples: ethereum.Value[][] = [];
        for (let i = 0; i < transferTokens.length; i++) {
          tuples.push([
            ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)),
            ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)),
            ethereum.Value.fromUnsignedBigInt(transferTokens[i]),
            ethereum.Value.fromUnsignedBigInt(amount),
            ethereum.Value.fromBytes(Bytes.fromHexString('0x')),
          ]);
        }

        let event = createExecutedEvent(
          tuples,
          [ERC1155_safeTransferFrom, ERC1155_safeTransferFrom],
          '0',
          true,
          [],
          '0'
        );
        handleExecuted(event);

        let erc1155TokenIdBalanceIdArray: string[] = [];
        for (let i = 0; i < transferTokens.length; i++) {
          erc1155TokenIdBalanceIdArray.push(
            generateTokenIdBalanceEntityId(
              daoAddress,
              tokenAddress,
              transferTokens[i]
            )
          );
        }

        assert.entityCount('ERC1155Contract', 1);
        assert.entityCount('ERC1155Transfer', 2);
        assert.entityCount('ERC1155Balance', 1);
        assert.entityCount('ERC1155TokenIdBalance', 2);
      });
    });
    describe('ERC1155 safeBatchTransferFrom', () => {
      test('create entities with correct values', () => {
        let tokenIds = [
          BigInt.fromI32(0),
          BigInt.fromI32(1),
          BigInt.fromI32(2),
        ];
        let amounts = [
          BigInt.fromI32(10),
          BigInt.fromI32(10),
          BigInt.fromI32(10),
        ];
        let tupleArray: Array<ethereum.Value> = [
          ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)), // from
          ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // to
          ethereum.Value.fromUnsignedBigIntArray(tokenIds), // tokenIds
          ethereum.Value.fromUnsignedBigIntArray(amounts), // amounts
          ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
        ];
        let event = createExecutedEvent(
          [tupleArray],
          [ERC1155_safeBatchTransferFrom],
          '0',
          true,
          [],
          '0'
        );
        handleExecuted(event);

        let timestamp = event.block.timestamp;
        let tokenIdBalanceIdArray: string[] = [];
        // iterate over tokenIds
        for (let i = 0; i < tokenIds.length; i++) {
          tokenIdBalanceIdArray.push(
            generateTokenIdBalanceEntityId(
              daoAddress,
              tokenAddress,
              tokenIds[i]
            )
          );
        }
        // check ERC1155Contract entity
        assert.entityCount('ERC1155Contract', 1);
        let erc1155Contract = new ExtendedERC1155Contract().withDefaultValues();
        erc1155Contract.assertEntity();
        // check ERC1155Balance entity
        assert.entityCount('ERC1155Balance', 1);
        let erc1155Balance = new ExtendedERC1155Balance().withDefaultValues();
        erc1155Balance.lastUpdated = timestamp;
        erc1155Balance.assertEntity();
        // check ERC1155TokenIdBalance entity
        assert.entityCount('ERC1155TokenIdBalance', 3);
        for (let i = 0; i < tokenIds.length; i++) {
          let erc1155TokenIdBalance =
            new ExtendedERC1155TokenIdBalance().withDefaultValues();
          erc1155TokenIdBalance.id = tokenIdBalanceIdArray[i];
          erc1155TokenIdBalance.tokenId = tokenIds[i];
          erc1155TokenIdBalance.amount = amounts[i];
          erc1155TokenIdBalance.lastUpdated = timestamp;
          erc1155TokenIdBalance.balance = balanceEntityId;
          erc1155TokenIdBalance.assertEntity();
        }
        // check ERC1155Transfer entity
        let txHash = event.transaction.hash;
        let logIndex = event.transactionLogIndex;
        let actionBatchEntityId = generateActionBatchEntityId(
          event.params.actor,
          event.address,
          event.params.callId,
          event.transaction.hash,
          event.transactionLogIndex
        );
        for (let i = 0; i < tokenIds.length; i++) {
          let erc1155Transfer =
            new ExtendedERC1155Transfer().withDefaultValues();
          erc1155Transfer.id = generateERC1155TransferEntityId(
            txHash,
            logIndex,
            0,
            i
          );
          // appeend index to transferId to make sure it is unique
          erc1155Transfer.amount = amounts[i];
          erc1155Transfer.from = Address.fromHexString(daoEntityId);
          erc1155Transfer.to = Address.fromHexString(ADDRESS_THREE);
          erc1155Transfer.tokenId = tokenIds[i];
          erc1155Transfer.actionBatch = actionBatchEntityId;
          erc1155Transfer.type = 'Withdraw';
          erc1155Transfer.txHash = txHash;
          erc1155Transfer.createdAt = timestamp;
          erc1155Transfer.assertEntity();
        }
      });
      test('correctly handles multiple events and updates balance', () => {
        let tokenIds = [
          [BigInt.fromI32(0), BigInt.fromI32(1), BigInt.fromI32(2)],
          [BigInt.fromI32(0), BigInt.fromI32(1), BigInt.fromI32(2)],
        ];
        let amounts = [
          [BigInt.fromI32(10), BigInt.fromI32(10), BigInt.fromI32(10)],
          [BigInt.fromI32(30), BigInt.fromI32(30), BigInt.fromI32(30)],
        ];
        let tuples: ethereum.Value[][] = [];
        for (let i = 0; i < tokenIds.length; i++) {
          tuples.push([
            ethereum.Value.fromAddress(Address.fromString(DAO_ADDRESS)), // from
            ethereum.Value.fromAddress(Address.fromString(ADDRESS_THREE)), // to
            ethereum.Value.fromUnsignedBigIntArray(tokenIds[i]), // tokenIds
            ethereum.Value.fromUnsignedBigIntArray(amounts[i]), // amounts
            ethereum.Value.fromBytes(Bytes.fromHexString('0x')), // data
          ]);
        }
        let event = createExecutedEvent(
          tuples,
          [ERC1155_safeBatchTransferFrom, ERC1155_safeBatchTransferFrom],
          '0',
          true,
          [],
          '0'
        );
        handleExecuted(event);
        let erc1155TokenIdBalanceIdArray: string[] = [];
        for (let i = 0; i < tokenIds[0].length; i++) {
          erc1155TokenIdBalanceIdArray.push(
            generateTokenIdBalanceEntityId(
              daoAddress,
              tokenAddress,
              tokenIds[0][i]
            )
          );
        }
        // check ERC ontract entity
        assert.entityCount('ERC1155Contract', 1);
        let erc1155Contract = new ExtendedERC1155Contract().withDefaultValues();
        erc1155Contract.assertEntity();
        // check ERC1155Balance entity
        assert.entityCount('ERC1155Transfer', 6);
        assert.entityCount('ERC1155Balance', 1);
        assert.entityCount('ERC1155TokenIdBalance', 3);
      });
    });
  });
});

describe('Testing ID generation', () => {
  test('Deterministic ID generation', () => {
    const caller = Address.fromString(ADDRESS_ONE);
    const daoAddress = Address.fromString(ADDRESS_TWO);
    const callId = '0xc0ffee';
    const index = 255;

    const actionId = generateDeterministicActionId(
      caller,
      daoAddress,
      Bytes.fromHexString(callId),
      index
    );

    assert.stringEquals(
      actionId,
      [
        caller.toHexString(),
        daoAddress.toHexString(),
        callId,
        index.toString(),
      ].join('_')
    );
  });

  test('ID generation with Tx data', () => {
    const caller = Address.fromString(ADDRESS_ONE);
    const daoAddress = Address.fromString(ADDRESS_TWO);
    const callId = ZERO_BYTES32;
    const index = 255;
    const txHash = Bytes.fromHexString('0x1234567890abcdef');
    const logIndex = BigInt.fromI32(12345);

    const actionId = generateActionEntityId(
      caller,
      daoAddress,
      Bytes.fromHexString(callId),
      index,
      txHash,
      logIndex
    );

    // Assemblyscript can only concat if all are strings
    // make sure your bytes are casted correctly
    assert.stringEquals(
      actionId,
      [
        caller.toHexString(),
        daoAddress.toHexString(),
        callId,
        index.toString(),
        txHash.toHexString(),
        logIndex.toString(),
      ].join('_')
    );
  });
});

// create Executed event with multiple actions
function createExecutedEvent(
  tuple: ethereum.Value[][],
  selectors: string[],
  allowFailureMap: string,
  isDynamic: boolean,
  execResults: Bytes[],
  failureMap: string
): Executed {
  let actions: ethereum.Tuple[] = [];
  for (let i = 0; i < selectors.length; i++) {
    let functionData = encodeWithFunctionSelector(
      tuple[i],
      selectors[i],
      isDynamic
    );

    let action = createDummyAction(
      DAO_TOKEN_ADDRESS,
      '0',
      functionData.toHexString()
    );

    actions.push(action as ethereum.Tuple);
  }

  if (execResults.length == 0) {
    for (let i = 0; i < actions.length; i++) {
      execResults[i] = Bytes.fromHexString('0x11');
    }
  }

  let event = createNewExecutedEvent<Executed>(
    Address.fromHexString(CONTRACT_ADDRESS).toHexString(),
    ZERO_BYTES32,
    actions,
    BigInt.fromString(failureMap),
    execResults,
    Address.fromHexString(DAO_ADDRESS).toHexString(),
    BigInt.fromString(allowFailureMap)
  );

  return event;
}


### File: /home/errick/core/packages/subgraph/tests/registry/pluginRepoRegistry.test.ts ###
import {handlePluginRepoRegistered} from '../../src/registries/pluginRepoRegistry';
import {ADDRESS_ONE} from '../constants';
import {createPluginRepoRegisteredEvent} from './utils';
import {generatePluginRepoEntityId} from '@aragon/osx-commons-subgraph';
import {Address} from '@graphprotocol/graph-ts';
import {assert, clearStore, test} from 'matchstick-as/assembly/index';

test('Run plugin repo registry mappings with mock event', () => {
  const pluginRepoAddress = Address.fromString(ADDRESS_ONE);
  const pluginRepoEntityId = generatePluginRepoEntityId(pluginRepoAddress);
  let newRepoRegisteredEvent = createPluginRepoRegisteredEvent(
    'plugin-repo',
    pluginRepoEntityId
  );

  handlePluginRepoRegistered(newRepoRegisteredEvent);

  assert.fieldEquals(
    'PluginRepo',
    pluginRepoEntityId,
    'subdomain',
    'plugin-repo'
  );

  clearStore();
});


### File: /home/errick/core/packages/subgraph/tests/registry/utils.ts ###
import {DAORegistered} from '../../generated/DAORegistry/DAORegistry';
import {PluginRepoRegistered} from '../../generated/PluginRepoRegistry/PluginRepoRegistry';
import {Address, ethereum} from '@graphprotocol/graph-ts';
import {newMockEvent} from 'matchstick-as/assembly/index';

// events

export function createNewDaoEvent(
  dao: string,
  creator: string,
  name: string
): DAORegistered {
  let newDaoEvent = changetype<DAORegistered>(newMockEvent());

  newDaoEvent.parameters = [];

  let daoParam = new ethereum.EventParam(
    'dao',
    ethereum.Value.fromAddress(Address.fromString(dao))
  );
  let creatorParam = new ethereum.EventParam(
    'creator',
    ethereum.Value.fromAddress(Address.fromString(creator))
  );
  let nameParam = new ethereum.EventParam(
    'name',
    ethereum.Value.fromString(name)
  );

  newDaoEvent.parameters.push(daoParam);
  newDaoEvent.parameters.push(creatorParam);
  newDaoEvent.parameters.push(nameParam);

  return newDaoEvent;
}

export function createPluginRepoRegisteredEvent(
  name: string,
  pluginRepo: string
): PluginRepoRegistered {
  let newPluginRepo = changetype<PluginRepoRegistered>(newMockEvent());

  newPluginRepo.parameters = [];

  let nameParam = new ethereum.EventParam(
    'name',
    ethereum.Value.fromString(name)
  );

  let pluginRepoParam = new ethereum.EventParam(
    'pluginRepo',
    ethereum.Value.fromAddress(Address.fromString(pluginRepo))
  );

  newPluginRepo.parameters.push(nameParam);
  newPluginRepo.parameters.push(pluginRepoParam);

  return newPluginRepo;
}


### File: /home/errick/core/packages/subgraph/tests/registry/daoRegistry.test.ts ###
import {Dao} from '../../generated/schema';
import {handleDAORegistered} from '../../src/registries/daoRegistry';
import {DAO_ADDRESS, ADDRESS_ONE} from '../constants';
import {createNewDaoEvent} from './utils';
import {generateDaoEntityId} from '@aragon/osx-commons-subgraph';
import {Address} from '@graphprotocol/graph-ts';
import {
  assert,
  clearStore,
  test,
  dataSourceMock,
  describe,
  afterEach,
} from 'matchstick-as/assembly/index';

describe('DAORegistry', () => {
  afterEach(() => {
    clearStore();
  });

  test('Run dao registry mappings with mock event', () => {
    // create event
    let newDaoEvent = createNewDaoEvent(DAO_ADDRESS, ADDRESS_ONE, 'mock-Dao');

    // handle event
    handleDAORegistered(newDaoEvent);

    const daoAddress = Address.fromString(DAO_ADDRESS);
    const daoEntityId = generateDaoEntityId(daoAddress);

    // checks
    assert.fieldEquals('Dao', daoEntityId, 'id', daoEntityId);
    assert.fieldEquals(
      'Dao',
      daoEntityId,
      'creator',
      Address.fromString(ADDRESS_ONE).toHexString()
    );
    assert.fieldEquals('Dao', daoEntityId, 'subdomain', 'mock-Dao');
    assert.fieldEquals(
      'Dao',
      daoEntityId,
      'createdAt',
      newDaoEvent.block.timestamp.toString()
    );
    assert.fieldEquals(
      'Dao',
      daoEntityId,
      'txHash',
      newDaoEvent.transaction.hash.toHexString()
    );
  });

  test("Don't store subdomain for blocklisted DAO", () => {
    // Using an already blocklisted address for mainnet. This is unlikely to change
    let denylistedEntityId = '0x16070493aa513f91fc8957f14b7b7c6c0c41fbac';
    // create event.
    let newDaoEvent = createNewDaoEvent(
      denylistedEntityId,
      ADDRESS_ONE,
      'mock-Dao'
    );
    dataSourceMock.setNetwork('mainnet');

    handleDAORegistered(newDaoEvent);

    // checks
    assert.fieldEquals('Dao', denylistedEntityId, 'id', denylistedEntityId);
    assert.fieldEquals(
      'Dao',
      denylistedEntityId,
      'creator',
      Address.fromString(ADDRESS_ONE).toHexString()
    );
    assert.fieldEquals(
      'Dao',
      denylistedEntityId,
      'createdAt',
      newDaoEvent.block.timestamp.toString()
    );
    assert.fieldEquals(
      'Dao',
      denylistedEntityId,
      'txHash',
      newDaoEvent.transaction.hash.toHexString()
    );

    const daoEntity = Dao.load(denylistedEntityId);

    if (!daoEntity) throw new Error('daoEntity is null');

    assert.assertNull(daoEntity.subdomain);
  });
});


### File: /home/errick/core/packages/subgraph/types/ASM.d.ts ###
/// AssemblyScript types to remove false errors from the compiler
interface ethereum {
  event: import('@graphprotocol/graph-ts/chain/ethereum').ethereum.Event;
  value: import('@graphprotocol/graph-ts/chain/ethereum').ethereum.Value;
}

// type casting through generics is a bit tricky so just add overloads here as you need them
declare function changetype<T>(input: ethereum['event']): T & ethereum['event'];
declare function changetype<T>(
  input: ethereum['value'][]
): T & ethereum['value'];

declare type i32 = number;


### File: /home/errick/core/packages/subgraph/scripts/build-manifest.sh ###
#!/bin/bash


if [ -f .env ]
then
  export $(cat .env | sed 's/#.*//g' | xargs)
fi

if [ -z "$NETWORK_NAME" ] 
then
    echo "env is not set, exiting..."
    exit -1
else
    echo "env Network is set to: $NETWORK_NAME"
fi

FILE=$NETWORK_NAME'.json'
DATA=manifest/data/$FILE

ARAGON_OSX_MODULE=$(node -e 'console.log(require("path").dirname(require.resolve("@aragon/osx-artifacts/package.json")))')

echo 'Generating manifest from data file: '$DATA
cat $DATA

mustache \
  $DATA \
  manifest/subgraph.placeholder.yaml \
  | sed -e "s#\$ARAGON_OSX_MODULE#$ARAGON_OSX_MODULE#g" \
  > subgraph.yaml


### File: /home/errick/core/packages/subgraph/scripts/build-subgraph.sh ###
#!/bin/sh

set -eu

if [ ! -f "./subgraph.yaml" ]; then
  echo "The file subgraph.yaml doesn’t exist. Did you run: yarn manifest?"
  exit 1
fi

rm -rf generated
rm -rf build

graph codegen
graph build


### File: /home/errick/core/packages/subgraph/scripts/deploy-subgraph.sh ###
#!/usr/bin/env bash

if [ -f .env ]
then
  export $(cat .env | sed 's/#.*//g' | xargs)
fi

if [ -z "$NETWORK_NAME" ] || [ -z "$SUBGRAPH_NAME" ] || [ -z "$GRAPH_KEY" ] || [ -z "$SUBGRAPH_VERSION" ]
then
    echo "env variables are not set properly, exiting..."
    exit -1
fi

# Exit script as soon as a command fails.
set -o errexit

# Build manifest
echo ''
echo '> Building manifest file subgraph.yaml'
./scripts/build-manifest.sh

# Build subgraph
echo ''
echo '> Building subgraph'
./scripts/build-subgraph.sh


# Prepare subgraph name
FULLNAME=$SUBGRAPH_NAME-$NETWORK_NAME
if [ "$STAGING" ]; then
  FULLNAME=$FULLNAME-staging
fi
echo ''
echo '> Deploying subgraph: '$FULLNAME
echo '> Subgraph version: '$SUBGRAPH_VERSION

# Deploy subgraph
if [ "$LOCAL" ]
then
    graph deploy $FULLNAME \
        --version-label $SUBGRAPH_VERSION \
        --ipfs http://localhost:5001 \
        --node http://localhost:8020
else
    graph deploy $FULLNAME \
        --version-label $SUBGRAPH_VERSION \
        --ipfs https://ipfs.satsuma.xyz \
        --node https://subgraphs.alchemy.com/api/subgraphs/deploy \
        --deploy-key $GRAPH_KEY > deploy-output.txt

    SUBGRAPH_ID=$(grep "Build completed:" deploy-output.txt | grep -oE "Qm[a-zA-Z0-9]{44}")
    rm deploy-output.txt
    echo "The Graph deployment complete: ${SUBGRAPH_ID}"

fi

### File: /home/errick/core/packages/subgraph/scripts/updateLocalManifest.js ###
/* eslint-disable no-undef */
/* eslint-disable @typescript-eslint/no-var-requires */
const fs = require('fs/promises');
const path = require('path');

async function main() {
  const networks = await fs.readdir('../contracts/deployments', {
    withFileTypes: true,
  });
  for (const network of networks) {
    if (network.isDirectory()) {
      const networkName = network.name;
      const networkPath = path.join('../contracts/deployments', networkName);

      const contracts = await fs.readdir(networkPath, {withFileTypes: true});
      const manifest = {
        info: '# Do not edit subgraph.yaml,this is a generated file. \n# Instead, edit subgraph.placeholder.yaml and run: yarn manifest',
        network: networkName,
        dataSources: {},
      };

      for (const contract of contracts) {
        let name;
        let dataSourceName;
        if (contract.isFile()) {
          switch (contract.name) {
            case 'DAORegistry.json':
              dataSourceName = 'DAORegistry';
              name = 'DAORegistry';
              break;
            case 'PluginRepoRegistry.json':
              dataSourceName = 'PluginRepoRegistry';
              name = 'PluginRepoRegistry';
              break;
            case 'PluginSetupProcessor.json':
              dataSourceName = 'PluginSetupProcessors';
              name = 'PluginSetupProcessor';
              break;
          }
        }

        if (name && dataSourceName) {
          const contractPath = path.join(networkPath, contract.name);
          const contractContent = await fs.readFile(contractPath);
          const contractJson = JSON.parse(contractContent.toString());
          manifest.dataSources[dataSourceName] = {
            name,
            address: contractJson.address,
            startBlock: contractJson.receipt.blockNumber,
          };
        }
      }

      await fs.writeFile(
        `manifest/data/${networkName}.json`,
        JSON.stringify(manifest, null, 2)
      );
    }
  }
}

main();


### File: /home/errick/core/packages/subgraph/scripts/tests/generate-introspection-json.sh ###
#!/usr/bin/env bash

if [ -f .env ]
then
  export $(cat .env | sed 's/#.*//g' | xargs)
fi

if [ -z "$NETWORK_NAME" ] || [ -z "$SUBGRAPH_NAME" ]
then
    echo "env variables are not set properly, exiting..."
    exit -1
fi

# Exit script as soon as a command fails.
set -o errexit
# Up docker
docker compose -f docker/docker-compose.yml up -d
# Wait for containers to start
# Get the docker id of the graph-node container
GRAPH_NODE_CONTAINER_ID=$(docker ps -qf "name=graph-node")
# Infinite loop to wait for the graph-node to be ready
while true; do
    # check logs
    if docker logs $GRAPH_NODE_CONTAINER_ID 2>&1 | grep -q "Started all assigned subgraphs"; then
        echo "Graph Node is ready"
        break
    fi
    # wait for 1 second
    echo "Waiting for Graph Node to be ready"
    sleep 1
done
# create subgraph
graph create $SUBGRAPH_NAME-$NETWORK_NAME --node http://localhost:8020
# deploy subgraph
LOCAL=true ./scripts/deploy-subgraph.sh
# make introspection json
FILENAME="tests/utils/schema-introspection.json"
GRAPH_URL="http://localhost:8000/subgraphs/name/$SUBGRAPH_NAME-$NETWORK_NAME"
echo "Fetching introspection query from $GRAPH_URL"
node ./scripts/tests/fetch-introspection-query.js $GRAPH_URL $FILENAME
prettier $FILENAME --write
# down docker
docker compose -f docker/docker-compose.yml down


### File: /home/errick/core/packages/subgraph/scripts/tests/fetch-introspection-query.js ###
const fs = require('fs');
const fetch = require('node-fetch');

const url = process.argv[2];
const filename = process.argv[3];
console.log(url, filename);

fetchIntrospectionQuery(url, filename).catch(e => {
  console.error(e);
  process.exit(1);
});

async function fetchIntrospectionQuery(
  url,
  filename = 'introspection-query.json'
) {
  console.log('Fetching introspection query...');
  const query = `
    fragment FullType on __Type {
      kind
      name
      fields(includeDeprecated: true) {
        name
        args {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }
    fragment InputValue on __InputValue {
      name
      type {
        ...TypeRef
      }
      defaultValue
    }
    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
    query IntrospectionQuery {
      __schema {
        queryType {
          name
        }
        mutationType {
          name
        }
        types {
          ...FullType
        }
        directives {
          name
          locations
          args {
            ...InputValue
          }
        }
      }
    }
  `;
  const res = await fetch(url, {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify({
      query,
    }),
  });
  const {data} = await res.json();
  fs.writeFileSync(filename, JSON.stringify(data, null, 2));
  console.log(`Wrote introspection query to ${filename}`);
}


### File: /home/errick/core/packages/contracts/hardhat-zksync.config.ts ###
import {TestingFork} from './types/hardhat';
import {ZK_SYNC_NETWORKS} from './utils/zksync';
import RichAccounts from './utils/zksync-rich-accounts';
import {addRpcUrlToNetwork} from '@aragon/osx-commons-configs';
import '@matterlabs/hardhat-zksync-deploy';
import '@matterlabs/hardhat-zksync-ethers';
import '@matterlabs/hardhat-zksync-node';
import '@matterlabs/hardhat-zksync-solc';
import '@matterlabs/hardhat-zksync-upgradable';
import '@matterlabs/hardhat-zksync-verify';
import '@nomicfoundation/hardhat-chai-matchers';
import '@nomicfoundation/hardhat-network-helpers';
import * as dotenv from 'dotenv';
import fs from 'fs';
import 'hardhat-deploy';
import {extendEnvironment, HardhatUserConfig, task} from 'hardhat/config';
import 'solidity-coverage';

dotenv.config();

const ETH_KEY = process.env.ETH_KEY;
const accounts = ETH_KEY ? ETH_KEY.split(',') : [];

// check alchemy Api key existence
if (process.env.ALCHEMY_API_KEY) {
  addRpcUrlToNetwork(process.env.ALCHEMY_API_KEY);
} else {
  throw new Error('ALCHEMY_API_KEY in .env not set');
}

// Extend HardhatRuntimeEnvironment
extendEnvironment(hre => {
  const testingFork: TestingFork = {
    network: '',
    osxVersion: '',
    activeContracts: {},
  };
  hre.aragonToVerifyContracts = [];
  hre.managementDAOMultisigPluginAddress = ''; // TODO This must be removed after the deploy script got refactored (see https://github.com/aragon/osx/pull/582)
  hre.managementDAOActions = [];
  hre.testingFork = testingFork;
});

task('compile').setAction(async (args, hre, runSuper) => {
  await runSuper(args);

  if (ZK_SYNC_NETWORKS.includes(hre.network.name)) {
    // Copy zkSync specific build artifacts and cache to the default directories.
    // This ensures that we don't need to change import paths for artifacts in the project.
    fs.cpSync('./build/artifacts-zk', './artifacts', {
      recursive: true,
      force: true,
    });
    fs.cpSync('./build/cache-zk', './cache', {recursive: true, force: true});

    return;
  }

  fs.cpSync('./build/artifacts', './artifacts', {recursive: true, force: true});
  fs.cpSync('./build/cache', './cache', {recursive: true, force: true});
});

task('deploy-contracts')
  .addOptionalParam('tags', 'Specify which tags to deploy')
  .setAction(async (args, hre) => {
    await hre.run('compile');
    await hre.run('deploy', {
      tags: args.tags,
    });
  });

task('test').setAction(async (args, hre, runSuper) => {
  await hre.run('compile');
  const imp = await import('./test/test-utils/wrapper');

  const wrapper = await imp.Wrapper.create(
    hre.network.name,
    hre.ethers.provider
  );
  hre.wrapper = wrapper;

  await runSuper(args);
});

// You need to export an object to set up your config
// Go to https://hardhat.org/config/ to learn more
const config: HardhatUserConfig = {
  zksolc: {
    compilerSource: 'binary',
    version: '1.5.0',
  },
  solidity: {
    version: '0.8.20',
    settings: {
      optimizer: {
        enabled: true,
        runs: 2000,
      },
      outputSelection: {
        '*': {
          '*': ['storageLayout'],
        },
      },
    },
  },
  defaultNetwork: 'zkLocalTestnet',
  networks: {
    zkLocalTestnet: {
      url: 'http://127.0.0.1:8011',
      ethNetwork: 'http://127.0.0.1:8545',
      zksync: true,
      deploy: ['./deploy/new'],
      gas: 15000000,
      blockGasLimit: 30000000,
      accounts: RichAccounts,
    },
    zksyncSepolia: {
      url: 'https://sepolia.era.zksync.dev',
      ethNetwork: 'sepolia',
      zksync: true,
      verifyURL:
        'https://explorer.sepolia.era.zksync.dev/contract_verification',
      deploy: ['./deploy/new', './deploy/verification'],
      accounts: accounts,
      forceDeploy: true,
    },
    zksyncMainnet: {
      url: 'https://mainnet.era.zksync.io',
      ethNetwork: 'mainnet',
      zksync: true,
      verifyURL:
        'https://zksync2-mainnet-explorer.zksync.io/contract_verification',
      deploy: ['./deploy/new', './deploy/verification'],
      accounts: accounts,
      forceDeploy: true,
    },
  },
  namedAccounts: {
    deployer: 0,
  },
  paths: {
    sources: './src',
    tests: './test',
    cache: './build/cache',
    artifacts: './build/artifacts',
    deploy: './deploy',
  },
  mocha: {
    timeout: 90_000, // 90 seconds // increase the timeout for subdomain validation tests
  },
};

export default config;


### File: /home/errick/core/packages/contracts/.env.example ###
ETH_KEY=<Private-Key>
ETHERSCAN_KEY=<Etherscan-Api-Key>
POLYGONSCAN_KEY=<Polygonscan-Api-Key>
ARBISCAN_KEY=<Arbiscan-Api-Key>

## To deploy contracts, you need to set:
PUB_PINATA_JWT=""

## Alchemy RPC endpoint credentials
ALCHEMY_API_KEY="zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz"

COINMARKETCAP_API_KEY=<Coinmarketcap-Api-Key>

MAINNET_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
GOERLI_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
SEPOLIA_DAO_ENS_DOMAIN=<ENS-Domain example: aragon-dao.eth>
BASEMAINNET_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
BASESEPOLIA_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
ARBITRUM_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
ARBITRUMSEPOLIA_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>

#
LOCALHOST_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>
HARDHAT_DAO_ENS_DOMAIN=<ENS-Domain example: dao.eth>

MAINNET_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
GOERLI_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
SEPOLIA_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
BASEMAINNET_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
BASESEPOLIA_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
ARBITRUM_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
ARBITRUMSEPOLIA_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>

#
LOCALHOST_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>
HARDHAT_PLUGIN_ENS_DOMAIN=<ENS-Domain example: plugin.dao.eth>

MANAGEMENT_DAO_SUBDOMAIN=<ENS-Subdomain example: "management">
MANAGEMENT_DAO_MULTISIG_APPROVERS=<list of addresses seperated by coma. example: "0x...01,0x...02">
MANAGEMENT_DAO_MULTISIG_MINAPPROVALS=<Minimum approvals. example: "1">
MANAGEMENT_DAO_MULTISIG_LISTEDONLY=<Listed Only. example: "true">

MAINNET_MANAGEMENT_DAO_MULTISIG=0x0673c13d48023efa609c20e5e351763b99dd67de
GOERLI_MANAGEMENT_DAO_MULTISIG=0x3263de63e70157c4b607982721026ffaa20e596c
SEPOLIA_MANAGEMENT_DAO_MULTISIG=0xfcEAd61339e3e73090B587968FcE8b090e0600EF
POLYGON_MANAGEMENT_DAO_MULTISIG=0x5db93850d843af581d8b87c350aa849a13a88e40
MUMBAI_MANAGEMENT_DAO_MULTISIG=0x944b067ccdbded94e64826747a5d72d4adcdf50a
BASESEPOLIA_MANAGEMENT_DAO_MULTISIG=0xBFa3Ea5Bf7C6491b7f24f2a3658fF1d9eAE11c01
BASEGOERLI_MANAGEMENT_DAO_MULTISIG=0x0deE00170c57161e629f5975F3B51b73B3770C06
BASEMAINNET_MANAGEMENT_DAO_MULTISIG=0x549B739731dFDfe256f9A3014b30035C05b6D1a6
ARBITRUM_MANAGEMENT_DAO_MULTISIG=0x02bBc496BEBC9a06C239670Cea663C43ceAd899F
ARBITRUMGOERLI_MANAGEMENT_DAO_MULTISIG=0x02bBc496BEBC9a06C239670Cea663C43ceAd899F
ARBITRUMSEPOLIA_MANAGEMENT_DAO_MULTISIG=0xfcEAd61339e3e73090B587968FcE8b090e0600EF

HARDHAT_MANAGEMENT_DAO_MULTISIG=0xe3ADd897e69010709498738e5116C06B4D81e672 # Changes with each new version

# not using this variable will disable the feature. Anything else will enable it
TEST_UPDATE_DEPLOY_SCRIPT=


### File: /home/errick/core/packages/contracts/tsconfig.json ###
{
  "compilerOptions": {
    "target": "es2018",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "outDir": "dist",
    "declaration": true,
    "moduleResolution": "node",
    "resolveJsonModule": true
  },
  "include": [
    "hardhat-zksync.config.ts",
    "./scripts",
    "./test",
    "./typechain",
    "./deploy",
    "./utils",
    "./artifacts",
    "types/hardhat.d.ts"
  ]
}


### File: /home/errick/core/packages/contracts/networks.ts ###
type NetworkExtension = {
  deploy: string[];
};

export const networkExtensions: {[index: string]: NetworkExtension} = {
  mainnet: {
    deploy: ['./deploy'],
  },
  sepolia: {
    deploy: ['./deploy'],
  },
  polygon: {
    deploy: ['./deploy'],
  },
  mumbai: {
    deploy: ['./deploy'],
  },
  baseMainnet: {
    deploy: ['./deploy'],
  },
  baseSepolia: {
    deploy: ['./deploy'],
  },
  arbitrum: {
    deploy: ['./deploy'],
  },
  arbitrumSepolia: {
    deploy: ['./deploy'],
  },
  zksyncMainnet: {
    deploy: ['./deploy'],
  },
  zksyncSepolia: {
    deploy: ['./deploy'],
  },
};


### File: /home/errick/core/packages/contracts/deployed_contracts_detailed.json ###
{
  "ManagementDAOImplementation": {
    "address": "0xa9186cf932e4e05b4606d107361Ae7b6651AF1b7",
    "blockNumber": 6049593,
    "deploymentTx": "0xae998dc65cca7ab1515843e6dbb31f21e4f38fe807c72a5f914ece15d7745a01"
  },
  "ManagementDAOProxy": {
    "address": "0x31a46feD168ECb9DE7d87E543Ba2e8DD101ad0a0",
    "blockNumber": 6049594,
    "deploymentTx": "0xa21d873add9f4267d6fd250ec52adaa5d90d5a7a9223af8133eebbcfbc499a13"
  },
  "ENSRegistry": {
    "address": "0x977E2F3aA628f7676d685A3AFe2df48c51C9949a",
    "blockNumber": 6049597,
    "deploymentTx": "0x7d6c46444c8c2483f55d2fe8dff3391daaddf19a54e314db3a4ee1f66cda228f"
  },
  "PublicResolver": {
    "address": "0x8647AC3a1270c746130418010A368449d1944A82",
    "blockNumber": 6049598,
    "deploymentTx": "0x38d3dc91ae9a15baa917ab47eb783e0687c54b567b7d42211b64b17fc63ba7fd"
  },
  "DAOENSSubdomainRegistrarImplementation": {
    "address": "0x98B0fE54Eddb752290Dd87a02402fb0728d05445",
    "blockNumber": 6049606,
    "deploymentTx": "0x213e2994a82562e5dbdb170fb866c7f800982d5e341ec6aa80af39d41e06d562"
  },
  "DAOENSSubdomainRegistrarProxy": {
    "address": "0x5BEE4b1691cBEDab1B08726f49D914d9bBC3Dd74",
    "blockNumber": 6049607,
    "deploymentTx": "0xd982714ff10f6d9a306c79e48082c352e5f1b54da525fedec2e2cc22d45ea5b3"
  },
  "PluginENSSubdomainRegistrarImplementation": {
    "address": "0x99D34Ab8f2cC1e05722345Bc3baa4E78cC6e0a14",
    "blockNumber": 6049608,
    "deploymentTx": "0x6cd287fab4dd75ea991ec6717b78363fac0bd7700737177ebf75610a227fadaf"
  },
  "PluginENSSubdomainRegistrarProxy": {
    "address": "0xe38293134297f062Eb9aB7d7CDa83733357C90c1",
    "blockNumber": 6049609,
    "deploymentTx": "0xfcdd2a5e9e1053cadf90d93fe74a20beb4275c07d68c9d5e11c94d6a213f187e"
  },
  "DAORegistryImplementation": {
    "address": "0xDF8340475A4a8490C763B88f7e88179Ec0DfaC1C",
    "blockNumber": 6049611,
    "deploymentTx": "0x8468c680db5d65adfe5868c52175a5c304aad1c6f4d469d8a72f184cc1ec07f2"
  },
  "DAORegistryProxy": {
    "address": "0x7BF3cF1176C4a037d3Ea2a5FF3d480359aC65Ecd",
    "blockNumber": 6049612,
    "deploymentTx": "0xd61b4a5df4557bfe154f85108094e7abc108c3e2fc9f24e408cdd680e85a0c5e"
  },
  "PluginRepoRegistryImplementation": {
    "address": "0xC4f7eE5ECE62e6bB53cad7a734b7539eFcbDCCbD",
    "blockNumber": 6049613,
    "deploymentTx": "0xf7b6b12ef3b0866570a4dbf5433ca2a4c8644fa9ffde82cf626d1cdae8c9750d"
  },
  "PluginRepoRegistryProxy": {
    "address": "0xC35EBbbFeB1c7C17295Ba6EB08F59cC1e54d2c7d",
    "blockNumber": 6049614,
    "deploymentTx": "0xf2ce026e50e29498288dbd2ad11927dd7e8c2eebf301fd30c0d151af966790b3"
  },
  "PluginRepoFactory": {
    "address": "0x2557627d61F85E5629b23B48d7226D0a9368D507",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  },
  "PluginRepoBase": {
    "address": "0xbDe9768478f4DcD74aD37c709c8AaE1d1339F799",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  },
  "PluginSetupProcessor": {
    "address": "0x62D1e5b65c5D345c4aA967F172f686f581c0614E",
    "blockNumber": 6049616,
    "deploymentTx": "0xafd38673baa677fb580a803013e6983846bc8eae8d27f4cbb94197128a683172"
  },
  "DAOFactory": {
    "address": "0xe390BF14A5623479E9bd0e3559D98B6fab44251F",
    "blockNumber": 6049617,
    "deploymentTx": "0x4bd45b014a05b588bcbd848197ba05fcc1923c21d9ca13c6fad53b489f84fcd2"
  },
  "DAOBase": {
    "address": "0x2f727C19D578e8Cb781aeaD6dEb3828F283F1D65",
    "blockNumber": 6049617,
    "deploymentTx": "0x4bd45b014a05b588bcbd848197ba05fcc1923c21d9ca13c6fad53b489f84fcd2"
  },
  "AddresslistVotingSetup": {
    "address": "0xaf981B8FB5429d1D64B16F98A2BDfc6cF667A08D",
    "blockNumber": 6049621,
    "deploymentTx": "0x21d9b668b6096b925a7084899d2e303987f63a9d29a77f2a1fb26158668ad574"
  },
  "AddresslistVotingSetupImplementation": {
    "address": "0xA3Db89b12604eb893b6A3AbbC6113dC667dB3630",
    "blockNumber": 6049621,
    "deploymentTx": "0x21d9b668b6096b925a7084899d2e303987f63a9d29a77f2a1fb26158668ad574"
  },
  "GovernanceERC20": {
    "address": "0x2135b360D32B17fAEE573BDE47C75e5e34bdC875",
    "blockNumber": 6049622,
    "deploymentTx": "0x8d45733f9e12d4ff18845481efe7d389837eaafc3fd2f74c48165a2c94cca57c"
  },
  "GovernanceWrappedERC20": {
    "address": "0x32A1A43203c93600555C200104D21c3584ED1A28",
    "blockNumber": 6049623,
    "deploymentTx": "0xf38510e3e8d5c3a3df4531ed7292ac02bcead4a092f55dade2abe4f54e0fe46c"
  },
  "TokenVotingSetup": {
    "address": "0x54A8E10751B030aB6a6bC508eD6d0634947774dd",
    "blockNumber": 6049624,
    "deploymentTx": "0xe940c7fc67a3820763d0080a1605bc01c030606a918fa67b21d2af7d0f2ffd08"
  },
  "TokenVotingSetupImplementation": {
    "address": "0x310cfdD99178A12147a78cC0E5efD285F6227f31",
    "blockNumber": 6049624,
    "deploymentTx": "0xe940c7fc67a3820763d0080a1605bc01c030606a918fa67b21d2af7d0f2ffd08"
  },
  "AdminSetup": {
    "address": "0x065B89D4726664BAb42EFc916c24660EAd0427DB",
    "blockNumber": 6049625,
    "deploymentTx": "0x7846bc39cbca9f96b4276b70450654e09f1a8fb04061460c92677341902727e7"
  },
  "AdminSetupImplementation": {
    "address": "0xc2246A415432de3774D794a14b699B02b6323ce2",
    "blockNumber": 6049625,
    "deploymentTx": "0x7846bc39cbca9f96b4276b70450654e09f1a8fb04061460c92677341902727e7"
  },
  "MultisigSetup": {
    "address": "0xFeA08d5ff36E99CEEb9627789d726D78D1E91B73",
    "blockNumber": 6049626,
    "deploymentTx": "0xa63f3f2be9a99981a74e686290b330ad1d2b6f8421dd54dd91934923be3e706b"
  },
  "MultisigSetupImplementation": {
    "address": "0xf4cc2F15515386743a04EF97dd0389A35203F1a4",
    "blockNumber": 6049626,
    "deploymentTx": "0xa63f3f2be9a99981a74e686290b330ad1d2b6f8421dd54dd91934923be3e706b"
  },
  "PlaceholderSetup": {
    "address": "0x60ccEaBCAaA362e90d0D75bcbEE125D43A51D191",
    "blockNumber": 6049627,
    "deploymentTx": "0x758afc83070f924a25656436106eb92947315af3b7c6a7f27b5d2aac622bfb94"
  },
  "AddressListVotingRepoProxy": {
    "address": "0x6B372Ad885C9Ae94Ac626f651347c472ad58F01e",
    "blockNumber": 6049628,
    "deploymentTx": "0xa9df78087990828e8df515b377efe9e31b12e102773cd81c1bcf98092518955a"
  },
  "AddressListVotingRepoImplementation": {
    "address": "0xbDe9768478f4DcD74aD37c709c8AaE1d1339F799",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  },
  "TokenVotingRepoProxy": {
    "address": "0x7c340b278f11F456Bb1a2AAF48d87f8D28Ee46a1",
    "blockNumber": 6049631,
    "deploymentTx": "0x8d351e692a90a3ca3e33cc4c8b9e499643483d2199203e42e8e77644842a1eca"
  },
  "TokenVotingRepoImplementation": {
    "address": "0xbDe9768478f4DcD74aD37c709c8AaE1d1339F799",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  },
  "AdminRepoProxy": {
    "address": "0x4DD52163dB9340D255b9267dc254252DB320b2c2",
    "blockNumber": 6049634,
    "deploymentTx": "0x991f9912c5791ee06e281751ed54b0e605198ac156672de1e5fafa5c29ba45fd"
  },
  "AdminRepoImplementation": {
    "address": "0xbDe9768478f4DcD74aD37c709c8AaE1d1339F799",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  },
  "MultisigRepoProxy": {
    "address": "0xf32B2C0094B9ecb7FC64C0CCB58a8bEc796055B5",
    "blockNumber": 6049636,
    "deploymentTx": "0x3c817bf37f0bf3a317380bcf8d4b8d4d0efc3f79f09ea6c909248618fc5c4fd1"
  },
  "MultisigRepoImplementation": {
    "address": "0xbDe9768478f4DcD74aD37c709c8AaE1d1339F799",
    "blockNumber": 6049615,
    "deploymentTx": "0xfffd61156da1bd2025474958a7a2632c84bccff4e536acb9b3a2b58b9db03f25"
  }
}


### File: /home/errick/core/packages/contracts/.eslintrc.js ###
module.exports = {
  env: {
    browser: false,
    es2021: true,
    mocha: true,
    node: true,
  },
  plugins: ['@typescript-eslint'],
  extends: [
    'standard',
    'plugin:prettier/recommended',
    'plugin:node/recommended',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaVersion: 12,
  },
  rules: {
    'node/no-unsupported-features/es-syntax': ['error', {ignores: ['modules']}],
  },
};


### File: /home/errick/core/packages/contracts/package.json ###
{
  "name": "@aragon/osx",
  "version": "1.4.0",
  "description": "The Aragon OSx source code",
  "private": true,
  "scripts": {
    "typechain:osx": "ts-node scripts/generate-typechain-osx.ts",
    "typechain:osx-versions": "ts-node scripts/generate-typechain-osx-versions.ts",
    "typechain": "yarn typechain:osx && yarn typechain:osx-versions",
    "test:parallel": "hardhat test --parallel",
    "test": "hardhat test",
    "test:report-gas": "REPORT_GAS=true hardhat test",
    "test:zksync": "hardhat test --config hardhat-zksync.config.ts",
    "build": "hardhat compile && yarn typechain",
    "build:zksync": "hardhat compile --config hardhat-zksync.config.ts && yarn typechain",
    "coverage": "hardhat coverage --solcoverjs ./.solcover.js",
    "flatten": "hardhat flatten",
    "analyze": "mythx analyze",
    "deploy": "hardhat deploy",
    "deploy:zksync": "hardhat deploy-contracts --config hardhat-zksync.config.ts",
    "deploy:local": "yarn deploy --network localhost --reset",
    "dev": "yarn hardhat node --hostname 0.0.0.0",
    "docgen": "hardhat docgen",
    "docs": "DOCS=true scripts/prepare-docs.sh",
    "clean": "rm -rf artifacts cache deployments typechain"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/aragon/osx"
  },
  "author": "Aragon X",
  "license": "AGPL-3.0-or-later",
  "bugs": {
    "url": "https://github.com/aragon/osx/issues"
  },
  "homepage": "https://github.com/aragon/osx#readme",
  "dependencies": {
    "@aragon/osx-commons-contracts": "1.4.0",
    "@ensdomains/ens-contracts": "0.0.11",
    "@openzeppelin/contracts": "4.9.6",
    "@openzeppelin/contracts-upgradeable": "4.9.6"
  },
  "devDependencies": {
    "@aragon/osx-commons-configs": "^0.8.0",
    "@aragon/osx-commons-sdk": "^0.1.0",
    "@aragon/osx-ethers-v1.2.0": "npm:@aragon/osx-ethers@1.2.0",
    "@aragon/osx-v1.0.1": "npm:@aragon/osx@1.0.1",
    "@aragon/osx-v1.3.0": "npm:@aragon/osx@1.3.0",
    "@defi-wonderland/smock": "^2.3.4",
    "@matterlabs/hardhat-zksync-deploy": "0.8",
    "@matterlabs/hardhat-zksync-node": "0.2.0",
    "@matterlabs/hardhat-zksync-solc": "1.2.5",
    "@matterlabs/hardhat-zksync-upgradable": "0.4.0",
    "@matterlabs/hardhat-zksync-verify": "0.7.0",
    "@matterlabs/hardhat-zksync-ethers": "0.0.1-beta.2",
    "zksync-ethers": "5.7.0",
    "@nomicfoundation/hardhat-chai-matchers": "^1.0.5",
    "@nomicfoundation/hardhat-network-helpers": "^1.0.8",
    "@nomicfoundation/hardhat-verify": "^1.0.4",
    "@nomiclabs/hardhat-ethers": "^2.2.1",
    "@openzeppelin/hardhat-upgrades": "^1.23.1",
    "@typechain/ethers-v5": "7.2.0",
    "@typechain/hardhat": "^2.3.1",
    "@types/chai": "^4.2.22",
    "@types/mocha": "^9.0.0",
    "@types/node": "^16.11.7",
    "@typescript-eslint/eslint-plugin": "^4.33.0",
    "@typescript-eslint/parser": "^4.33.0",
    "chai": "^4.3.4",
    "dotenv": "^10.0.0",
    "eslint": "^7.32.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-config-standard": "^16.0.3",
    "eslint-plugin-import": "^2.25.2",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-prettier": "^3.4.1",
    "eslint-plugin-promise": "^5.1.1",
    "ethereumjs-util": "^7.1.4",
    "ethers": "^5.7.2",
    "hardhat": "^2.22.15",
    "hardhat-deploy": "0.12.4",
    "hardhat-gas-reporter": "^1.0.4",
    "ipfs-http-client": "51.0.0",
    "solhint": "^3.3.6",
    "solidity-coverage": "^0.8.2",
    "solidity-docgen": "^0.6.0-beta.35",
    "tmp-promise": "^3.0.3",
    "ts-node": "^8.1.0",
    "typechain": "^5.2.0",
    "typescript": "^4.4.4",
    "lodash.startcase": "^4.4.0"
  }
}


### File: /home/errick/core/packages/contracts/.solhint.json ###
{
  "extends": "solhint:recommended",
  "rules": {
    "compiler-version": ["error", "^0.8.0"],
    "func-visibility": ["warn", {"ignoreConstructors": true}]
  }
}


### File: /home/errick/core/packages/contracts/.solcover.js ###
module.exports = {
  skipFiles: ['test', 'exampleplugins/counter-'],
};


### File: /home/errick/core/packages/contracts/hardhat.config.ts ###
import {networkExtensions} from './networks';
import {TestingFork} from './types/hardhat';
import {
  networks as commonNetworkConfigs,
  SupportedNetworks,
  addRpcUrlToNetwork,
} from '@aragon/osx-commons-configs';
import '@nomicfoundation/hardhat-chai-matchers';
import '@nomicfoundation/hardhat-network-helpers';
import '@nomicfoundation/hardhat-verify';
import '@openzeppelin/hardhat-upgrades';
import * as dotenv from 'dotenv';
import 'hardhat-deploy';
import 'hardhat-gas-reporter';
import {extendEnvironment, HardhatUserConfig, task} from 'hardhat/config';
import type {NetworkUserConfig} from 'hardhat/types';
import 'solidity-coverage';
import 'solidity-docgen';

dotenv.config();

const ETH_KEY = process.env.ETH_KEY;
const accounts = ETH_KEY ? ETH_KEY.split(',') : [];

// check alchemy Api key existence
if (process.env.ALCHEMY_API_KEY) {
  addRpcUrlToNetwork(process.env.ALCHEMY_API_KEY);
} else {
  //throw new Error('ALCHEMY_API_KEY in .env not set');  // حذف یا کامنت کردن
}

// add accounts to network configs
const hardhatNetworks: {[index: string]: NetworkUserConfig} =
  commonNetworkConfigs;
for (const network of Object.keys(hardhatNetworks) as SupportedNetworks[]) {
  if (network === SupportedNetworks.LOCAL) {
    continue;
  }

  if (networkExtensions[network] == undefined) {
    console.log(`WARNING: newtork ${network} is not found in networks.ts file`);
    continue;
  }

  hardhatNetworks[network].accounts = accounts;
  hardhatNetworks[network].deploy = networkExtensions[network].deploy;
}

// Extend HardhatRuntimeEnvironment
extendEnvironment(hre => {
  const testingFork: TestingFork = {
    network: '',
    osxVersion: '',
    activeContracts: {},
  };
  hre.aragonToVerifyContracts = [];
  hre.managementDAOMultisigPluginAddress = ''; // TODO This must be removed after the deploy script got refactored (see https://github.com/aragon/osx/pull/582)
  hre.managementDAOActions = [];
  hre.testingFork = testingFork;
});

const ENABLE_DEPLOY_TEST = process.env.TEST_UPDATE_DEPLOY_SCRIPT !== undefined;

console.log('Is deploy test is enabled: ', ENABLE_DEPLOY_TEST);

// Override the test task so it injects wrapper.
// Note that this also gets injected when running it through coverage.
task('test').setAction(async (args, hre, runSuper) => {
  await hre.run('compile');
  const imp = await import('./test/test-utils/wrapper');

  const wrapper = await imp.Wrapper.create(
    hre.network.name,
    hre.ethers.provider
  );
  hre.wrapper = wrapper;

  await runSuper(args);
});

// You need to export an object to set up your config
// Go to https://hardhat.org/config/ to learn more
const config: HardhatUserConfig = {
  solidity: {
    version: '0.8.20',
    settings: {
      optimizer: {
        enabled: true,
        runs: 2000,
      },
      outputSelection: {
        '*': {
          '*': ['storageLayout'],
        },
      },
    },
  },
  defaultNetwork: 'hardhat',
  networks: {
    hardhat: {
      throwOnTransactionFailures: true,
      throwOnCallFailures: true,
      blockGasLimit: 3000000000, // really high to test some things that are only possible with a higher block gas limit
      gasPrice: 80000000000,
      deploy: ENABLE_DEPLOY_TEST
        ? ['./deploy']
        : ['./deploy/env', './deploy/new', './deploy/verification'],
    },
    localhost: { // اضافه کردن تنظیمات ganache
      url: "http://172.16.22.120:9545",
      chainId: 5777,
      deploy: ENABLE_DEPLOY_TEST
          ? ['./deploy']
          : ['./deploy/env', './deploy/new', './deploy/verification'],
        accounts: accounts // اگر آدرس خصوصی دارید
    },
    ...hardhatNetworks,
  },
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
    currency: 'USD',
  },
  etherscan: {
    apiKey: {
      mainnet: process.env.ETHERSCAN_KEY || '',
      rinkeby: process.env.ETHERSCAN_KEY || '',
      goerli: process.env.ETHERSCAN_KEY || '',
      sepolia: process.env.ETHERSCAN_KEY || '',
      holesky: process.env.ETHERSCAN_KEY || '',
      polygon: process.env.POLYGONSCAN_KEY || '',
      polygonMumbai: process.env.POLYGONSCAN_KEY || '',
      baseMainnet: process.env.BASESCAN_KEY || '',
      baseGoerli: process.env.BASESCAN_KEY || '',
      baseSepolia: process.env.BASESCAN_KEY || '',
      arbitrumOne: process.env.ARBISCAN_KEY || '',
      arbitrumGoerli: process.env.ARBISCAN_KEY || '',
      arbitrumSepolia: process.env.ARBISCAN_KEY || '',
      modeTestnet: 'modeTestnet',
      modeMainnet: 'modeMainnet',
    },
    customChains: [
      {
        network: 'baseMainnet',
        chainId: 8453,
        urls: {
          apiURL: 'https://api.basescan.org/api',
          browserURL: 'https://basescan.org',
        },
      },
      {
        network: 'baseGoerli',
        chainId: 84531,
        urls: {
          apiURL: 'https://api-goerli.basescan.org/api',
          browserURL: 'https://goerli.basescan.org',
        },
      },
      {
        network: 'baseSepolia',
        chainId: 84532,
        urls: {
          apiURL: 'https://api-sepolia.basescan.org/api',
          browserURL: 'https://sepolia.arbiscan.io',
        },
      },
      {
        network: 'arbitrumSepolia',
        chainId: 421614,
        urls: {
          apiURL: 'https://api-sepolia.arbiscan.io/api',
          browserURL: 'https://sepolia.arbiscan.io',
        },
      },
      {
        network: 'holesky',
        chainId: 17000,
        urls: {
          apiURL: 'https://api-holesky.etherscan.io/api',
          browserURL: 'https://holesky.etherscan.io',
        },
      },
      {
        network: 'modeTestnet',
        chainId: 919,
        urls: {
          apiURL:
            'https://api.routescan.io/v2/network/testnet/evm/919/etherscan',
          browserURL: 'https://testnet.modescan.io',
        },
      },
      {
        network: 'modeMainnet',
        chainId: 34443,
        urls: {
          apiURL:
            'https://api.routescan.io/v2/network/mainnet/evm/34443/etherscan',
          browserURL: 'https://modescan.io',
        },
      },
    ],
  },
  namedAccounts: {
    deployer: 0,
  },
  paths: {
    sources: './src',
    tests: './test',
    cache: './cache',
    artifacts: './artifacts',
    deploy: './deploy',
  },
  docgen: process.env.DOCS ? require('./docs/config.js') : undefined,
  mocha: {
    timeout: 90_000, // 90 seconds // increase the timeout for subdomain validation tests
  },
};

export default config;

### File: /home/errick/core/packages/contracts/deploy/management-dao-metadata.json ###
{
  "name": "Aragon Management DAO",
  "description": "Aragon OSx includes a group of global smart contracts that allow for a DAO ecosystem to be built on top. These contracts will require future improvements and general maintenance. The Management DAO is intended to perform such maintenance tasks and holds the permissions to deliver any new capabilities that are added in the future.",
  "avatar": "https://ipfs.eth.aragon.network/ipfs/QmVyy3ci7F2zHG6JUJ1XbcwLKuxWrQ6hqNvSnjmDmdYJzP/",
  "links": [
    {
      "name": "Web site",
      "url": "https://www.aragon.org"
    },
    {
      "name": "Developer Portal",
      "url": "https://devs.aragon.org/"
    }
  ]
}


### File: /home/errick/core/packages/contracts/deploy/helpers.ts ###
import {VersionTag} from '../test/test-utils/psp/types';
import {
  ENSRegistry__factory,
  PluginRepoFactory__factory,
  PluginRepoRegistry__factory,
  PluginRepo__factory,
} from '../typechain';
import {VersionCreatedEvent} from '../typechain/PluginRepo';
import {PluginRepoRegisteredEvent} from '../typechain/PluginRepoRegistry';
import {isLocal, pluginDomainEnv} from '../utils/environment';
import {
  getNetworkNameByAlias,
  getLatestNetworkDeployment,
} from '@aragon/osx-commons-configs';
import {findEvent, findEventTopicLog, Operation} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {Contract} from 'ethers';
import {ethers} from 'hardhat';
import {HardhatRuntimeEnvironment} from 'hardhat/types';
import IPFS from 'ipfs-http-client';

// TODO: Add support for L2 such as Arbitrum. (https://discuss.ens.domains/t/register-using-layer-2/688)
// Make sure you own the ENS set in the {{NETWORK}}_ENS_DOMAIN variable in .env
export const ENS_ADDRESSES: {[key: string]: string} = {
  mainnet: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  goerli: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  sepolia: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
  holesky: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
};

export const ENS_PUBLIC_RESOLVERS: {[key: string]: string} = {
  goerli: '0x19c2d5d0f035563344dbb7be5fd09c8dad62b001',
  mainnet: '0x4976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41',
  sepolia: '0x8FADE66B79cC9f707aB26799354482EB93a5B7dD',
  holesky: '0x9010A27463717360cAD99CEA8bD39b8705CCA238',
};

export const DAO_PERMISSIONS = [
  'ROOT_PERMISSION',
  'UPGRADE_DAO_PERMISSION',
  'SET_SIGNATURE_VALIDATOR_PERMISSION',
  'SET_TRUSTED_FORWARDER_PERMISSION',
  'SET_METADATA_PERMISSION',
  'REGISTER_STANDARD_CALLBACK_PERMISSION',
];

export async function uploadToIPFS(
  metadata: string,
  networkName: string
): Promise<string> {
  const client = IPFS.create({
    url: 'https://prod.ipfs.aragon.network/api/v0',
    headers: {
      'X-API-KEY': 'b477RhECf8s8sdM7XrkLBs2wHc4kCMwpbcFC55Kt',
    },
  });

  if (networkName === 'hardhat' || networkName === 'localhost') {
    // return a dummy path
    return 'QmNnobxuyCjtYgsStCPhXKEiQR5cjsc3GtG9ZMTKFTTEFJ';
  }

  const res = await client.add(metadata);
  await client.pin.add(res.cid);
  console.log(`Uploaded to IPFS with cid ${res.cid.toString()}`);
  return res.cid.toString();
}

export async function getContractAddress(
  contractName: string,
  hre: HardhatRuntimeEnvironment
): Promise<string> {
  const {deployments, network} = hre;

  let networkName = network.name;

  if (hre.testingFork.network) {
    networkName = hre.testingFork.network;
  }

  try {
    const contract = await deployments.get(contractName);
    if (contract) {
      return contract.address;
    }
  } catch (e) {}

  try {
    if (!hre.testingFork.osxVersion && !hre.testingFork.activeContracts) {
      console.log('==========================');
      console.log('Warning: osxVersion is not set');
      console.log('==========================');
    }

    const activeContracts = hre.testingFork.activeContracts;

    if (activeContracts && activeContracts[networkName][contractName]) {
      return activeContracts[networkName][contractName];
    }
  } catch (e) {}

  return getLatestContractAddress(contractName, hre);
}

export function getLatestContractAddress(
  contractName: string,
  hre: HardhatRuntimeEnvironment
): string {
  let networkName = hre.network.name;

  if (hre.testingFork.network) {
    networkName = hre.testingFork.network;
  }

  const osxNetworkName = getNetworkNameByAlias(networkName);
  if (!osxNetworkName) {
    if (isLocal(hre.network)) {
      return '';
    }
    throw new Error(`Failed to find network ${networkName}`);
  }

  const latestNetworkDeployment = getLatestNetworkDeployment(osxNetworkName);
  if (latestNetworkDeployment && contractName in latestNetworkDeployment) {
    // safe cast due to conditional above, but we return the fallback string anyhow
    const key = contractName as keyof typeof latestNetworkDeployment;
    return latestNetworkDeployment[key]?.address ?? '';
  }
  return '';
}

export async function detemineDeployerNextAddress(
  index: number,
  deployer: SignerWithAddress
): Promise<string> {
  const [owner] = await ethers.getSigners();
  const nonce = await owner.getTransactionCount();
  const futureAddress = ethers.utils.getContractAddress({
    from: deployer.address,
    nonce: nonce + index,
  });
  return futureAddress;
}

export async function checkSetManagementDao(
  contract: Contract,
  expectedDaoAddress: string
) {
  const setDAO = await contract.dao();
  if (setDAO !== expectedDaoAddress) {
    throw new Error(
      `${contract.address} has wrong DAO. Expected ${setDAO} to be ${expectedDaoAddress}`
    );
  }
}

export type Permission = {
  operation: Operation;
  where: {name: string; address: string};
  who: {name: string; address: string};
  permission: string;
  condition?: string;
  data?: string;
};

export async function checkPermission(
  permissionManagerContract: Contract,
  permission: Permission
) {
  const checkStatus = await isPermissionSetCorrectly(
    permissionManagerContract,
    permission
  );
  if (!checkStatus) {
    const {who, where, operation} = permission;
    if (operation === Operation.Grant) {
      throw new Error(
        `(${who.name}: ${who.address}) doesn't have ${permission.permission} on (${where.name}: ${where.address}) in ${permissionManagerContract.address}`
      );
    }
    throw new Error(
      `(${who.name}: ${who.address}) has ${permission.permission} on (${where.name}: ${where.address}) in ${permissionManagerContract.address}`
    );
  }
}

export async function isPermissionSetCorrectly(
  permissionManagerContract: Contract,
  {operation, where, who, permission, data = '0x'}: Permission
): Promise<boolean> {
  const permissionId = ethers.utils.id(permission);
  const isGranted = await permissionManagerContract.isGranted(
    where.address,
    who.address,
    permissionId,
    data
  );
  if (!isGranted && operation === Operation.Grant) {
    return false;
  }

  if (isGranted && operation === Operation.Revoke) {
    return false;
  }
  return true;
}

export async function managePermissions(
  permissionManagerContract: Contract,
  permissions: Permission[]
): Promise<void> {
  // filtering permission to only apply those that are needed
  const items: Permission[] = [];
  for (const permission of permissions) {
    if (await isPermissionSetCorrectly(permissionManagerContract, permission)) {
      continue;
    }
    items.push(permission);
  }

  if (items.length === 0) {
    console.log(`Contract call skipped. No permissions to set...`);
    return;
  }

  console.log(
    `Setting ${items.length} permissions. Skipped ${
      permissions.length - items.length
    }`
  );
  const tx = await permissionManagerContract.applyMultiTargetPermissions(
    items.map(item => [
      item.operation,
      item.where.address,
      item.who.address,
      item.condition || ethers.constants.AddressZero,
      ethers.utils.id(item.permission),
    ])
  );
  console.log(`Set permissions with ${tx.hash}. Waiting for confirmation...`);
  await tx.wait();

  items.forEach(permission => {
    console.log(
      `${
        permission.operation === Operation.Grant ? 'Granted' : 'Revoked'
      } the ${permission.permission} of (${permission.where.name}: ${
        permission.where.address
      }) for (${permission.who.name}: ${permission.who.address}), see (tx: ${
        tx.hash
      })`
    );
  });
}

export async function isENSDomainRegistered(
  domain: string,
  ensRegistryAddress: string,
  signer: SignerWithAddress
): Promise<boolean> {
  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    signer
  );

  return ensRegistryContract.recordExists(ethers.utils.namehash(domain));
}

export async function getENSAddress(
  hre: HardhatRuntimeEnvironment
): Promise<string> {
  if (ENS_ADDRESSES[hre.network.name]) {
    return ENS_ADDRESSES[hre.network.name];
  }

  const ensDeployment = await hre.deployments.get('ENSRegistry');
  if (ensDeployment) {
    return ensDeployment.address;
  }

  throw new Error('ENS address not found.');
}

export async function getPublicResolverAddress(
  hre: HardhatRuntimeEnvironment
): Promise<string> {
  if (ENS_PUBLIC_RESOLVERS[hre.network.name]) {
    return ENS_PUBLIC_RESOLVERS[hre.network.name];
  }

  const publicResolverDeployment = await hre.deployments.get('PublicResolver');
  if (publicResolverDeployment) {
    return publicResolverDeployment.address;
  }

  throw new Error('PublicResolver address not found.');
}

export async function registerSubnodeRecord(
  domain: string,
  owner: SignerWithAddress,
  ensRegistryAddress: string,
  publicResolver: string
): Promise<string> {
  const domainSplitted = domain.split('.');
  const subdomain = domainSplitted.splice(0, 1)[0];
  const parentDomain = domainSplitted.join('.');

  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    owner
  );
  const tx = await ensRegistryContract.setSubnodeRecord(
    ethers.utils.namehash(parentDomain),
    ethers.utils.keccak256(ethers.utils.toUtf8Bytes(subdomain)),
    owner.address,
    publicResolver,
    0
  );
  await tx.wait();
  return ensRegistryContract.owner(ethers.utils.namehash(domain));
}

export async function transferSubnodeRecord(
  domain: string,
  newOwner: string,
  ensRegistryAddress: string
): Promise<void> {
  const domainSplitted = domain.split('.');
  const subdomain = domainSplitted.splice(0, 1)[0];
  const parentDomain = domainSplitted.join('.');

  const [deployer] = await ethers.getSigners();

  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    deployer
  );

  const tx = await ensRegistryContract.setSubnodeOwner(
    ethers.utils.namehash(parentDomain),
    ethers.utils.keccak256(ethers.utils.toUtf8Bytes(subdomain)),
    newOwner
  );
  console.log(
    `Transfering owner of ${domain} to ${newOwner} with tx ${tx.hash}`
  );
  await tx.wait();
}

// transfers owner ship of a domain and all parent domains to a new owner if it matches the expected current owner
export async function transferSubnodeChain(
  fullDomain: string,
  newOwner: string,
  currentOwner: string,
  ensRegistryAddress: string
): Promise<void> {
  const [deployer] = await ethers.getSigners();

  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    deployer
  );

  const daoDomainSplitted = fullDomain.split('.').reverse();
  let domain = '';
  // +1 on length because we also need to check the owner of the empty domain
  for (let i = 0; i < daoDomainSplitted.length + 1; i++) {
    const domainOwner = await ensRegistryContract.callStatic.owner(
      ethers.utils.namehash(domain)
    );
    if (domainOwner !== newOwner && domainOwner === currentOwner) {
      const tx = await ensRegistryContract.setOwner(
        ethers.utils.namehash(domain),
        newOwner
      );
      console.log(
        `Changing owner of ${domain} from (currentOwner) ${domainOwner} to ${newOwner} (newOwner)`
      );
      await tx.wait();
    }

    domain = `${daoDomainSplitted[i]}.${domain}`;
    if (i === 0) {
      domain = daoDomainSplitted[i];
    }
  }
}

export async function delay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// hh-deploy cannot process files without default exports
export default async () => {};


### File: /home/errick/core/packages/contracts/deploy/new/00_management-dao/20_set-dao-permission.ts ###
import {DAO__factory} from '../../../typechain';
import {
  DAO_PERMISSIONS,
  getContractAddress,
  managePermissions,
} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nSetting ManagementDao permissions.');
  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Set all the permission needed for a DAO to operate normally as if it was created via DAOFactory.
  const permissions = DAO_PERMISSIONS.map(permission => {
    return {
      operation: Operation.Grant,
      where: {name: 'managementDAO', address: managementDAOAddress},
      who: {name: 'managementDAO', address: managementDAOAddress},
      permission: permission,
    };
  });

  await managePermissions(managementDaoContract, permissions);
};
export default func;
func.tags = ['New', 'SetManagementDaoPermissions'];


### File: /home/errick/core/packages/contracts/deploy/new/00_management-dao/00_management-dao.ts ###
import daoArtifactJson from '../../../artifacts/src/core/dao/DAO.sol/DAO.json';
import {ArtifactData, DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

/** NOTE:
 * Create a (Management DAO) with no Plugin, to be the owner DAO for the framework, temporarily.
 */

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`\nDeploying ManagementDAO.`);

  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  console.log(
    `ManagementDAO will be owned by the (Deployer: ${deployer.address}) temporarily, while the entire framework is getting deployed.` +
      ` At the final step when Multisig is available, it will be installed on managementDAO and all roles for the Deployer will be revoked.`
  );

  const initializeParams = {
    metadata: '0x',
    initialOwner: deployer.address,
    trustedForwarder: ethers.constants.AddressZero,
    daoURI: '0x',
  };

  const daoArtifactData = daoArtifactJson as ArtifactData;

  await deploy('ManagementDAOProxy', {
    contract: daoArtifactData,
    from: deployer.address,
    args: [],
    log: true,
    proxy: {
      owner: deployer.address,
      proxyContract: 'ERC1967Proxy',
      proxyArgs: ['{implementation}', '{data}'],
      execute: {
        init: {
          methodName: 'initialize',
          args: [
            initializeParams.metadata,
            initializeParams.initialOwner,
            initializeParams.trustedForwarder,
            initializeParams.daoURI,
          ],
        },
      },
    },
  });
};
export default func;
func.tags = ['New', 'ManagementDao'];
func.dependencies = ['Env'];


### File: /home/errick/core/packages/contracts/deploy/new/00_management-dao/02_management-dao_conclude.ts ###
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding ManagementDao deployment.\n`);

  const {deployments} = hre;

  hre.aragonToVerifyContracts.push(
    await deployments.get('ManagementDAOProxy_Implementation')
  );
  hre.aragonToVerifyContracts.push(await deployments.get('ManagementDAOProxy'));
};

export default func;
func.tags = ['New', 'ManagementDao', 'ManagementDaoPermissions', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/00_management-dao/99_verify_step.ts ###
import {DAO__factory} from '../../../typechain';
import {
  checkPermission,
  DAO_PERMISSIONS,
  getContractAddress,
} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nVerifying management DAO deployment.');

  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );
  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Check that deployer has root permission.
  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
    who: {name: 'Deployer', address: deployer.address},
    permission: 'ROOT_PERMISSION',
  });

  // check that the DAO have all permissions set correctly
  for (let index = 0; index < DAO_PERMISSIONS.length; index++) {
    const permission = DAO_PERMISSIONS[index];

    await checkPermission(managementDaoContract, {
      operation: Operation.Grant,
      where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      who: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      permission: permission,
    });
  }

  console.log('Management DAO deployment verified');
};
export default func;
func.tags = ['New', 'ManagementDao', 'SetDAOPermissions'];


### File: /home/errick/core/packages/contracts/deploy/new/00_management-dao/01_management-dao-permissions.ts ###
import {DAO__factory} from '../../../typechain';
import {getContractAddress, managePermissions} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  console.log(`Granting ${deployer.address} temp execute permissions`);

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );
  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // grant the deployer execute permissions.
  await managePermissions(managementDaoContract, [
    {
      operation: Operation.Grant,
      where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'EXECUTE_PERMISSION',
    },
  ]);
};
export default func;
func.tags = ['New', 'ManagementDaoPermissions'];


### File: /home/errick/core/packages/contracts/deploy/new/40_finalize-management-dao/20_register-management-dao-on-dao-registry.ts ###
import {DAO__factory, DAORegistry__factory} from '../../../typechain';
import {ENSRegistry__factory} from '../../../typechain/factories/ENSRegistry__factory';
import {
  daoDomainEnv,
  isLocal,
  managementDaoSubdomainEnv,
} from '../../../utils/environment';
import {getContractAddress, getENSAddress, uploadToIPFS} from '../../helpers';
import MANAGEMENT_DAO_METADATA from '../../management-dao-metadata.json';
import {uploadToPinata} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers, network} = hre;
  const [deployer] = await ethers.getSigners();

  // Get info from .env
  const daoSubdomain = managementDaoSubdomainEnv(network);
  const daoDomain = daoDomainEnv(network);

  if (!daoSubdomain)
    throw new Error('ManagementDAO subdomain has not been set in .env');

  const node = ethers.utils.namehash(`${daoSubdomain}.${daoDomain}`);

  // Get `ManagementDAOProxy` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `DAORegistryProxy` contract.
  const daoRegistryContract = DAORegistry__factory.connect(
    daoRegistryAddress,
    deployer
  );

  const ensRegistryContract = ENSRegistry__factory.connect(
    await getENSAddress(hre),
    deployer
  );
  let owner = await ensRegistryContract.owner(node);

  let daoENSSubdomainRegistrar = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );

  if (
    owner != daoENSSubdomainRegistrar &&
    owner != ethers.constants.AddressZero
  ) {
    throw new Error(
      `A DAO with ${daoSubdomain}.${daoDomain} is registered and owned by 
      someone other than ENSSubdomainRegistrar ${daoENSSubdomainRegistrar}.`
    );
  }

  if (owner === ethers.constants.AddressZero) {
    // Register `managingDAO` on `DAORegistry`.
    const registerTx = await daoRegistryContract.register(
      managementDAOAddress,
      deployer.address,
      daoSubdomain
    );
    await registerTx.wait();
    console.log(
      `Registered the (managingDAO: ${managementDAOAddress}) on (DAORegistry: ${daoRegistryAddress}), see (tx: ${registerTx.hash})`
    );
  }

  // Set Metadata for the Management DAO
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  let metadataCIDPath = '0x';

  if (!isLocal(hre.network)) {
    // Upload the metadata to IPFS
    metadataCIDPath = await uploadToPinata(
      JSON.stringify(MANAGEMENT_DAO_METADATA, null, 2),
      `management-dao-metadata`
    );
  }

  const hasMetadataPermission = await managementDaoContract.hasPermission(
    managementDaoContract.address,
    deployer.address,
    ethers.utils.id('SET_METADATA_PERMISSION'),
    '0x'
  );

  if (hasMetadataPermission) {
    const setMetadataTX = await managementDaoContract.setMetadata(
      ethers.utils.hexlify(ethers.utils.toUtf8Bytes(metadataCIDPath))
    );
    await setMetadataTX.wait();
  }
};
export default func;
func.tags = ['New', 'RegisterManagementDAO'];


### File: /home/errick/core/packages/contracts/deploy/new/40_finalize-management-dao/00_grant-permissions.ts ###
import {DAO__factory, PluginRepo__factory} from '../../../typechain';
import {getContractAddress, managePermissions, Permission} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`\nFinalizing ManagementDao.`);

  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `PluginSetupProcessor` address.
  const pspAddress = await getContractAddress('PluginSetupProcessor', hre);

  // Get `ManagementDAOProxy` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  const grantPermissions = [
    {
      operation: Operation.Grant,
      where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'REGISTER_DAO_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'SET_METADATA_PERMISSION',
    },
  ];

  await managePermissions(managementDaoContract, grantPermissions);
};
export default func;
func.tags = ['New', 'RegisterManagementDAO'];


### File: /home/errick/core/packages/contracts/deploy/new/40_finalize-management-dao/99_verify_step.ts ###
import {DAO__factory} from '../../../typechain';
import {checkPermission, delay, getContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nVerifying management DAO deployment.');

  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `ManagementDAOProxy` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    (await ethers.getSigners())[0]
  );

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);
  // Get `PluginSetupProcessor` address.
  const pspAddress = await getContractAddress('PluginSetupProcessor', hre);

  // On some chains - such as holesky - wait so
  // previous permission txs are fully applied and verified.
  await delay(5000);

  // Check revoked permission.
  await checkPermission(managementDaoContract, {
    operation: Operation.Revoke,
    where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
    who: {name: 'Deployer', address: deployer.address},
    permission: 'REGISTER_DAO_PERMISSION',
  });

  await checkPermission(managementDaoContract, {
    operation: Operation.Revoke,
    where: {name: 'PluginSetupProcessor', address: pspAddress},
    who: {name: 'Deployer', address: deployer.address},
    permission: 'APPLY_INSTALLATION_PERMISSION',
  });

  await checkPermission(managementDaoContract, {
    operation: Operation.Revoke,
    where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
    who: {name: 'PluginSetupProcessor', address: pspAddress},
    permission: 'ROOT_PERMISSION',
  });

  await checkPermission(managementDaoContract, {
    operation: Operation.Revoke,
    where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
    who: {name: 'Deployer', address: deployer.address},
    permission: 'ROOT_PERMISSION',
  });

  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
    who: {name: 'Deployer', address: deployer.address},
    permission: 'EXECUTE_PERMISSION',
  });

  console.log('Finalizing Management DAO verified');
};
export default func;
func.tags = ['New', 'RegisterManagementDAO'];


### File: /home/errick/core/packages/contracts/deploy/new/40_finalize-management-dao/40_revoke-permissions.ts ###
import {DAO__factory, PluginRepo__factory} from '../../../typechain';
import {managementDaoSubdomainEnv} from '../../../utils/environment';
import {getContractAddress, managePermissions, Permission} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

// Revokes necessary permissions from deployer, but leaves EXECUTE
// permission currently on the deployer. This is useful for a deployer
// to install the plugin on managing dao at later time.
const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get info from .env
  const daoSubdomain = managementDaoSubdomainEnv(hre.network);

  if (!daoSubdomain)
    throw new Error('ManagementDAO subdomain has not been set in .env');

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `PluginSetupProcessor` address.
  const pspAddress = await getContractAddress('PluginSetupProcessor', hre);

  // Get `ManagementDAOProxy` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `ManagementDAOProxy` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Revoke `REGISTER_DAO_PERMISSION` from `Deployer`.
  // Revoke `ROOT_PERMISSION` from `Deployer`.
  // Revoke `SET_METADATA_PERMISSION` from `Deployer`.
  const revokePermissions = [
    {
      operation: Operation.Revoke,
      where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'REGISTER_DAO_PERMISSION',
    },
    {
      operation: Operation.Revoke,
      where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'ROOT_PERMISSION',
    },
    {
      operation: Operation.Revoke,
      where: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      who: {name: 'Deployer', address: deployer.address},
      permission: 'SET_METADATA_PERMISSION',
    },
  ];
  await managePermissions(managementDaoContract, revokePermissions);
};
export default func;
func.tags = ['New', 'RevokeManagementPermissionsDAO'];


### File: /home/errick/core/packages/contracts/deploy/new/20_permissions/00_ens-permissions.ts ###
import {DAO__factory} from '../../../typechain';
import {getContractAddress, managePermissions} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`\nSetting framework permission.`);

  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Get `DAORegistry` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `PluginRepoRegistry` address.
  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );

  // Get DAO's `ENSSubdomainRegistrar` address.
  const daoEnsSubdomainRegistrarAddress = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );

  // Get Plugin's `ENSSubdomainRegistrar` address.
  const pluginEnsSubdomainRegistrarAddress = await getContractAddress(
    'PluginENSSubdomainRegistrarProxy',
    hre
  );

  // Grant `REGISTER_ENS_SUBDOMAIN_PERMISSION` of `DAOENSSubdomainRegistrarProxy` to `DAORegistry`.
  // Grant `REGISTER_ENS_SUBDOMAIN_PERMISSION` of `PluginENSSubdomainRegistrarProxy` to `PluginRepoRegistry`.
  // Grant `UPGRADE_REGISTRAR_PERMISSION` of `DAOENSSubdomainRegistrarProxy` to `ManagementDAO`.
  // Grant `UPGRADE_REGISTRAR_PERMISSION` of `PluginENSSubdomainRegistrarProxy` to `ManagementDAO`.
  const grantPermissions = [
    {
      operation: Operation.Grant,
      where: {
        name: 'DAOENSSubdomainRegistrarProxy',
        address: daoEnsSubdomainRegistrarAddress,
      },
      who: {name: 'DAORegistry', address: daoRegistryAddress},
      permission: 'REGISTER_ENS_SUBDOMAIN_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {
        name: 'PluginENSSubdomainRegistrarProxy',
        address: pluginEnsSubdomainRegistrarAddress,
      },
      who: {name: 'PluginRepoRegistry', address: pluginRepoRegistryAddress},
      permission: 'REGISTER_ENS_SUBDOMAIN_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {
        name: 'DAOENSSubdomainRegistrarProxy',
        address: daoEnsSubdomainRegistrarAddress,
      },
      who: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      permission: 'UPGRADE_REGISTRAR_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {
        name: 'PluginENSSubdomainRegistrarProxy',
        address: pluginEnsSubdomainRegistrarAddress,
      },
      who: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      permission: 'UPGRADE_REGISTRAR_PERMISSION',
    },
  ];
  await managePermissions(managementDaoContract, grantPermissions);
};
export default func;
func.tags = ['New', 'ENS_Permissions'];


### File: /home/errick/core/packages/contracts/deploy/new/20_permissions/99_verify.ts ###
import {DAO__factory} from '../../../typechain';
import {checkPermission, delay, getContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nVerifying permissions');

  const {ethers} = hre;

  const [deployer] = await ethers.getSigners();

  // Get `ManagementDAOProxy` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `ManagementDAOProxy` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // On some chains - such as holesky - wait so
  // previous permission txs are fully applied and verified.
  await delay(5000);

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `PluginRepoRegistryProxy` address.
  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );

  // Get DAO's `DAOENSSubdomainRegistrarProxy` address.
  const daoEnsSubdomainRegistrarAddress = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );

  // Get Plugin's `PluginENSSubdomainRegistrarProxy` address.
  const pluginEnsSubdomainRegistrarAddress = await getContractAddress(
    'PluginENSSubdomainRegistrarProxy',
    hre
  );

  // Get `DAOFactory` address.
  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);

  // Get `PluginRepoFactory` address.
  const pluginRepoFactoryAddress = await getContractAddress(
    'PluginRepoFactory',
    hre
  );

  // ENS PERMISSIONS
  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {
      name: 'DAOENSSubdomainRegistrarProxy',
      address: daoEnsSubdomainRegistrarAddress,
    },
    who: {name: 'DAORegistryProxy', address: daoRegistryAddress},
    permission: 'REGISTER_ENS_SUBDOMAIN_PERMISSION',
  });

  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {
      name: 'PluginENSSubdomainRegistrarProxy',
      address: pluginEnsSubdomainRegistrarAddress,
    },
    who: {name: 'PluginRepoRegistryProxy', address: pluginRepoRegistryAddress},
    permission: 'REGISTER_ENS_SUBDOMAIN_PERMISSION',
  });

  // DAO REGISTRY PERMISSIONS
  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
    who: {name: 'DAOFactory', address: daoFactoryAddress},
    permission: 'REGISTER_DAO_PERMISSION',
  });

  // PLUGIN REPO REGISTRY PERMISSIONS
  await checkPermission(managementDaoContract, {
    operation: Operation.Grant,
    where: {
      name: 'PluginRepoRegistryProxy',
      address: pluginRepoRegistryAddress,
    },
    who: {name: 'PluginRepoFactory', address: pluginRepoFactoryAddress},
    permission: 'REGISTER_PLUGIN_REPO_PERMISSION',
  });

  console.log('Permissions verified');
};
export default func;
func.tags = [
  'New',
  'ENS_Permissions',
  'DAO_Registry_Permissions',
  'Plugin_Registry_Permissions',
];


### File: /home/errick/core/packages/contracts/deploy/new/20_permissions/10_dao-registry-permissions.ts ###
import {DAO__factory} from '../../../typechain';
import {getContractAddress, managePermissions} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `DAOFactory` address.
  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);

  // Grant `REGISTER_DAO_PERMISSION` of `DAORegistryProxy` to `DAOFactory`.
  // Grant `UPGRADE_REGISTRY_PERMISSION` of `DAORegistryProxy` to `ManagementDAOProxy`.
  const grantPermissions = [
    {
      operation: Operation.Grant,
      where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
      who: {name: 'DAOFactory', address: daoFactoryAddress},
      permission: 'REGISTER_DAO_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {name: 'DAORegistryProxy', address: daoRegistryAddress},
      who: {name: 'ManagementDAOProxy', address: managementDAOAddress},
      permission: 'UPGRADE_REGISTRY_PERMISSION',
    },
  ];
  await managePermissions(managementDaoContract, grantPermissions);
};
export default func;
func.tags = ['New', 'DAO_Registry_Permissions'];


### File: /home/errick/core/packages/contracts/deploy/new/20_permissions/20_plugin-registrty-permissions.ts ###
import {DAO__factory} from '../../../typechain';
import {getContractAddress, managePermissions} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get `DAO` contract.
  const managementDaoContract = DAO__factory.connect(
    managementDAOAddress,
    deployer
  );

  // Get `PluginRepoRegistryProxy` address.
  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );

  // Get `PluginRepoFactory` address.
  const pluginRepoFactoryAddress = await getContractAddress(
    'PluginRepoFactory',
    hre
  );

  // Grant `REGISTER_PLUGIN_REPO_PERMISSION` of `PluginRepoRegistryProxy` to `DAOFactory`.
  // Grant `UPGRADE_REGISTRY_PERMISSION` of `PluginRepoRegistryProxy` to `ManagementDAO`.
  const grantPermissions = [
    {
      operation: Operation.Grant,
      where: {
        name: 'PluginRepoRegistryProxy',
        address: pluginRepoRegistryAddress,
      },
      who: {name: 'PluginRepoFactory', address: pluginRepoFactoryAddress},
      permission: 'REGISTER_PLUGIN_REPO_PERMISSION',
    },
    {
      operation: Operation.Grant,
      where: {
        name: 'PluginRepoRegistryProxy',
        address: pluginRepoRegistryAddress,
      },
      who: {name: 'ManagementDAO', address: managementDAOAddress},
      permission: 'UPGRADE_REGISTRY_PERMISSION',
    },
  ];
  await managePermissions(managementDaoContract, grantPermissions);
};
export default func;
func.tags = ['New', 'Plugin_Registry_Permissions'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/21_plugin-repo-registry_conclude.ts ###
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding Plugin Repo Registry deployment.\n`);

  const {deployments} = hre;

  hre.aragonToVerifyContracts.push(
    await deployments.get('PluginRepoRegistryProxy')
  );
  hre.aragonToVerifyContracts.push({
    contract:
      'src/framework/plugin/repo/PluginRepoRegistry.sol:PluginRepoRegistry',
    ...(await deployments.get('PluginRepoRegistryProxy_Implementation')),
  });
};

export default func;
func.tags = ['New', 'PluginRepoRegistry', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/51_dao-factory-conclude.ts ###
import {DAOFactory__factory} from '../../../typechain';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding DAOFactory deployment.\n`);
  const {deployments, ethers} = hre;

  const [deployer] = await ethers.getSigners();

  const DAOFactoryDeployment = await deployments.get('DAOFactory');
  const daoFactory = DAOFactory__factory.connect(
    DAOFactoryDeployment.address,
    deployer
  );

  hre.aragonToVerifyContracts.push({
    contract: 'src/framework/dao/DAOFactory.sol:DAOFactory',
    ...DAOFactoryDeployment,
  });
  hre.aragonToVerifyContracts.push({
    contract: 'src/core/dao/DAO.sol:DAO',
    address: await daoFactory.daoBase(),
    args: [],
  });
};

export default func;
func.tags = ['New', 'DAOFactory', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/40_plugin_setup_processor.ts ###
import pluginSetupProcessorFactoryArtifact from '../../../artifacts/src/framework/plugin/setup/PluginSetupProcessor.sol/PluginSetupProcessor.json';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Get `PluginRepoRegistry` address.
  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );

  await deploy('PluginSetupProcessor', {
    contract: pluginSetupProcessorFactoryArtifact,
    from: deployer.address,
    args: [pluginRepoRegistryAddress],
    log: true,
  });
};
export default func;
func.tags = ['New', 'PluginSetupProcessor'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/50_dao-factory.ts ###
import daoFactoryArtifact from '../../../artifacts/src/framework/dao/DAOFactory.sol/DAOFactory.json';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Get `DAORegistryProxy` address.
  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);

  // Get `PluginSetupProcessor` address.
  const pluginSetupProcessorAddress = await getContractAddress(
    'PluginSetupProcessor',
    hre
  );

  await deploy('DAOFactory', {
    contract: daoFactoryArtifact,
    from: deployer.address,
    args: [daoRegistryAddress, pluginSetupProcessorAddress],
    log: true,
  });
};
export default func;
func.tags = ['New', 'DAOFactory'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/41_plugin-setup-processor_conclude.ts ###
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding Plugin Setup Processor deployment.\n`);

  const {deployments} = hre;
  hre.aragonToVerifyContracts.push(
    await deployments.get('PluginSetupProcessor')
  );
};

export default func;
func.tags = ['New', 'PluginSetupProcessor', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/30_repo-factory.ts ###
import pluginRepoFactoryArtifact from '../../../artifacts/src/framework/plugin/repo/PluginRepoFactory.sol/PluginRepoFactory.json';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Get `PluginRepoRegistry` address.
  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );

  await deploy('PluginRepoFactory', {
    contract: pluginRepoFactoryArtifact,
    from: deployer.address,
    args: [pluginRepoRegistryAddress],
    log: true,
  });
};
export default func;
func.tags = ['New', 'PluginRepoFactory'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/00_ens_registry.ts ###
import {setupENS} from '../../../utils/ens';
import {daoDomainEnv, pluginDomainEnv} from '../../../utils/environment';
import {ENS_ADDRESSES} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

// Make sure you own the ENS set in the {{NETWORK}}_ENS_DOMAIN variable in .env
const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`\nDeploying framework.`);

  const {network} = hre;

  const daoDomain = daoDomainEnv(network);
  const pluginDomain = pluginDomainEnv(network);

  const officialEnsRegistryAddress = ENS_ADDRESSES[network.name];

  if (!officialEnsRegistryAddress) {
    await setupENS([daoDomain, pluginDomain], hre);
  }
};
export default func;
func.tags = ['New', 'ENSRegistry'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/09_ens_conclude.ts ###
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding ENS deployment.\n`);

  const {deployments} = hre;

  try {
    const ensRegistry = await deployments.get('ENSRegistry');
    if (ensRegistry) {
      hre.aragonToVerifyContracts.push(ensRegistry);
    }
  } catch (e) {
    console.log(`No deployment for ENSRegistry found`);
  }

  try {
    const publicResolver = await deployments.get('PublicResolver');
    if (publicResolver) {
      hre.aragonToVerifyContracts.push(publicResolver);
    }
  } catch (e) {
    console.log(`No deployment for PublicResolver found`);
  }

  hre.aragonToVerifyContracts.push(
    await deployments.get('DAOENSSubdomainRegistrarProxy')
  );
  hre.aragonToVerifyContracts.push({
    contract:
      'src/framework/utils/ens/ENSSubdomainRegistrar.sol:ENSSubdomainRegistrar',
    ...(await deployments.get('DAOENSSubdomainRegistrarProxy_Implementation')),
  });
  hre.aragonToVerifyContracts.push(
    await deployments.get('PluginENSSubdomainRegistrarProxy')
  );
  hre.aragonToVerifyContracts.push({
    contract:
      'src/framework/utils/ens/ENSSubdomainRegistrar.sol:ENSSubdomainRegistrar',
    ...(await deployments.get(
      'PluginENSSubdomainRegistrarProxy_Implementation'
    )),
  });
};

export default func;
func.tags = [
  'New',
  'ENSRegistry',
  'ENSSubdomains',
  'ENSSubdomainRegistrars',
  'Verify',
];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/02_ens_subdomain_registrars.ts ###
import ensSubdomainRegistrarArtifact from '../../../artifacts/src/framework/utils/ens/ENSSubdomainRegistrar.sol/ENSSubdomainRegistrar.json';
import {DAO__factory, ENSRegistry__factory} from '../../../typechain';
import {daoDomainEnv, pluginDomainEnv} from '../../../utils/environment';
import {getContractAddress, getENSAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers, network} = hre;
  const {deploy} = deployments;

  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const managementDAO = DAO__factory.connect(managementDAOAddress, deployer);

  const ensRegistryAddress = await getENSAddress(hre);

  const daoDomain = daoDomainEnv(network);
  const pluginDomain = pluginDomainEnv(network);

  const daoNode = ethers.utils.namehash(daoDomain);
  const pluginNode = ethers.utils.namehash(pluginDomain);

  await deploy('DAOENSSubdomainRegistrarProxy', {
    contract: ensSubdomainRegistrarArtifact,
    from: deployer.address,
    args: [],
    log: true,
    proxy: {
      owner: deployer.address,
      proxyContract: 'ERC1967Proxy',
      proxyArgs: ['{implementation}', '{data}'],
      execute: {
        init: {
          methodName: 'initialize',
          args: [managementDAOAddress, ensRegistryAddress, daoNode],
        },
      },
    },
  });

  // Get DAO's `DAOENSSubdomainRegistrarProxy` contract.
  const daoSubdomainRegistrarAddress = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );

  await deploy('PluginENSSubdomainRegistrarProxy', {
    contract: ensSubdomainRegistrarArtifact,
    from: deployer.address,
    args: [],
    log: true,
    proxy: {
      owner: deployer.address,
      proxyContract: 'ERC1967Proxy',
      proxyArgs: ['{implementation}', '{data}'],
      execute: {
        init: {
          methodName: 'initialize',
          args: [managementDAOAddress, ensRegistryAddress, pluginNode],
        },
      },
    },
  });

  // Get the `ENSSubdomainRegistrar` proxy contract of the PluginRepoRegistry.
  const pluginSubdomainRegistrarAddress = await getContractAddress(
    'PluginENSSubdomainRegistrarProxy',
    hre
  );

  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    deployer
  );

  const daoRegistrarTX =
    await ensRegistryContract.populateTransaction.setApprovalForAll(
      daoSubdomainRegistrarAddress,
      true
    );
  const pluginRegistrarTX =
    await ensRegistryContract.populateTransaction.setApprovalForAll(
      pluginSubdomainRegistrarAddress,
      true
    );
  const deployerTX =
    await ensRegistryContract.populateTransaction.setApprovalForAll(
      deployer.address,
      true
    );

  const tx = await managementDAO.execute(
    ethers.utils.hexlify(ethers.utils.formatBytes32String('ENS_Permissions')),
    [
      {
        to: daoRegistrarTX.to || '',
        value: daoRegistrarTX.value || '0',
        data: daoRegistrarTX.data || '',
      },
      {
        to: pluginRegistrarTX.to || '',
        value: pluginRegistrarTX.value || '0',
        data: pluginRegistrarTX.data || '',
      },
      {
        to: deployerTX.to || '',
        value: deployerTX.value || '0',
        data: deployerTX.data || '',
      },
    ],
    0
  );
  console.log(`Updating controllers of ENS domains with tx ${tx.hash}`);
  await tx.wait();
};
export default func;
func.tags = ['New', 'ENSSubdomainRegistrars'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/99_verifiy_step.ts ###
import {
  DAOFactory__factory,
  DAORegistry__factory,
  ENSRegistry__factory,
  ENSSubdomainRegistrar__factory,
  PluginRepoFactory__factory,
  PluginRepoRegistry__factory,
  PluginSetupProcessor__factory,
} from '../../../typechain';
import {daoDomainEnv, pluginDomainEnv} from '../../../utils/environment';
import {checkSetManagementDao, getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nVerifying framework deployment.');

  const {ethers} = hre;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // VERIFYING DAO ENS SUBDOMAIN REGISTRAR
  const DAOENSSubdomainRegistrarAddress = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );
  const DAOENSSubdomainRegistrar = ENSSubdomainRegistrar__factory.connect(
    DAOENSSubdomainRegistrarAddress,
    deployer
  );
  await checkSetManagementDao(DAOENSSubdomainRegistrar, managementDAOAddress);
  // scope to reuse same const again
  {
    const ensAddr = await DAOENSSubdomainRegistrar.ens();
    const ensRegistryContract = ENSRegistry__factory.connect(ensAddr, deployer);
    const isApprovedForAll = await ensRegistryContract.isApprovedForAll(
      managementDAOAddress,
      DAOENSSubdomainRegistrarAddress
    );
    if (!isApprovedForAll) {
      throw new Error(
        `DAOENSSubdomainRegistrar isn't approved for all. Expected ${managementDAOAddress} to have ${DAOENSSubdomainRegistrarAddress} approved for all`
      );
    }

    const node = await DAOENSSubdomainRegistrar.node();
    const expectedNode = ethers.utils.namehash(daoDomainEnv(hre.network));
    if (node !== expectedNode) {
      throw new Error(
        `DAOENSSubdomainRegistrar node (${node}) doesn't match expected node (${expectedNode})`
      );
    }
  }

  // VERIFYING PLUGIN ENS SUBDOMAIN REGISTRAR
  const PluginENSSubdomainRegistrarAddress = await getContractAddress(
    'PluginENSSubdomainRegistrarProxy',
    hre
  );
  const PluginENSSubdomainRegistrar = ENSSubdomainRegistrar__factory.connect(
    PluginENSSubdomainRegistrarAddress,
    deployer
  );
  await checkSetManagementDao(
    PluginENSSubdomainRegistrar,
    managementDAOAddress
  );
  // scope to reuse same const again
  {
    const ensAddr = await PluginENSSubdomainRegistrar.ens();
    const ensRegistryContract = ENSRegistry__factory.connect(ensAddr, deployer);
    const isApprovedForAll = await ensRegistryContract.isApprovedForAll(
      managementDAOAddress,
      PluginENSSubdomainRegistrarAddress
    );
    if (!isApprovedForAll) {
      throw new Error(
        `PluginENSSubdomainRegistrar isn't approved for all. Expected ${managementDAOAddress} to have ${PluginENSSubdomainRegistrarAddress} approved for all`
      );
    }

    const node = await PluginENSSubdomainRegistrar.node();
    const expectedNode = ethers.utils.namehash(pluginDomainEnv(hre.network));
    if (node !== expectedNode) {
      throw new Error(
        `PluginENSSubdomainRegistrar node (${node}) doesn't match expected node (${expectedNode})`
      );
    }
  }

  // VERIFYING DAO REGISTRY
  const DAORegistryAddress = await getContractAddress('DAORegistryProxy', hre);
  const DAORegistry = DAORegistry__factory.connect(
    DAORegistryAddress,
    deployer
  );
  await checkSetManagementDao(DAORegistry, managementDAOAddress);
  // scope to reuse same const again
  {
    const SubdomainRegistrarAddress = await DAORegistry.subdomainRegistrar();
    if (SubdomainRegistrarAddress !== DAOENSSubdomainRegistrarAddress) {
      throw new Error(
        `${DAORegistry} has wrong SubdomainRegistrarAddress set. Expected ${DAOENSSubdomainRegistrarAddress} to be ${SubdomainRegistrarAddress}`
      );
    }
  }

  // VERIFYING PLUGIN REPO REGISTRY
  const PluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );
  const PluginRepoRegistry = PluginRepoRegistry__factory.connect(
    PluginRepoRegistryAddress,
    deployer
  );
  await checkSetManagementDao(PluginRepoRegistry, managementDAOAddress);
  // scope to reuse same const again
  {
    const SubdomainRegistrarAddress =
      await PluginRepoRegistry.subdomainRegistrar();
    if (SubdomainRegistrarAddress !== PluginENSSubdomainRegistrarAddress) {
      throw new Error(
        `${PluginRepoRegistry} has wrong SubdomainRegistrarAddress set. Expected ${PluginENSSubdomainRegistrarAddress} to be ${SubdomainRegistrarAddress}`
      );
    }
  }

  // VERIFYING PLUGIN REPO FACTORY
  const PluginRepoFactoryAddress = await getContractAddress(
    'PluginRepoFactory',
    hre
  );
  const PluginRepoFactory = PluginRepoFactory__factory.connect(
    PluginRepoFactoryAddress,
    deployer
  );
  // scope to reuse same const again
  {
    const SetPluginRepoRegistryAddress =
      await PluginRepoFactory.pluginRepoRegistry();
    if (SetPluginRepoRegistryAddress !== PluginRepoRegistryAddress) {
      throw new Error(
        `${PluginRepoFactoryAddress} has wrong PluginRepoRegistry set. Expected ${SetPluginRepoRegistryAddress} to be ${PluginRepoRegistryAddress}`
      );
    }
  }

  // VERIFYING PSP
  const PluginSetupProcessorAddress = await getContractAddress(
    'PluginSetupProcessor',
    hre
  );
  const PluginSetupProcessor = PluginSetupProcessor__factory.connect(
    PluginSetupProcessorAddress,
    deployer
  );
  // scope to reuse same const again
  {
    const SetPluginRepoRegistryAddress =
      await PluginSetupProcessor.repoRegistry();
    if (SetPluginRepoRegistryAddress !== PluginRepoRegistryAddress) {
      throw new Error(
        `${PluginRepoFactoryAddress} has wrong PluginRepoRegistry set. Expected ${SetPluginRepoRegistryAddress} to be ${PluginRepoRegistryAddress}`
      );
    }
  }

  // VERIFYING DAO FACTORY
  const DAOFactoryAddress = await getContractAddress('DAOFactory', hre);
  const DAOFactory = DAOFactory__factory.connect(DAOFactoryAddress, deployer);
  // scope to reuse same const again
  {
    const SetDAORegistryAddress = await DAOFactory.daoRegistry();
    if (SetDAORegistryAddress !== DAORegistryAddress) {
      throw new Error(
        `${PluginRepoFactoryAddress} has wrong DAORegistry set. Expected ${SetDAORegistryAddress} to be ${DAORegistryAddress}`
      );
    }
  }
  // scope to reuse same const again
  {
    const SetPSP = await DAOFactory.pluginSetupProcessor();
    if (SetPSP !== PluginSetupProcessorAddress) {
      throw new Error(
        `${PluginRepoFactoryAddress} has wrong PluginSetupProcessor set. Expected ${SetPSP} to be ${PluginSetupProcessorAddress}`
      );
    }
  }

  console.log('Framework deployment verified');
};
export default func;
func.tags = [
  'New',
  'ENSSubdomainRegistrar',
  'DAORegistry',
  'PluginRepoRegistry',
  'PluginRepoFactory',
  'PluginSetupProcessor',
  'DAOFactory',
];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/01_ens_subdomains.ts ###
import {ENSRegistry__factory} from '../../../typechain';
import {ENSRegistry} from '../../../typechain/ENSRegistry';
import {daoDomainEnv, pluginDomainEnv} from '../../../utils/environment';
import {
  getContractAddress,
  getENSAddress,
  getPublicResolverAddress,
  registerSubnodeRecord,
  transferSubnodeChain,
} from '../../helpers';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

async function registerAndTransferDomain(
  ensRegistryContract: ENSRegistry,
  managementDAOAddress: string,
  domain: string,
  node: string,
  deployer: SignerWithAddress,
  hre: HardhatRuntimeEnvironment,
  ethers: any
) {
  let owner = await ensRegistryContract.owner(node);

  // node hasn't been registered yet
  if (owner === ethers.constants.AddressZero) {
    owner = await registerSubnodeRecord(
      domain,
      deployer,
      await getENSAddress(hre),
      await getPublicResolverAddress(hre)
    );
  }

  if (owner !== managementDAOAddress && owner !== deployer.address) {
    throw new Error(
      `${domain} is not owned either by deployer: ${deployer.address} or management dao: ${managementDAOAddress}. 
      Check if the domain is owned by ENS wrapper and if so, unwrap it from the ENS app.`
    );
  }

  // It could be the case that domain is already owned by the management DAO which could happen
  // if the script succeeded and is re-run again. So avoid transfer which would fail otherwise.
  if (owner === deployer.address) {
    await transferSubnodeChain(
      domain,
      managementDAOAddress,
      deployer.address,
      await getENSAddress(hre)
    );
  }
}

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {ethers, network} = hre;
  const [deployer] = await ethers.getSigners();

  // Get ENS subdomains
  const daoDomain = daoDomainEnv(network);
  const pluginDomain = pluginDomainEnv(network);

  const ensRegistryAddress = await getENSAddress(hre);
  const ensRegistryContract = ENSRegistry__factory.connect(
    ensRegistryAddress,
    deployer
  );

  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Check if domains are owned by the managementDAO
  const daoNode = ethers.utils.namehash(daoDomain);
  const pluginNode = ethers.utils.namehash(pluginDomain);

  await registerAndTransferDomain(
    ensRegistryContract,
    managementDAOAddress,
    daoDomain,
    daoNode,
    deployer,
    hre,
    ethers
  );

  await registerAndTransferDomain(
    ensRegistryContract,
    managementDAOAddress,
    pluginDomain,
    pluginNode,
    deployer,
    hre,
    ethers
  );
};
export default func;
func.tags = ['New', 'ENSSubdomains'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/31_repo-factory_conclude.ts ###
import {PluginRepoFactory__factory} from '../../../typechain';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding Plugin Repo Factory deployment.\n`);

  const {deployments, ethers} = hre;
  const [deployer] = await ethers.getSigners();

  const pluginRepoFactoryDeployment = await deployments.get(
    'PluginRepoFactory'
  );
  const pluginRepoFactory = PluginRepoFactory__factory.connect(
    pluginRepoFactoryDeployment.address,
    deployer
  );

  hre.aragonToVerifyContracts.push({
    contract:
      'src/framework/plugin/repo/PluginRepoFactory.sol:PluginRepoFactory',
    ...pluginRepoFactoryDeployment,
  });
  hre.aragonToVerifyContracts.push({
    contract: 'src/framework/plugin/repo/PluginRepo.sol:PluginRepo',
    address: await pluginRepoFactory.pluginRepoBase(),
    args: [],
  });
};

export default func;
func.tags = ['New', 'PluginRepoFactory', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/52_global_executor.ts ###
import executorArtifact from '../../../artifacts/@aragon/osx-commons-contracts/src/executors/Executor.sol/Executor.json';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  await deploy('GlobalExecutor', {
    contract: executorArtifact,
    from: deployer.address,
    args: [],
    log: true,
  });

  hre.aragonToVerifyContracts.push({
    ...(await deployments.get('GlobalExecutor')),
  });
};
export default func;
func.tags = ['New', 'GlobalExecutor'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/10_dao-registry.ts ###
import daoRegistryArtifact from '../../../artifacts/src/framework/dao/DAORegistry.sol/DAORegistry.json';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get DAO's `ENSSubdomainRegistrar` contract.
  const ensSubdomainRegistrarAddress = await getContractAddress(
    'DAOENSSubdomainRegistrarProxy',
    hre
  );

  await deploy('DAORegistryProxy', {
    contract: daoRegistryArtifact,
    from: deployer.address,
    args: [],
    log: true,
    proxy: {
      owner: deployer.address,
      proxyContract: 'ERC1967Proxy',
      proxyArgs: ['{implementation}', '{data}'],
      execute: {
        init: {
          methodName: 'initialize',
          args: [managementDAOAddress, ensSubdomainRegistrarAddress],
        },
      },
    },
  });
};
export default func;
func.tags = ['New', 'DAORegistry'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/11_dao-registry_conclude.ts ###
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log(`Concluding DAO Registry deployment.\n`);

  const {deployments} = hre;

  hre.aragonToVerifyContracts.push(await deployments.get('DAORegistryProxy'));
  hre.aragonToVerifyContracts.push({
    contract: 'src/framework/dao/DAORegistry.sol:DAORegistry',
    ...(await deployments.get('DAORegistryProxy_Implementation')),
  });
};

export default func;
func.tags = ['New', 'DAORegistry', 'Verify'];


### File: /home/errick/core/packages/contracts/deploy/new/10_framework/20_plugin-repo-registry.ts ###
import pluginRepoRegistryArtifact from '../../../artifacts/src/framework/plugin/repo/PluginRepoRegistry.sol/PluginRepoRegistry.json';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Get `managementDAO` address.
  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );

  // Get DAO's `ENSSubdomainRegistrar` address.
  const ensSubdomainRegistrarAddress = await getContractAddress(
    'PluginENSSubdomainRegistrarProxy',
    hre
  );

  await deploy('PluginRepoRegistryProxy', {
    contract: pluginRepoRegistryArtifact,
    from: deployer.address,
    args: [],
    log: true,
    proxy: {
      owner: deployer.address,
      proxyContract: 'ERC1967Proxy',
      proxyArgs: ['{implementation}', '{data}'],
      execute: {
        init: {
          methodName: 'initialize',
          args: [managementDAOAddress, ensSubdomainRegistrarAddress],
        },
      },
    },
  });
};
export default func;
// func.runAtTheEnd = true;
func.tags = ['New', 'PluginRepoRegistry'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.3.0/21_PluginRepoFactory_conclude.ts ###
import {PluginRepoFactory__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nConcluding PluginRepoFactory update');
  const {deployments, ethers} = hre;
  const [deployer] = await ethers.getSigners();

  const pluginRepoFactoryAddress = await getContractAddress(
    'PluginRepoFactory',
    hre
  );
  const pluginRepoFactory = PluginRepoFactory__factory.connect(
    pluginRepoFactoryAddress,
    deployer
  );
  const pluginRepoBase = await pluginRepoFactory.callStatic.pluginRepoBase();

  hre.aragonToVerifyContracts.push(await deployments.get('PluginRepoFactory'));
  hre.aragonToVerifyContracts.push({
    address: pluginRepoBase,
    args: [],
  });
};
export default func;
func.tags = ['PluginRepoFactory', 'Verify', 'v1.3.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.3.0/11_DAOFactory_conclude.ts ###
import {DAOFactory__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nConcluding DAOFactory update');
  const {deployments, ethers} = hre;
  const [deployer] = await ethers.getSigners();

  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);
  const daoFactory = DAOFactory__factory.connect(daoFactoryAddress, deployer);
  const daoBase = await daoFactory.callStatic.daoBase();

  hre.aragonToVerifyContracts.push(await deployments.get('DAOFactory'));
  hre.aragonToVerifyContracts.push({
    address: daoBase,
    args: [],
  });
};
export default func;
func.tags = ['DAOFactory', 'Verify', 'v1.3.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.3.0/10_DAOFactory.ts ###
import daoFactoryArtifact from '../../../artifacts/src/framework/dao/DAOFactory.sol/DAOFactory.json';
import {DAO__factory} from '../../../typechain';
import {getLatestContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpdating DAOFactory');
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const managementDAOAddress = getLatestContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const pluginSetupProcessorAddress = getLatestContractAddress(
    'PluginSetupProcessor',
    hre
  );
  const daoRegistryAddress = getLatestContractAddress('DAORegistryProxy', hre);
  const previousDAOFactoryAddress = getLatestContractAddress('DAOFactory', hre);
  console.log(`Using managementDAO ${managementDAOAddress}`);
  console.log(`Using PluginSetupProcessor ${pluginSetupProcessorAddress}`);
  console.log(`Using DAORegistry ${daoRegistryAddress}`);
  console.log(`Using PreviousDAOFactory ${previousDAOFactoryAddress}`);

  const deployResult = await deploy('DAOFactory', {
    contract: daoFactoryArtifact,
    from: deployer.address,
    args: [daoRegistryAddress, pluginSetupProcessorAddress],
    log: true,
  });

  const daoInterface = DAO__factory.createInterface();
  const calldata = daoInterface.encodeFunctionData(
    'applyMultiTargetPermissions',
    [
      [
        {
          who: previousDAOFactoryAddress,
          where: daoRegistryAddress,
          operation: Operation.Revoke,
          permissionId: ethers.utils.id('REGISTER_DAO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
        {
          who: deployResult.address,
          where: daoRegistryAddress,
          operation: Operation.Grant,
          permissionId: ethers.utils.id('REGISTER_DAO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
      ],
    ]
  );
  // update permissions actions
  hre.managementDAOActions.push({
    to: managementDAOAddress,
    value: 0,
    data: calldata,
    description: `Moves the <strong>REGISTER_DAO_PERMISSION_ID</strong> permission on the <strong>DAORegistry</strong> (<code>${daoRegistryAddress}</code>) from the old <strong>DAOFactory</strong> (<code>${previousDAOFactoryAddress}</code>) to the new <strong>DAOFactory</strong> (<code>${deployResult.address}</code>).`,
  });
};
export default func;
func.tags = ['DAOFactory', 'v1.3.0'];
func.dependencies = ['Env'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.3.0/20_PluginRepoFactory.ts ###
import pluginRepoFactoryArtifact from '../../../artifacts/src/framework/plugin/repo/PluginRepoFactory.sol/PluginRepoFactory.json';
import {PluginRepo__factory} from '../../../typechain';
import {getLatestContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpdating PluginRepoFactory');
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const managementDAOAddress = getLatestContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const pluginRepoRegistryAddress = getLatestContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );
  const previousPluginRepoFactoryAddress = getLatestContractAddress(
    'PluginRepoFactory',
    hre
  );
  console.log(`Using managementDAO ${managementDAOAddress}`);
  console.log(`Using PluginRepoRegistry ${pluginRepoRegistryAddress}`);
  console.log(
    `Using PreviousPluginRepoFactory ${previousPluginRepoFactoryAddress}`
  );

  const deployResult = await deploy('PluginRepoFactory', {
    contract: pluginRepoFactoryArtifact,
    from: deployer.address,
    args: [pluginRepoRegistryAddress],
    log: true,
  });

  const pluginRepoInterface = PluginRepo__factory.createInterface();
  const calldata = pluginRepoInterface.encodeFunctionData(
    'applyMultiTargetPermissions',
    [
      [
        {
          who: previousPluginRepoFactoryAddress,
          where: pluginRepoRegistryAddress,
          operation: Operation.Revoke,
          permissionId: ethers.utils.id('REGISTER_PLUGIN_REPO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
        {
          who: deployResult.address,
          where: pluginRepoRegistryAddress,
          operation: Operation.Grant,
          permissionId: ethers.utils.id('REGISTER_PLUGIN_REPO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
      ],
    ]
  );
  // update permissions actions
  hre.managementDAOActions.push({
    to: managementDAOAddress,
    value: 0,
    data: calldata,
    description: `Moves the <strong>REGISTER_PLUGIN_REPO_PERMISSION</strong> permission on the <strong>PluginRepoRegistry</strong> (<code>${pluginRepoRegistryAddress}</code>) from the old <strong>PluginRepoFactory</strong> (<code>${previousPluginRepoFactoryAddress}</code>) to the new <strong>PluginRepoFactory</strong> (<code>${deployResult.address}</code>).`,
  });
};
export default func;
func.tags = ['PluginRepoFactory', 'v1.3.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.3.0/90_ManagingDAO.ts ###
import {DAOFactory__factory, DAO__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {IMPLICIT_INITIAL_PROTOCOL_VERSION} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpgrade the management DAO to new Implementation');

  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);
  const newDaoImplementation = await DAOFactory__factory.connect(
    daoFactoryAddress,
    hre.ethers.provider
  ).daoBase();

  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const managementDAO = DAO__factory.connect(
    managementDAOAddress,
    hre.ethers.provider
  );
  const upgradeTX = await managementDAO.populateTransaction.upgradeToAndCall(
    newDaoImplementation,
    managementDAO.interface.encodeFunctionData('initializeFrom', [
      IMPLICIT_INITIAL_PROTOCOL_VERSION,
      [],
    ])
  );

  if (!upgradeTX.to || !upgradeTX.data) {
    throw new Error(`Failed to populate upgradeToAndCall transaction`);
  }
  hre.managementDAOActions.push({
    to: upgradeTX.to,
    data: upgradeTX.data,
    value: 0,
    description: `Upgrade the <strong>management DAO</strong> (<code>${managementDAOAddress}</code>) to the new <strong>implementation</strong> (<code>${newDaoImplementation}</code>).`,
  });
};
export default func;
func.tags = ['ManagementDAO', 'v1.3.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/41_PluginRepoRegistry.ts ###
import pluginRepoRegistryArtifact from '../../../artifacts/src/framework/plugin/repo/PluginRepoRegistry.sol/PluginRepoRegistry.json';
import {
  DAOFactory__factory,
  DAORegistry__factory,
  DAO__factory,
  PluginRepoRegistry__factory,
} from '../../../typechain';
import {DAORegistry} from '../../../typechain/@aragon/osx-v1.0.1/framework/dao/DAORegistry.sol';
import {getContractAddress} from '../../helpers';
import {getProtocolVersion} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpgrade the pluginRepoRegistry to new Implementation');

  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const pluginRepoRegistryAddress = await getContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );
  const pluginRepoRegistry = PluginRepoRegistry__factory.connect(
    pluginRepoRegistryAddress,
    hre.ethers.provider
  );

  const result = await deploy('PluginRepoRegistryImplementation', {
    contract: pluginRepoRegistryArtifact,
    from: deployer.address,
    args: [],
    log: true,
  });

  const upgradeTX = await pluginRepoRegistry.populateTransaction.upgradeTo(
    result.address
  );

  if (!upgradeTX.to || !upgradeTX.data) {
    throw new Error(`Failed to populate upgradeToAndCall transaction`);
  }

  hre.aragonToVerifyContracts.push({
    address: result.address,
    args: [],
  });

  hre.managementDAOActions.push({
    to: upgradeTX.to,
    data: upgradeTX.data,
    value: 0,
    description: `Upgrade the <strong>PluginRepoRegistry </strong> (<code>${pluginRepoRegistryAddress}</code>) to the new <strong>implementation</strong> (<code>${result.address}</code>).`,
  });
};
export default func;
func.tags = ['PluginRepoRegistry', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/21_PluginRepoFactory_conclude.ts ###
import {PluginRepoFactory__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nConcluding PluginRepoFactory update');
  const {deployments, ethers} = hre;
  const [deployer] = await ethers.getSigners();

  const pluginRepoFactoryAddress = await getContractAddress(
    'PluginRepoFactory',
    hre
  );
  const pluginRepoFactory = PluginRepoFactory__factory.connect(
    pluginRepoFactoryAddress,
    deployer
  );
  const pluginRepoBase = await pluginRepoFactory.callStatic.pluginRepoBase();

  hre.aragonToVerifyContracts.push(await deployments.get('PluginRepoFactory'));
  hre.aragonToVerifyContracts.push({
    address: pluginRepoBase,
    args: [],
  });
};
export default func;
func.tags = ['PluginRepoFactory', 'Verify', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/11_DAOFactory_conclude.ts ###
import {DAOFactory__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nConcluding DAOFactory update');
  const {deployments, ethers} = hre;
  const [deployer] = await ethers.getSigners();

  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);
  const daoFactory = DAOFactory__factory.connect(daoFactoryAddress, deployer);
  const daoBase = await daoFactory.callStatic.daoBase();

  hre.aragonToVerifyContracts.push(await deployments.get('DAOFactory'));
  hre.aragonToVerifyContracts.push({
    address: daoBase,
    args: [],
  });
};
export default func;
func.tags = ['DAOFactory', 'Verify', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/10_DAOFactory.ts ###
import daoFactoryArtifact from '../../../artifacts/src/framework/dao/DAOFactory.sol/DAOFactory.json';
import {DAO__factory} from '../../../typechain';
import {getLatestContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpdating DAOFactory');
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const managementDAOAddress = getLatestContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const pluginSetupProcessorAddress = getLatestContractAddress(
    'PluginSetupProcessor',
    hre
  );

  const daoRegistryAddress = getLatestContractAddress('DAORegistryProxy', hre);
  console.log(`Using managementDAO ${managementDAOAddress}`);
  console.log(`Using PluginSetupProcessor ${pluginSetupProcessorAddress}`);
  console.log(`Using DAORegistry ${daoRegistryAddress}`);

  const deployResult = await deploy('DAOFactory', {
    contract: daoFactoryArtifact,
    from: deployer.address,
    args: [daoRegistryAddress, pluginSetupProcessorAddress],
    log: true,
  });

  const daoInterface = DAO__factory.createInterface();
  const calldata = daoInterface.encodeFunctionData(
    'applyMultiTargetPermissions',
    [
      [
        {
          who: deployResult.address,
          where: daoRegistryAddress,
          operation: Operation.Grant,
          permissionId: ethers.utils.id('REGISTER_DAO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
      ],
    ]
  );
  // update permissions actions
  hre.managementDAOActions.push({
    to: managementDAOAddress,
    value: 0,
    data: calldata,
    description: `Grant the <strong>REGISTER_DAO_PERMISSION_ID</strong> permission on the <strong>DAORegistry</strong> (<code>${daoRegistryAddress}</code>) to the new <strong>DAOFactory</strong> (<code>${deployResult.address}</code>).`,
  });
};
export default func;
func.tags = ['DAOFactory', 'v1.4.0'];
func.dependencies = ['Env'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/20_PluginRepoFactory.ts ###
import pluginRepoFactoryArtifact from '../../../artifacts/src/framework/plugin/repo/PluginRepoFactory.sol/PluginRepoFactory.json';
import {PluginRepo__factory} from '../../../typechain';
import {getLatestContractAddress} from '../../helpers';
import {Operation} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpdating PluginRepoFactory');
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const managementDAOAddress = getLatestContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const pluginRepoRegistryAddress = getLatestContractAddress(
    'PluginRepoRegistryProxy',
    hre
  );
  const previousPluginRepoFactoryAddress = getLatestContractAddress(
    'PluginRepoFactory',
    hre
  );
  console.log(`Using managementDAO ${managementDAOAddress}`);
  console.log(`Using PluginRepoRegistry ${pluginRepoRegistryAddress}`);
  console.log(
    `Using PreviousPluginRepoFactory ${previousPluginRepoFactoryAddress}`
  );

  const deployResult = await deploy('PluginRepoFactory', {
    contract: pluginRepoFactoryArtifact,
    from: deployer.address,
    args: [pluginRepoRegistryAddress],
    log: true,
  });

  const pluginRepoInterface = PluginRepo__factory.createInterface();
  const calldata = pluginRepoInterface.encodeFunctionData(
    'applyMultiTargetPermissions',
    [
      [
        {
          who: previousPluginRepoFactoryAddress,
          where: pluginRepoRegistryAddress,
          operation: Operation.Revoke,
          permissionId: ethers.utils.id('REGISTER_PLUGIN_REPO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
        {
          who: deployResult.address,
          where: pluginRepoRegistryAddress,
          operation: Operation.Grant,
          permissionId: ethers.utils.id('REGISTER_PLUGIN_REPO_PERMISSION'),
          condition: ethers.constants.AddressZero,
        },
      ],
    ]
  );
  // update permissions actions
  hre.managementDAOActions.push({
    to: managementDAOAddress,
    value: 0,
    data: calldata,
    description: `Moves the <strong>REGISTER_PLUGIN_REPO_PERMISSION</strong> permission on the <strong>PluginRepoRegistry</strong> (<code>${pluginRepoRegistryAddress}</code>) from the old <strong>PluginRepoFactory</strong> (<code>${previousPluginRepoFactoryAddress}</code>) to the new <strong>PluginRepoFactory</strong> (<code>${deployResult.address}</code>).`,
  });
};
export default func;
func.tags = ['PluginRepoFactory', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/31_DAORegistry.ts ###
import daoRegistryArtifact from '../../../artifacts/src/framework/dao/DAORegistry.sol/DAORegistry.json';
import {
  DAOFactory__factory,
  DAORegistry__factory,
  DAO__factory,
} from '../../../typechain';
import {DAORegistry} from '../../../typechain/@aragon/osx-v1.0.1/framework/dao/DAORegistry.sol';
import {getContractAddress} from '../../helpers';
import {getProtocolVersion} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpgrade the DAORegistry to new Implementation');

  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  const daoRegistryAddress = await getContractAddress('DAORegistryProxy', hre);
  const daoRegistry = DAORegistry__factory.connect(
    daoRegistryAddress,
    hre.ethers.provider
  );

  const result = await deploy('DAORegistryImplementation', {
    contract: daoRegistryArtifact,
    from: deployer.address,
    args: [],
    log: true,
  });

  const upgradeTX = await daoRegistry.populateTransaction.upgradeTo(
    result.address
  );

  if (!upgradeTX.to || !upgradeTX.data) {
    throw new Error(`Failed to populate upgradeToAndCall transaction`);
  }

  hre.aragonToVerifyContracts.push({
    address: result.address,
    args: [],
  });

  hre.managementDAOActions.push({
    to: upgradeTX.to,
    data: upgradeTX.data,
    value: 0,
    description: `Upgrade the <strong>DaoRegistry </strong> (<code>${daoRegistryAddress}</code>) to the new <strong>implementation</strong> (<code>${result.address}</code>).`,
  });
};
export default func;
func.tags = ['DAORegistry', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/update/to_v1.4.0/90_ManagingDAO.ts ###
import {DAOFactory__factory, DAO__factory} from '../../../typechain';
import {getContractAddress} from '../../helpers';
import {getProtocolVersion} from '@aragon/osx-commons-sdk';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nUpgrade the management DAO to new Implementation');

  const daoFactoryAddress = await getContractAddress('DAOFactory', hre);
  const newDaoImplementation = await DAOFactory__factory.connect(
    daoFactoryAddress,
    hre.ethers.provider
  ).daoBase();

  const managementDAOAddress = await getContractAddress(
    'ManagementDAOProxy',
    hre
  );
  const managementDAO = DAO__factory.connect(
    managementDAOAddress,
    hre.ethers.provider
  );

  const upgradeTX = await managementDAO.populateTransaction.upgradeToAndCall(
    newDaoImplementation,
    managementDAO.interface.encodeFunctionData('initializeFrom', [
      await getProtocolVersion(managementDAO),
      [],
    ])
  );

  if (!upgradeTX.to || !upgradeTX.data) {
    throw new Error(`Failed to populate upgradeToAndCall transaction`);
  }
  hre.managementDAOActions.push({
    to: upgradeTX.to,
    data: upgradeTX.data,
    value: 0,
    description: `Upgrade the <strong>management DAO</strong> (<code>${managementDAOAddress}</code>) to the new <strong>implementation</strong> (<code>${newDaoImplementation}</code>).`,
  });
};
export default func;
func.tags = ['ManagementDAO', 'v1.4.0'];


### File: /home/errick/core/packages/contracts/deploy/verification/99_conclude/10_verify-contracts.ts ###
import {isLocal} from '../../../utils/environment';
import {verifyContract} from '../../../utils/etherscan';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

function delay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nVerifying contracts');

  for (let index = 0; index < hre.aragonToVerifyContracts.length; index++) {
    const element = hre.aragonToVerifyContracts[index];

    console.log(
      `Verifying address ${element.address} with constructor argument ${element.args}.`
    );
    await verifyContract(element.address, element.args || [], element.contract);

    // Etherscan Max rate limit is 1/5s,
    // use 6s just to be safe.
    console.log(
      `Delaying 6s, so we dont reach Etherscan's Max rate limit of 1/5s.`
    );
    await delay(6000);
  }
};
export default func;
func.tags = ['New', 'Verify', 'VerifyEnd'];
func.runAtTheEnd = true;
func.skip = (hre: HardhatRuntimeEnvironment) =>
  Promise.resolve(isLocal(hre.network));


### File: /home/errick/core/packages/contracts/deploy/verification/99_conclude/00_save-contract-addresses.ts ###
import {promises as fs} from 'fs';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nPrinting deployed contracts.');
  const {deployments, aragonPluginRepos} = hre;

  const deployedContracts = await deployments.all();
  const deployedContractAddresses: {[index: string]: string} = {};

  for (const deployment in deployedContracts) {
    // skip proxies because they are included twice
    if (!deployment.endsWith('_Proxy')) {
      switch (deployment) {
        case 'ManagementDAOProxy':
          deployedContractAddresses['ManagementDAOProxy'] =
            deployedContracts[deployment].address;
          console.log(
            `Management DAO: ${deployedContracts[deployment].address}`
          );
          break;
        case 'ManagementDAOProxy_Implementation':
          deployedContractAddresses['ManagementDAOProxyImplementation'] =
            deployedContracts[deployment].address;
          console.log(
            `Management DAO Implementation: ${deployedContracts[deployment].address}`
          );
          break;
        default:
          deployedContractAddresses[deployment] =
            deployedContracts[deployment].address;
          console.log(
            `${deployment}: ${deployedContracts[deployment].address}`
          );
      }
    }
  }

  for (const pluginRepo in aragonPluginRepos) {
    deployedContractAddresses[pluginRepo] = aragonPluginRepos[pluginRepo];
    console.log(`${pluginRepo}: ${aragonPluginRepos[pluginRepo]}`);
  }

  const storeInfo = {
    deployedContractAddresses,
    managementDAOActions: hre.managementDAOActions,
  };

  await fs.writeFile('deployed_contracts.json', JSON.stringify(storeInfo));
};
export default func;
func.tags = ['New', 'Conclude', 'ConcludeEnd'];
func.runAtTheEnd = true;


### File: /home/errick/core/packages/contracts/deploy/env/00-env-check.ts ###
import {
  daoDomainEnv,
  ethKeyEnv,
  managementDaoMultisigApproversEnv,
  managementDaoMultisigListedOnlyEnv,
  managementDaoMultisigMinApprovalsEnv,
  managementDaoSubdomainEnv,
  pluginDomainEnv,
} from '../../utils/environment';
import {DeployFunction} from 'hardhat-deploy/types';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

/**
 * Pre-deployment check for required environment variables
 * Although fetching these variables throws during execution, it's nicer
 * to fail early and provide a more descriptive error message and avoid submitting
 * redundant transactions.
 */
const func: DeployFunction = async function (hre: HardhatRuntimeEnvironment) {
  console.log('\nChecking Required Env Vars');

  const {network} = hre;

  // fetch env values: in localhost or hardhat network, these have defaults
  const daoDomain = daoDomainEnv(network);
  const pluginDomain = pluginDomainEnv(network);
  const managementDaoSubdomain = managementDaoSubdomainEnv(network);
  const managementDaoMultisigApprovers =
    managementDaoMultisigApproversEnv(network);
  const managementDaoMultisigMinApprovals =
    managementDaoMultisigMinApprovalsEnv(network);
  const managementDaoMultisigListedOnly =
    managementDaoMultisigListedOnlyEnv(network);
  const ethKey = ethKeyEnv(network);

  // technically redundant as the above functions throw if the env var is missing
  if (
    !daoDomain ||
    !pluginDomain ||
    !managementDaoSubdomain ||
    !managementDaoMultisigApprovers ||
    !managementDaoMultisigMinApprovals ||
    !managementDaoMultisigListedOnly ||
    !ethKey
  ) {
    throw new Error('Missing required env vars');
  }

  console.log('✅ All required env vars are set');
};
export default func;
// set the dependencies of other functions to `Env` to ensure this check runs first
func.tags = ['Env'];


### File: /home/errick/core/packages/contracts/utils/zksync-rich-accounts.ts ###
export default [
  // Rich accounts with pre-funded balances for the chain on port 8545.
  // These accounts are used for testing purposes and have sufficient funds.
  '0x3d3cbc973389cb26f657686445bcc75662b415b656078503592ac8c1abb8810e',
  '0x509ca2e9e6acf0ba086477910950125e698d4ea70fa6f63e000c5a22bda9361c',
  '0x71781d3a358e7a65150e894264ccc594993fbc0ea12d69508a340bc1d4f5bfbc',
  '0x379d31d4a7031ead87397f332aab69ef5cd843ba3898249ca1046633c0c7eefe',
  '0x105de4e75fe465d075e1daae5647a02e3aad54b8d23cf1f70ba382b9f9bee839',
  '0x7becc4a46e0c3b512d380ca73a4c868f790d1055a7698f38fb3ca2b2ac97efbb',
  '0xe0415469c10f3b1142ce0262497fe5c7a0795f0cbfd466a6bfa31968d0f70841',
  '0x4d91647d0a8429ac4433c83254fb9625332693c848e578062fe96362f32bfe91',
  '0x41c9f9518aa07b50cb1c0cc160d45547f57638dd824a8d85b5eb3bf99ed2bdeb',
  '0xb0680d66303a0163a19294f1ef8c95cd69a9d7902a4aca99c05f3e134e68a11a',
  // Additional accounts to ensure ethers.getSigners() returns 20 addresses.
  // zkSync only returns 10 accounts by default, which may break tests
  // that expect more. Adding these extra accounts prevents the need
  // to rewrite tests by maintaining a consistent 20 accounts.
  // ethers.getSigners() still return 20 addresses instead of 10.
  '0xec4822aa037f555ba18304bfcb6e30f3c981e730f57e7bad174312868952af90',
  '0x00058bfe32cbfe46e81a7c60178fae13078068b5a3a8e1441d47f7cb96665286',
  '0x4e0e42d531f61e25f12d64504ec5f021ead984c406fb5df97d27d813d11222a3',
  '0x9534dcb0f1e8c94c8c936b39d8a5667169df34d80966d13fe7ab9ef0c78c704a',
  '0xe6c08ed153863f48ccb843b6ba82e4880cd30a0874309a291d214a3a7d794499',
  '0x247411619389bbc301816f8928c568115c7e340daf950e241f447bcb68644f92',
  '0xaff4231bc7ef2141fe25aea9d957114064a778a1aeb54276ea8b6576b958d30f',
  '0x7c81899f9d699ce7eeea50ce47fbcf2bd84ae5d7d1b6eb01cd9eedd73eac13ee',
  '0xab5f8bf24c10790972c3a25c78e7ae070619d07c93dd189f86ccac67e82da837',
  '0x23d60e6c95faf5d242edeaed780868fb55f85556764dcc11082dd40d9a2ffd3f',
];


### File: /home/errick/core/packages/contracts/utils/ens.ts ###
import ensRegistryArtifact from '../artifacts/@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol/ENSRegistry.json';
import publicResolverArtifact from '../artifacts/@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol/PublicResolver.json';
import {ENSRegistry__factory} from '../typechain';
import {ethers} from 'hardhat';
import {HardhatRuntimeEnvironment} from 'hardhat/types';

export function ensLabelHash(label: string): string {
  return ethers.utils.id(label);
}

export function ensDomainHash(name: string): string {
  return ethers.utils.namehash(name);
}

export async function setupENS(
  domains: string[],
  hre: HardhatRuntimeEnvironment
): Promise<any> {
  const {deployments, ethers} = hre;
  const {deploy} = deployments;
  const [deployer] = await ethers.getSigners();

  // Deploy the ENSRegistry
  await deploy('ENSRegistry', {
    contract: ensRegistryArtifact,
    from: deployer.address,
    args: [],
    log: true,
  });

  const ensDeployment = await deployments.get('ENSRegistry');
  const ens = ENSRegistry__factory.connect(ensDeployment.address, deployer);

  // Deploy the Resolver
  await deploy('PublicResolver', {
    contract: publicResolverArtifact,
    from: deployer.address,
    args: [ensDeployment.address, ethers.constants.AddressZero],
  });

  const resolver = await deployments.get('PublicResolver');

  for (let i = 0; i < domains.length; i++) {
    console.log(`Registering subdomain ${domains[i]}`);

    const resolvedResolver = await ens.resolver(ensDomainHash(domains[i]));
    if (resolvedResolver === resolver.address) {
      console.log(`${domains[i]} already registered. Skipping...`);
      continue;
    }

    // Register subdomains in the reverse order
    let domainNamesReversed = domains[i].split('.');
    domainNamesReversed.push(''); //add the root domain
    domainNamesReversed = domainNamesReversed.reverse();

    for (let i = 0; i < domainNamesReversed.length - 1; i++) {
      // to support subdomains
      const domain = domainNamesReversed
        .map((value, index) => (index <= i ? value : ''))
        .filter(value => value !== '')
        .reverse()
        .join('.');

      // skipping if it is already set
      const resolvedResolver = await ens.resolver(
        ensDomainHash(
          `${domainNamesReversed[i + 1]}${domain ? '.' + domain : ''}`
        )
      );
      if (resolvedResolver !== ethers.constants.AddressZero) {
        continue;
      }

      const tx = await ens.setSubnodeRecord(
        ensDomainHash(domain),
        ensLabelHash(domainNamesReversed[i + 1]),
        deployer.address,
        resolver.address,
        0
      );
      await tx.wait();
    }

    console.log(`Registered subdomain ${domains[i]}`);
  }

  console.log(`ENS Setup complete!`);

  return ens;
}


### File: /home/errick/core/packages/contracts/utils/environment.ts ###
import {HARDHAT_NETWORK_NAME} from 'hardhat/plugins';
import {Network} from 'hardhat/types';

export const isLocal = (network: Network): boolean =>
  [HARDHAT_NETWORK_NAME, 'localhost', 'coverage', 'zkLocalTestnet'].includes(
    network.name
  );

// known hardhat accounts and private keys unlocked by default in the HH node
export const HARDHAT_ACCOUNTS: Array<{KEY: string; ADDRESS: string}> = [
  {
    KEY: '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
    ADDRESS: '0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266',
  },
  {
    KEY: '0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d',
    ADDRESS: '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
  },
] as const;

/**
 * Provides default values for environment variables if running in local
 * else requires that the environment variables are set
 * @param network The hardhat network object.
 * @param name The name of the environment variable.
 * @param defaultValue The fallback value to be used if not set and in development mode.
 * @returns The value of the environment variable, or a fallback if possible.
 */
export function env(
  network: Network,
  name: string,
  defaultValue: string
): string {
  const value = process.env[name];
  if (!isLocal(network) && !value) {
    throw new Error(`Missing env var: ${name}`);
  }
  return process.env[name] || defaultValue;
}

/// Specific environment variables with hardcoded defaults in local environments

export const daoDomainEnv = (network: Network): string =>
  env(network, `${network.name.toUpperCase()}_DAO_ENS_DOMAIN`, 'dao.eth');

export const pluginDomainEnv = (network: Network): string =>
  env(
    network,
    `${network.name.toUpperCase()}_PLUGIN_ENS_DOMAIN`,
    'plugin.dao.eth'
  );

export const managementDaoSubdomainEnv = (network: Network): string =>
  env(network, 'MANAGEMENT_DAO_SUBDOMAIN', 'management');

export const managementDaoMultisigApproversEnv = (network: Network): string =>
  env(
    network,
    'MANAGEMENT_DAO_MULTISIG_APPROVERS',
    HARDHAT_ACCOUNTS[0].ADDRESS
  );

export const managementDaoMultisigMinApprovalsEnv = (
  network: Network
): string => env(network, 'MANAGEMENT_DAO_MULTISIG_MINAPPROVALS', '1');

export const managementDaoMultisigListedOnlyEnv = (network: Network): string =>
  env(network, 'MANAGEMENT_DAO_MULTISIG_LISTEDONLY', 'true');

export const ethKeyEnv = (network: Network): string =>
  env(network, 'ETH_KEY', HARDHAT_ACCOUNTS[1].KEY);


### File: /home/errick/core/packages/contracts/utils/psp.ts ###
import {defaultAbiCoder, keccak256} from 'ethers/lib/utils';

export function hashHelpers(helpers: string[]) {
  return keccak256(defaultAbiCoder.encode(['address[]'], [helpers]));
}


### File: /home/errick/core/packages/contracts/utils/etherscan.ts ###
import {networkExtensions} from '../networks';
import fs from 'fs';
import HRE from 'hardhat';
import {file} from 'tmp-promise';

function delay(ms: number) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export const verifyContract = async (
  address: string,
  constructorArguments: any[],
  contract?: string
) => {
  const currentNetwork = HRE.network.name;

  if (!Object.keys(networkExtensions).includes(currentNetwork)) {
    throw Error(
      `Current network ${currentNetwork} not supported. Please change to one of the next networks: ${Object.keys(
        networkExtensions
      ).join(',')}`
    );
  }

  try {
    const msDelay = 500; // minimum dely between tasks
    const times = 2; // number of retries

    // Write a temporal file to host complex parameters for hardhat-etherscan https://github.com/nomiclabs/hardhat/tree/master/packages/hardhat-etherscan#complex-arguments
    const {fd, path, cleanup} = await file({
      prefix: 'verify-params-',
      postfix: '.js',
    });
    fs.writeSync(
      fd,
      `module.exports = ${JSON.stringify([...constructorArguments])};`
    );

    const params = {
      contract,
      address,
      constructorArgs: path,
    };
    await runTaskWithRetry('verify', params, times, msDelay, cleanup);
  } catch (error) {
    console.warn(`Verify task error: ${error}`);
  }
};

export const runTaskWithRetry = async (
  task: string,
  params: any,
  times: number,
  msDelay: number,
  cleanup: () => void
) => {
  let counter = times;
  await delay(msDelay);

  try {
    if (times) {
      await HRE.run(task, params);
      cleanup();
    } else {
      cleanup();
      console.error(
        'Errors after all the retries, check the logs for more information.'
      );
    }
  } catch (error: any) {
    counter--;
    // This is not the ideal check, but it's all that's possible for now https://github.com/nomiclabs/hardhat/issues/1301
    if (!/already verified/i.test(error.message)) {
      console.log(`Retrying attemps: ${counter}.`);
      console.error(error.message);
      await runTaskWithRetry(task, params, counter, msDelay, cleanup);
    }
  }
};


### File: /home/errick/core/packages/contracts/utils/zksync.ts ###
export const ZK_SYNC_NETWORKS = [
  'zksyncMainnet',
  'zkLocalTestnet',
  'zksyncSepolia',
];


### File: /home/errick/core/packages/contracts/utils/storage.ts ###
import {defaultAbiCoder} from 'ethers/lib/utils';
import {ethers} from 'hardhat';

// See https://eips.ethereum.org/EIPS/eip-1967
export const ERC1967_IMPLEMENTATION_SLOT =
  '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc'; // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)

export const OZ_INITIALIZED_SLOT_POSITION = 0;

export async function readStorage(
  contractAddress: string,
  location: number | string,
  types: string[]
): Promise<string> {
  return ethers.provider
    .getStorageAt(contractAddress, location)
    .then(encoded => defaultAbiCoder.decode(types, encoded)[0]);
}


### File: /home/errick/core/packages/contracts/src/.npmignore ###
test/

### File: /home/errick/core/packages/contracts/src/package.json ###
{
  "name": "@aragon/osx",
  "version": "1.4.0",
  "description": "The Aragon OSx Solidity contracts",
  "publishConfig": {
    "access": "public"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/aragon/osx.git"
  },
  "author": "",
  "license": "AGPL-3.0-or-later",
  "bugs": {
    "url": "https://github.com/aragon/osx/issues"
  },
  "homepage": "https://github.com/aragon/osx#readme",
  "dependencies": {
    "@aragon/osx-commons-contracts": "1.4.0",
    "@ensdomains/ens-contracts": "0.0.11",
    "@openzeppelin/contracts": "4.9.6",
    "@openzeppelin/contracts-upgradeable": "4.9.6"
  }
}


### File: /home/errick/core/packages/contracts/src/core/README.adoc ###
== Core Contracts API

The natspec generated API for the core contracts. You can also find the contracts on the following link:https://github.com/aragon/osx[repository].

== Core

{{DAO}}

{{IDAO}}

{{PermissionManager}}

{{CallbackHandler}}

### File: /home/errick/core/packages/contracts/src/core/permission/PermissionManager.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";

import {IPermissionCondition} from "@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol";
import {PermissionCondition} from "@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol";
import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";

/// @title PermissionManager
/// @author Aragon X - 2021-2023
/// @notice The abstract permission manager used in a DAO, its associated plugins, and other framework-related components.
/// @custom:security-contact sirt@aragon.org
abstract contract PermissionManager is Initializable {
    using AddressUpgradeable for address;

    /// @notice The ID of the permission required to call the `grant`, `grantWithCondition`, `revoke`, and `bulk` function.
    bytes32 public constant ROOT_PERMISSION_ID = keccak256("ROOT_PERMISSION");

    /// @notice A special address encoding permissions that are valid for any address `who` or `where`.
    address internal constant ANY_ADDR = address(type(uint160).max);

    /// @notice A special address encoding if a permissions is not set and therefore not allowed.
    address internal constant UNSET_FLAG = address(0);

    /// @notice A special address encoding if a permission is allowed.
    address internal constant ALLOW_FLAG = address(2);

    /// @notice A mapping storing permissions as hashes (i.e., `permissionHash(where, who, permissionId)`) and their status encoded by an address (unset, allowed, or redirecting to a `PermissionCondition`).
    mapping(bytes32 => address) internal permissionsHashed;

    /// @notice Thrown if a call is unauthorized.
    /// @param where The context in which the authorization reverted.
    /// @param who The address (EOA or contract) missing the permission.
    /// @param permissionId The permission identifier.
    error Unauthorized(address where, address who, bytes32 permissionId);

    /// @notice Thrown if a permission has been already granted with a different condition.
    /// @dev This makes sure that condition on the same permission can not be overwriten by a different condition.
    /// @param where The address of the target contract to grant `_who` permission to.
    /// @param who The address (EOA or contract) to which the permission has already been granted.
    /// @param permissionId The permission identifier.
    /// @param currentCondition The current condition set for permissionId.
    /// @param newCondition The new condition it tries to set for permissionId.
    error PermissionAlreadyGrantedForDifferentCondition(
        address where,
        address who,
        bytes32 permissionId,
        address currentCondition,
        address newCondition
    );

    /// @notice Thrown if a condition address is not a contract.
    /// @param condition The address that is not a contract.
    error ConditionNotAContract(IPermissionCondition condition);

    /// @notice Thrown if a condition contract does not support the `IPermissionCondition` interface.
    /// @param condition The address that is not a contract.
    error ConditionInterfaceNotSupported(IPermissionCondition condition);

    /// @notice Thrown for `ROOT_PERMISSION_ID` or `EXECUTE_PERMISSION_ID` permission grants where `who` or `where` is `ANY_ADDR`.
    error PermissionsForAnyAddressDisallowed();

    /// @notice Thrown for permission grants where `who` and `where` are both `ANY_ADDR`.
    error AnyAddressDisallowedForWhoAndWhere();

    /// @notice Thrown if `Operation.GrantWithCondition` is requested as an operation but the method does not support it.
    error GrantWithConditionNotSupported();

    /// @notice Emitted when a permission `permission` is granted in the context `here` to the address `_who` for the contract `_where`.
    /// @param permissionId The permission identifier.
    /// @param here The address of the context in which the permission is granted.
    /// @param where The address of the target contract for which `_who` receives permission.
    /// @param who The address (EOA or contract) receiving the permission.
    /// @param condition The address `ALLOW_FLAG` for regular permissions or, alternatively, the `IPermissionCondition` contract implementation to be used.
    event Granted(
        bytes32 indexed permissionId,
        address indexed here,
        address where,
        address indexed who,
        address condition
    );

    /// @notice Emitted when a permission `permission` is revoked in the context `here` from the address `_who` for the contract `_where`.
    /// @param permissionId The permission identifier.
    /// @param here The address of the context in which the permission is revoked.
    /// @param where The address of the target contract for which `_who` loses permission.
    /// @param who The address (EOA or contract) losing the permission.
    event Revoked(
        bytes32 indexed permissionId,
        address indexed here,
        address where,
        address indexed who
    );

    /// @notice A modifier to make functions on inheriting contracts authorized. Permissions to call the function are checked through this permission manager.
    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.
    modifier auth(bytes32 _permissionId) {
        _auth(_permissionId);
        _;
    }

    /// @notice Initialization method to set the initial owner of the permission manager.
    /// @dev The initial owner is granted the `ROOT_PERMISSION_ID` permission.
    /// @param _initialOwner The initial owner of the permission manager.
    function __PermissionManager_init(address _initialOwner) internal onlyInitializing {
        _initializePermissionManager({_initialOwner: _initialOwner});
    }

    /// @notice Grants permission to an address to call methods in a contract guarded by an auth modifier with the specified permission identifier.
    /// @dev Requires the `ROOT_PERMISSION_ID` permission.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) receiving the permission.
    /// @param _permissionId The permission identifier.
    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.
    function grant(
        address _where,
        address _who,
        bytes32 _permissionId
    ) external virtual auth(ROOT_PERMISSION_ID) {
        _grant({_where: _where, _who: _who, _permissionId: _permissionId});
    }

    /// @notice Grants permission to an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier if the referenced condition permits it.
    /// @dev Requires the `ROOT_PERMISSION_ID` permission
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) receiving the permission.
    /// @param _permissionId The permission identifier.
    /// @param _condition The `PermissionCondition` that will be asked for authorization on calls connected to the specified permission identifier.
    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.
    function grantWithCondition(
        address _where,
        address _who,
        bytes32 _permissionId,
        IPermissionCondition _condition
    ) external virtual auth(ROOT_PERMISSION_ID) {
        _grantWithCondition({
            _where: _where,
            _who: _who,
            _permissionId: _permissionId,
            _condition: _condition
        });
    }

    /// @notice Revokes permission from an address to call methods in a target contract guarded by an auth modifier with the specified permission identifier.
    /// @dev Requires the `ROOT_PERMISSION_ID` permission.
    /// @param _where The address of the target contract for which `_who` loses permission.
    /// @param _who The address (EOA or contract) losing the permission.
    /// @param _permissionId The permission identifier.
    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that exist in parallel.
    function revoke(
        address _where,
        address _who,
        bytes32 _permissionId
    ) external virtual auth(ROOT_PERMISSION_ID) {
        _revoke({_where: _where, _who: _who, _permissionId: _permissionId});
    }

    /// @notice Applies an array of permission operations on a single target contracts `_where`.
    /// @param _where The address of the single target contract.
    /// @param items The array of single-targeted permission operations to apply.
    function applySingleTargetPermissions(
        address _where,
        PermissionLib.SingleTargetPermission[] calldata items
    ) external virtual auth(ROOT_PERMISSION_ID) {
        for (uint256 i; i < items.length; ) {
            PermissionLib.SingleTargetPermission memory item = items[i];

            if (item.operation == PermissionLib.Operation.Grant) {
                _grant({_where: _where, _who: item.who, _permissionId: item.permissionId});
            } else if (item.operation == PermissionLib.Operation.Revoke) {
                _revoke({_where: _where, _who: item.who, _permissionId: item.permissionId});
            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {
                revert GrantWithConditionNotSupported();
            }

            unchecked {
                ++i;
            }
        }
    }

    /// @notice Applies an array of permission operations on multiple target contracts `items[i].where`.
    /// @param _items The array of multi-targeted permission operations to apply.
    function applyMultiTargetPermissions(
        PermissionLib.MultiTargetPermission[] calldata _items
    ) external virtual auth(ROOT_PERMISSION_ID) {
        for (uint256 i; i < _items.length; ) {
            PermissionLib.MultiTargetPermission memory item = _items[i];

            if (item.operation == PermissionLib.Operation.Grant) {
                // Ensure a non-zero condition isn't passed, as `_grant` can't handle conditions.
                // This avoids the false impression that a conditional grant occurred,
                // since the transaction would still succeed without conditions.
                if (item.condition != address(0)) {
                    revert GrantWithConditionNotSupported();
                }
                _grant({_where: item.where, _who: item.who, _permissionId: item.permissionId});
            } else if (item.operation == PermissionLib.Operation.Revoke) {
                _revoke({_where: item.where, _who: item.who, _permissionId: item.permissionId});
            } else if (item.operation == PermissionLib.Operation.GrantWithCondition) {
                _grantWithCondition({
                    _where: item.where,
                    _who: item.who,
                    _permissionId: item.permissionId,
                    _condition: IPermissionCondition(item.condition)
                });
            }

            unchecked {
                ++i;
            }
        }
    }

    /// @notice Checks if the caller address has permission on the target contract via a permission identifier and relays the answer to a condition contract if this was declared during the granting process.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) for which the permission is checked.
    /// @param _permissionId The permission identifier.
    /// @param _data Optional data to be passed to the set `PermissionCondition`.
    /// @return Returns true if `_who` has the permissions on the target contract via the specified permission identifier.
    function isGranted(
        address _where,
        address _who,
        bytes32 _permissionId,
        bytes memory _data
    ) public view virtual returns (bool) {
        // Specific caller (`_who`) and target (`_where`) permission check
        {
            // This permission may have been granted directly via the `grant` function or with a condition via the `grantWithCondition` function.
            address specificCallerTargetPermission = permissionsHashed[
                permissionHash({_where: _where, _who: _who, _permissionId: _permissionId})
            ];

            // If the permission was granted directly, return `true`.
            if (specificCallerTargetPermission == ALLOW_FLAG) return true;

            // If the permission was granted with a condition, check the condition and return the result.
            if (specificCallerTargetPermission != UNSET_FLAG) {
                return
                    _checkCondition({
                        _condition: specificCallerTargetPermission,
                        _where: _where,
                        _who: _who,
                        _permissionId: _permissionId,
                        _data: _data
                    });
            }

            // If this permission is not set, continue.
        }

        // Generic caller (`_who: ANY_ADDR`)
        {
            address genericCallerPermission = permissionsHashed[
                permissionHash({_where: _where, _who: ANY_ADDR, _permissionId: _permissionId})
            ];

            // If the permission was granted directly to (`_who: ANY_ADDR`), return `true`.
            if (genericCallerPermission == ALLOW_FLAG) return true;

            // If the permission was granted with a condition, check the condition and return the result.
            if (genericCallerPermission != UNSET_FLAG) {
                return
                    _checkCondition({
                        _condition: genericCallerPermission,
                        _where: _where,
                        _who: _who,
                        _permissionId: _permissionId,
                        _data: _data
                    });
            }
            // If this permission is not set, continue.
        }

        // Generic target (`_where: ANY_ADDR`) condition check
        {
            // This permission can only be granted in conjunction with a condition via the `grantWithCondition` function.
            address genericTargetPermission = permissionsHashed[
                permissionHash({_where: ANY_ADDR, _who: _who, _permissionId: _permissionId})
            ];

            // If the permission was granted with a condition, check the condition and return the result.
            if (genericTargetPermission != UNSET_FLAG) {
                return
                    _checkCondition({
                        _condition: genericTargetPermission,
                        _where: _where,
                        _who: _who,
                        _permissionId: _permissionId,
                        _data: _data
                    });
            }
            // If this permission is not set, continue.
        }

        // No specific or generic permission applies to the `_who`, `_where`, `_permissionId`, so we return `false`.
        return false;
    }

    /// @notice Relays the question if caller address has permission on target contract via a permission identifier to a condition contract.
    /// @notice Checks a condition contract by doing an external call via try/catch.
    /// @param _condition The condition contract that is called.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) owning the permission.
    /// @param _permissionId The permission identifier.
    /// @param _data Optional data to be passed to a referenced `PermissionCondition`.
    /// @return Returns `true` if a caller (`_who`) has the permissions on the contract (`_where`) via the specified permission identifier.
    /// @dev If the external call fails, we return `false`.
    function _checkCondition(
        address _condition,
        address _where,
        address _who,
        bytes32 _permissionId,
        bytes memory _data
    ) internal view virtual returns (bool) {
        // Try-catch to skip failures
        try
            IPermissionCondition(_condition).isGranted({
                _where: _where,
                _who: _who,
                _permissionId: _permissionId,
                _data: _data
            })
        returns (bool result) {
            if (result) {
                return true;
            }
        } catch {}
        return false;
    }

    /// @notice Grants the `ROOT_PERMISSION_ID` permission to the initial owner during initialization of the permission manager.
    /// @param _initialOwner The initial owner of the permission manager.
    function _initializePermissionManager(address _initialOwner) internal {
        _grant({_where: address(this), _who: _initialOwner, _permissionId: ROOT_PERMISSION_ID});
    }

    /// @notice This method is used in the external `grant` method of the permission manager.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) owning the permission.
    /// @param _permissionId The permission identifier.
    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.
    function _grant(address _where, address _who, bytes32 _permissionId) internal virtual {
        if (_where == ANY_ADDR) {
            revert PermissionsForAnyAddressDisallowed();
        }

        if (_who == ANY_ADDR) {
            if (
                _permissionId == ROOT_PERMISSION_ID ||
                isPermissionRestrictedForAnyAddr(_permissionId)
            ) {
                revert PermissionsForAnyAddressDisallowed();
            }
        }

        bytes32 permHash = permissionHash({
            _where: _where,
            _who: _who,
            _permissionId: _permissionId
        });

        address currentFlag = permissionsHashed[permHash];

        // Means permHash is not currently set.
        if (currentFlag == UNSET_FLAG) {
            permissionsHashed[permHash] = ALLOW_FLAG;

            emit Granted({
                permissionId: _permissionId,
                here: msg.sender,
                where: _where,
                who: _who,
                condition: ALLOW_FLAG
            });
        }
    }

    /// @notice This method is used in the external `grantWithCondition` method of the permission manager.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) owning the permission.
    /// @param _permissionId The permission identifier.
    /// @param _condition An address either resolving to a `PermissionCondition` contract address or being the `ALLOW_FLAG` address (`address(2)`).
    /// @dev Note, that granting permissions with `_who` or `_where` equal to `ANY_ADDR` does not replace other permissions with specific `_who` and `_where` addresses that exist in parallel.
    function _grantWithCondition(
        address _where,
        address _who,
        bytes32 _permissionId,
        IPermissionCondition _condition
    ) internal virtual {
        address conditionAddr = address(_condition);

        if (!conditionAddr.isContract()) {
            revert ConditionNotAContract(_condition);
        }

        if (
            !PermissionCondition(conditionAddr).supportsInterface(
                type(IPermissionCondition).interfaceId
            )
        ) {
            revert ConditionInterfaceNotSupported(_condition);
        }

        if (_where == ANY_ADDR && _who == ANY_ADDR) {
            revert AnyAddressDisallowedForWhoAndWhere();
        }

        if (_where == ANY_ADDR || _who == ANY_ADDR) {
            if (
                _permissionId == ROOT_PERMISSION_ID ||
                isPermissionRestrictedForAnyAddr(_permissionId)
            ) {
                revert PermissionsForAnyAddressDisallowed();
            }
        }

        bytes32 permHash = permissionHash({
            _where: _where,
            _who: _who,
            _permissionId: _permissionId
        });

        address currentCondition = permissionsHashed[permHash];

        // Means permHash is not currently set.
        if (currentCondition == UNSET_FLAG) {
            permissionsHashed[permHash] = conditionAddr;

            emit Granted({
                permissionId: _permissionId,
                here: msg.sender,
                where: _where,
                who: _who,
                condition: conditionAddr
            });
        } else if (currentCondition != conditionAddr) {
            // Revert if `permHash` is already granted, but uses a different condition.
            // If we don't revert, we either should:
            //   - allow overriding the condition on the same permission
            //     which could be confusing whoever granted the same permission first
            //   - or do nothing and succeed silently which could be confusing for the caller.
            revert PermissionAlreadyGrantedForDifferentCondition({
                where: _where,
                who: _who,
                permissionId: _permissionId,
                currentCondition: currentCondition,
                newCondition: conditionAddr
            });
        }
    }

    /// @notice This method is used in the public `revoke` method of the permission manager.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) owning the permission.
    /// @param _permissionId The permission identifier.
    /// @dev Note, that revoking permissions with `_who` or `_where` equal to `ANY_ADDR` does not revoke other permissions with specific `_who` and `_where` addresses that might have been granted in parallel.
    function _revoke(address _where, address _who, bytes32 _permissionId) internal virtual {
        bytes32 permHash = permissionHash({
            _where: _where,
            _who: _who,
            _permissionId: _permissionId
        });
        if (permissionsHashed[permHash] != UNSET_FLAG) {
            permissionsHashed[permHash] = UNSET_FLAG;

            emit Revoked({permissionId: _permissionId, here: msg.sender, where: _where, who: _who});
        }
    }

    /// @notice A private function to be used to check permissions on the permission manager contract (`address(this)`) itself.
    /// @param _permissionId The permission identifier required to call the method this modifier is applied to.
    function _auth(bytes32 _permissionId) internal view virtual {
        if (!isGranted(address(this), msg.sender, _permissionId, msg.data)) {
            revert Unauthorized({
                where: address(this),
                who: msg.sender,
                permissionId: _permissionId
            });
        }
    }

    /// @notice Generates the hash for the `permissionsHashed` mapping obtained from the word "PERMISSION", the contract address, the address owning the permission, and the permission identifier.
    /// @param _where The address of the target contract for which `_who` receives permission.
    /// @param _who The address (EOA or contract) owning the permission.
    /// @param _permissionId The permission identifier.
    /// @return The permission hash.
    function permissionHash(
        address _where,
        address _who,
        bytes32 _permissionId
    ) internal pure virtual returns (bytes32) {
        return keccak256(abi.encodePacked("PERMISSION", _who, _where, _permissionId));
    }

    /// @notice Decides if the granting permissionId is restricted when `_who == ANY_ADDR` or `_where == ANY_ADDR`.
    /// @param _permissionId The permission identifier.
    /// @return Whether or not the permission is restricted.
    /// @dev By default, every permission is unrestricted and it is the derived contract's responsibility to override it. Note, that the `ROOT_PERMISSION_ID` is included and not required to be set it again.
    function isPermissionRestrictedForAnyAddr(
        bytes32 _permissionId
    ) internal view virtual returns (bool) {
        (_permissionId); // silence the warning.
        return false;
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[49] private __gap;
}


### File: /home/errick/core/packages/contracts/src/core/permission/AccControl.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./CustomHash.sol"; // اتصال به تابع هش اختصاصی

/**
 * @title AccControl
 * @dev مدیریت نقش‌ها، نودهای DAO و Validatorها در شبکه DAO-VC
 */
contract AccControl is Ownable {
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش
    
    // تعریف نقش‌های مختلف برای اعضا
    enum Role { Investor, Developer, Auditor, DAO, Validator }
    
    // نگاشت برای ارتباط آدرس اعضا با نقش‌هایشان
    mapping(address => Role) public memberRoles;
    
    // نگاشت برای شناسایی نودهای DAO
    mapping(address => bool) public daoNodes;
    
    // نگاشت برای شناسایی Validatorها
    mapping(address => bool) public validators;
    address[] public validatorAddresses; // لیست آدرس‌های Validatorها
    
    // نگاشت برای نگهداری هش Validatorها
    mapping(address => bytes32) public validatorHashes;

    // رویدادها برای ثبت تغییرات در قرارداد
    event MemberAdded(address indexed member, Role role);
    event MemberRemoved(address indexed member);
    event ValidatorAdded(address indexed validator, bytes32 hash);
    event ValidatorRemoved(address indexed validator);
    event DAONodeAdded(address indexed dao);
    event DAONodeRemoved(address indexed dao);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param hasherAddress آدرس قرارداد تابع هش
     */
    constructor(address initialOwner, address hasherAddress) Ownable(initialOwner) {
        hasher = CustomHash(hasherAddress); // تنظیم آدرس قرارداد تابع هش
    }

    /**
     * @dev افزودن عضو جدید به قرارداد
     * @param member آدرس عضو جدید
     * @param role نقش عضو جدید
     */
    function addMember(address member, Role role) external onlyOwner {
        require(role != Role.DAO && role != Role.Validator, "Use specific functions for DAO/Validator");
        require(memberRoles[member] == Role(0), "Member already exists");
        memberRoles[member] = role;
        emit MemberAdded(member, role);
    }

    /**
     * @dev حذف عضو موجود از قرارداد
     * @param member آدرس عضو
     */
    function removeMember(address member) external onlyOwner {
        require(memberRoles[member] != Role(0), "Member does not exist");
        delete memberRoles[member];
        emit MemberRemoved(member);
    }

    /**
     * @dev دریافت نقش یک عضو
     * @param member آدرس عضو
     * @return نقش عضو
     */
    function getRole(address member) external view returns (Role) {
        return memberRoles[member];
    }

    /**
     * @dev افزودن نود جدید به DAO
     * @param daoNode آدرس نود DAO جدید
     */
    function addDAONode(address daoNode) external onlyOwner {
        require(!daoNodes[daoNode], "DAO node already exists");
        daoNodes[daoNode] = true;
        memberRoles[daoNode] = Role.DAO;
        emit DAONodeAdded(daoNode);
    }

    /**
     * @dev حذف نود موجود از DAO
     * @param daoNode آدرس نود DAO
     */
    function removeDAONode(address daoNode) external onlyOwner {
        require(daoNodes[daoNode], "DAO node does not exist");
        daoNodes[daoNode] = false;
        delete memberRoles[daoNode];
        emit DAONodeRemoved(daoNode);
    }

    /**
     * @dev افزودن Validator جدید
     * @param validator آدرس Validator جدید
     */
    function addValidator(address validator) external {
        require(daoNodes[msg.sender], "Only DAO nodes can add validators");
        require(!validators[validator], "Validator already exists");
        
        bytes32 hash = hasher.customHash(abi.encodePacked(validator), blockhash(block.number - 1));
        validators[validator] = true;
        validatorHashes[validator] = hash;
        validatorAddresses.push(validator); // افزودن به لیست آدرس‌های Validatorها
        memberRoles[validator] = Role.Validator;
        emit ValidatorAdded(validator, hash);
    }

    /**
     * @dev حذف Validator موجود
     * @param validator آدرس Validator
     */
    function removeValidator(address validator) external {
        require(daoNodes[msg.sender], "Only DAO nodes can remove validators");
        require(validators[validator], "Validator does not exist");
        validators[validator] = false;
        delete memberRoles[validator];
        delete validatorHashes[validator];
        // حذف آدرس Validator از لیست
        for (uint256 i = 0; i < validatorAddresses.length; i++) {
            if (validatorAddresses[i] == validator) {
                validatorAddresses[i] = validatorAddresses[validatorAddresses.length - 1];
                validatorAddresses.pop();
                break;
            }
        }
        emit ValidatorRemoved(validator);
    }

    /**
     * @dev بررسی اینکه آیا یک آدرس نود DAO است یا خیر
     * @param daoNode آدرس نود DAO
     * @return نتیجه بررسی
     */
    function isDAONode(address daoNode) external view returns (bool) {
        return daoNodes[daoNode];
    }

    /**
     * @dev بررسی اینکه آیا یک آدرس Validator است یا خیر
     * @param validator آدرس Validator
     * @return نتیجه بررسی
     */
    function isValidator(address validator) external view returns (bool) {
        return validators[validator];
    }

    /**
     * @dev دریافت تعداد کل اعتبارسنج‌ها
     * @return تعداد اعتبارسنج‌ها
     */
    function validatorCount() external view returns (uint256) {
        return validatorAddresses.length;
    }
}

### File: /home/errick/core/packages/contracts/src/core/utils/CallbackHandler.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @title CallbackHandler
/// @author Aragon X - 2022-2023
/// @notice This contract handles callbacks by registering a magic number together with the callback function's selector. It provides the `_handleCallback` function that inheriting contracts have to call inside their `fallback()` function  (`_handleCallback(msg.callbackSelector, msg.data)`).  This allows to adaptively register ERC standards (e.g., [ERC-721](https://eips.ethereum.org/EIPS/eip-721), [ERC-1115](https://eips.ethereum.org/EIPS/eip-1155), or future versions of [ERC-165](https://eips.ethereum.org/EIPS/eip-165)) and returning the required magic numbers for the associated callback functions for the inheriting contract so that it doesn't need to be upgraded.
/// @dev This callback handling functionality is intended to be used by executor contracts (i.e., `DAO.sol`).
/// @custom:security-contact sirt@aragon.org
abstract contract CallbackHandler {
    /// @notice A mapping between callback function selectors and magic return numbers.
    mapping(bytes4 => bytes4) internal callbackMagicNumbers;

    /// @notice The magic number refering to unregistered callbacks.
    bytes4 internal constant UNREGISTERED_CALLBACK = bytes4(0);

    /// @notice Thrown if the callback function is not registered.
    /// @param callbackSelector The selector of the callback function.
    /// @param magicNumber The magic number to be registered for the callback function selector.
    error UnknownCallback(bytes4 callbackSelector, bytes4 magicNumber);

    /// @notice Emitted when `_handleCallback` is called.
    /// @param sender Who called the callback.
    /// @param sig The function signature.
    /// @param data The calldata.
    event CallbackReceived(address sender, bytes4 indexed sig, bytes data);

    /// @notice Handles callbacks to adaptively support ERC standards.
    /// @dev This function is supposed to be called via `_handleCallback(msg.sig, msg.data)` in the `fallback()` function of the inheriting contract.
    /// @param _callbackSelector The function selector of the callback function.
    /// @param _data The calldata.
    /// @return The magic number registered for the function selector triggering the fallback.
    function _handleCallback(
        bytes4 _callbackSelector,
        bytes memory _data
    ) internal virtual returns (bytes4) {
        bytes4 magicNumber = callbackMagicNumbers[_callbackSelector];
        if (magicNumber == UNREGISTERED_CALLBACK) {
            revert UnknownCallback({callbackSelector: _callbackSelector, magicNumber: magicNumber});
        }

        emit CallbackReceived({sender: msg.sender, sig: _callbackSelector, data: _data});

        return magicNumber;
    }

    /// @notice Registers a magic number for a callback function selector.
    /// @param _callbackSelector The selector of the callback function.
    /// @param _magicNumber The magic number to be registered for the callback function selector.
    function _registerCallback(bytes4 _callbackSelector, bytes4 _magicNumber) internal virtual {
        callbackMagicNumbers[_callbackSelector] = _magicNumber;
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[49] private __gap;
}


### File: /home/errick/core/packages/contracts/src/core/utils/Voting.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به قرارداد CustomHash برای هش کردن اطلاعات

/**
 * @title Voting
 * @dev مدیریت رأی‌گیری برای تصمیم‌گیری‌های DAO-VC با الگوریتم ترکیبی PoA + dPoS + PoP + AI
 */
contract Voting is Ownable {
    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // وضعیت‌های مختلف پیشنهاد
    enum ProposalStatus { Pending, Approved, Rejected }

    // ساختار Proposal شامل شناسه، توضیحات، تعداد آراء موافق، تعداد آراء مخالف، تعداد کل آراء، وضعیت و هش
    struct Proposal {
        uint256 id;
        string description;
        uint256 voteCountYes;
        uint256 voteCountNo;
        uint256 totalVotes;
        ProposalStatus status;
        bytes32 hash;
        mapping(address => bool) hasVoted; // نگاشت برای پیگیری آراء اعضا
    }

    uint256 public proposalCount; // شمارنده پیشنهادات
    uint256 public requiredQuorumPercentage = 50; // حداقل درصد رأی مثبت برای تأیید
    uint256 public reputationThreshold = 10; // حداقل امتیاز برای اعتبارسنجی PoA
    mapping(uint256 => Proposal) public proposals; // نگاشت برای ذخیره‌سازی پیشنهادات
    mapping(bytes32 => bool) public proposalHashes; // نگاشت برای پیگیری هش پیشنهادات به منظور جلوگیری از پیشنهادات تکراری
    mapping(address => uint256) public reputationScore; // ذخیره امتیاز Validators

    // رویدادها برای ثبت تغییرات در قرارداد
    event ProposalCreated(uint256 indexed proposalId, string description, bytes32 hash);
    event Voted(uint256 indexed proposalId, address indexed voter, bool support, bytes32 hash);
    event ProposalFinalized(uint256 indexed proposalId, ProposalStatus status);
    event ReputationAdjusted(address indexed validator, uint256 newReputation);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     */
    constructor(address initialOwner, address _accControl, address _hasher) Ownable(initialOwner) {
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها اعضای DAO می‌توانند پیشنهادات ایجاد کنند
     */
    modifier onlyDAOMember() {
        require(accControl.isDAONode(msg.sender), "Only DAO members can create proposals");
        _;
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها اعتبارسنج‌های واجد شرایط می‌توانند رأی دهند
     */
    modifier onlyQualifiedValidator() {
        require(accControl.isValidator(msg.sender), "Only validators can vote");
        require(reputationScore[msg.sender] >= reputationThreshold, "Validator reputation too low");
        _;
    }

    /**
     * @dev ایجاد پیشنهاد جدید
     * @param description توضیحات پیشنهاد
     */
    function createProposal(string memory description) external onlyDAOMember {
        proposalCount++;
        bytes32 proposalHash = hasher.customHash(abi.encodePacked(description, msg.sender, block.timestamp), keccak256(abi.encodePacked("createProposal")));
        require(!proposalHashes[proposalHash], "Duplicate proposal detected");

        Proposal storage newProposal = proposals[proposalCount];
        newProposal.id = proposalCount;
        newProposal.description = description;
        newProposal.voteCountYes = 0;
        newProposal.voteCountNo = 0;
        newProposal.totalVotes = 0;
        newProposal.status = ProposalStatus.Pending;
        newProposal.hash = proposalHash;
        proposalHashes[proposalHash] = true;

        emit ProposalCreated(proposalCount, description, proposalHash);
    }

    /**
     * @dev رأی دادن به یک پیشنهاد
     * @param proposalId شناسه پیشنهاد
     * @param support رأی موافق یا مخالف
     */
    function vote(uint256 proposalId, bool support) external onlyQualifiedValidator {
        Proposal storage proposal = proposals[proposalId];
        require(!proposal.hasVoted[msg.sender], "Validator has already voted");
        require(proposal.status == ProposalStatus.Pending, "Voting is closed for this proposal");
        bytes32 voteHash = hasher.customHash(abi.encodePacked(proposalId, msg.sender, support, block.timestamp), keccak256(abi.encodePacked("vote")));

        if (support) {
            proposal.voteCountYes++;
        } else {
            proposal.voteCountNo++;
        }
        proposal.totalVotes++;
        proposal.hasVoted[msg.sender] = true;

        adjustReputation(msg.sender, true); // افزایش امتیاز اعتبارسنجی برای مشارکت
        emit Voted(proposalId, msg.sender, support, voteHash);
    }

    /**
     * @dev نهایی کردن یک پیشنهاد پس از پایان دوره رأی‌گیری
     * @param proposalId شناسه پیشنهاد
     */
    function finalizeProposal(uint256 proposalId) external onlyDAOMember {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.status == ProposalStatus.Pending, "Proposal already finalized");
        uint256 totalValidators = accControl.validatorCount(); // تعداد کل اعتبارسنج‌ها
        require(proposal.totalVotes >= (totalValidators * requiredQuorumPercentage) / 100, "Not enough votes to finalize");

        if (proposal.voteCountYes > proposal.voteCountNo) {
            proposal.status = ProposalStatus.Approved;
        } else {
            proposal.status = ProposalStatus.Rejected;
        }

        emit ProposalFinalized(proposalId, proposal.status);
    }

    /**
     * @dev تنظیم امتیاز اعتبارسنجی
     * @param validator آدرس اعتبارسنج
     * @param participated وضعیت مشارکت
     */
    function adjustReputation(address validator, bool participated) internal {
        if (participated) {
            reputationScore[validator] += 2; // افزایش امتیاز برای مشارکت
        } else {
            reputationScore[validator] = reputationScore[validator] > 0 ? reputationScore[validator] - 1 : 0; // کاهش امتیاز در صورت عدم فعالیت
        }
        emit ReputationAdjusted(validator, reputationScore[validator]);
    }
}

### File: /home/errick/core/packages/contracts/src/core/consensus/Consensus.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به تابع هش اختصاصی

/**
 * @title Consensus
 * @dev مدیریت مکانیزم اجماع با ترکیب PoA + dPoS + PoP + AI
 */
contract Consensus is Ownable {
    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // ساختار Validator شامل آدرس، مقدار استیک، اعتبار، تعداد مشارکت و وضعیت فعال بودن
    struct Validator {
        address validatorAddress;
        uint256 stake;
        uint256 reputation;
        uint256 participationCount;
        bool isActive;
    }

    // نگاشت برای ذخیره Validatorها
    mapping(address => Validator) public validators;
    address[] public validatorList; // لیست آدرس‌های Validatorها
    uint256 public requiredReputation = 10; // اعتبار مورد نیاز برای Validatorها
    uint256 public minParticipation = 5; // حداقل تعداد مشارکت برای حفظ اعتبار

    // رویدادها برای ثبت تغییرات در قرارداد
    event ValidatorAdded(address indexed validator, uint256 stake);
    event ValidatorRemoved(address indexed validator);
    event TransactionValidated(address indexed validator, bytes32 transactionHash);
    event ReputationUpdated(address indexed validator, uint256 newReputation);

    /**
     * @dev سازنده قرارداد
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     * @param initialOwner آدرس مالک اولیه
     */
    constructor(address _accControl, address _hasher, address initialOwner) Ownable(initialOwner) {
        require(_accControl != address(0), "Invalid AccControl address");
        require(_hasher != address(0), "Invalid CustomHash address");
        require(initialOwner != address(0), "Invalid owner address");
        
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها Validatorهای فعال می‌توانند عمل انجام دهند
     */
    modifier onlyValidator() {
        require(validators[msg.sender].isActive, "Only active validators can perform this action");
        require(validators[msg.sender].reputation >= requiredReputation, "Validator reputation too low");
        _;
    }

    /**
     * @dev افزودن Validator جدید به قرارداد
     * @param validatorAddress آدرس Validator جدید
     * @param stake مقدار استیک Validator
     */
    function addValidator(address validatorAddress, uint256 stake) external onlyOwner {
        require(validatorAddress != address(0), "Invalid validator address");
        require(!validators[validatorAddress].isActive, "Validator already exists");
        validators[validatorAddress] = Validator(validatorAddress, stake, 10, 0, true);
        validatorList.push(validatorAddress);
        emit ValidatorAdded(validatorAddress, stake);
    }

    /**
     * @dev حذف Validator موجود از قرارداد
     * @param validatorAddress آدرس Validator
     */
    function removeValidator(address validatorAddress) external onlyOwner {
        require(validatorAddress != address(0), "Invalid validator address");
        require(validators[validatorAddress].isActive, "Validator not found");
        validators[validatorAddress].isActive = false;
        emit ValidatorRemoved(validatorAddress);
    }

    /**
     * @dev تایید تراکنش توسط Validator
     * @param transactionHash هش تراکنش
     */
    function validateTransaction(bytes32 transactionHash) external onlyValidator {
        require(transactionHash != bytes32(0), "Invalid transaction hash");
        validators[msg.sender].participationCount++;
        adjustReputation(msg.sender, true);
        emit TransactionValidated(msg.sender, transactionHash);
    }

    /**
     * @dev تنظیم اعتبار Validator بر اساس مشارکت
     * @param validator آدرس Validator
     * @param participated وضعیت مشارکت Validator
     */
    function adjustReputation(address validator, bool participated) internal {
        require(validator != address(0), "Invalid validator address");
        if (participated) {
            validators[validator].reputation += 2;
        } else if (validators[validator].participationCount < minParticipation) {
            validators[validator].reputation = validators[validator].reputation > 0 ? validators[validator].reputation - 1 : 0;
        }
        emit ReputationUpdated(validator, validators[validator].reputation);
    }
}

### File: /home/errick/core/packages/contracts/src/core/security/CustomHash.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

/**
 * @title CustomHash
 * @dev قرارداد برای اجرای تابع هش اختصاصی
 */
contract CustomHash {

    /**
     * @dev تابع هش اختصاصی
     * @param data داده ورودی به صورت بایت
     * @param salt مقدار Salt برای ترکیب با داده
     * @return هش نهایی به صورت bytes32
     */
    function customHash(bytes memory data, bytes32 salt) public pure returns (bytes32) {
        // ترکیب داده ورودی با salt
        bytes memory saltedData = abi.encodePacked(data, salt);

        // اجرای ۵ دور Keccak256
        bytes32 hashed = keccak256(saltedData);
        for (uint8 i = 0; i < 4; i++) {
            hashed = keccak256(abi.encodePacked(hashed));
        }

        // ترکیب هش نهایی با salt به صورت XOR
        return hashed ^ salt;
    }
}


### File: /home/errick/core/packages/contracts/src/core/management/ProjectMon.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به قرارداد CustomHash برای هش کردن اطلاعات

/**
 * @title ProjectMon
 * @dev نظارت بر پروژه‌ها در شبکه DAO-VC
 */
contract ProjectMon is Ownable {
    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // ساختار Project شامل شناسه، نام، توضیحات، مالک، هش و وضعیت کامل شدن
    struct Project {
        uint256 id;
        string name;
        string description;
        address owner;
        bytes32 hash;
        bool isCompleted;
    }

    uint256 public projectCount; // شمارنده پروژه‌ها
    mapping(uint256 => Project) public projects; // نگاشت برای ذخیره‌سازی پروژه‌ها
    mapping(bytes32 => bool) public projectHashes; // نگاشت برای پیگیری هش پروژه‌ها به منظور جلوگیری از پروژه‌های تکراری

    // رویدادها برای ثبت تغییرات در قرارداد
    event ProjectRegistered(uint256 indexed projectId, string name, address indexed owner, bytes32 hash);
    event ProjectUpdated(uint256 indexed projectId, bool isCompleted, bytes32 hash);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     */
    constructor(address initialOwner, address _accControl, address _hasher) Ownable(initialOwner) {
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها مالک پروژه می‌تواند عمل انجام دهد
     * @param projectId شناسه پروژه
     */
    modifier onlyProjectOwner(uint256 projectId) {
        require(projects[projectId].owner == msg.sender, "Only project owner can update");
        _;
    }

    /**
     * @dev ثبت پروژه جدید
     * @param name نام پروژه
     * @param description توضیحات پروژه
     */
    function registerProject(string memory name, string memory description) external {
        projectCount++;
        bytes32 projectHash = hasher.customHash(abi.encodePacked(name, description, msg.sender, block.timestamp), keccak256(abi.encodePacked("register")));
        require(!projectHashes[projectHash], "Duplicate project detected");

        projects[projectCount] = Project({
            id: projectCount,
            name: name,
            description: description,
            owner: msg.sender,
            hash: projectHash,
            isCompleted: false
        });
        projectHashes[projectHash] = true;

        emit ProjectRegistered(projectCount, name, msg.sender, projectHash);
    }

    /**
     * @dev به‌روزرسانی وضعیت پروژه
     * @param projectId شناسه پروژه
     * @param isCompleted وضعیت کامل شدن پروژه
     */
    function updateProjectStatus(uint256 projectId, bool isCompleted) external onlyProjectOwner(projectId) {
        bytes32 updateHash = hasher.customHash(abi.encodePacked(projectId, isCompleted, block.timestamp), keccak256(abi.encodePacked("update")));
        require(!projectHashes[updateHash], "Duplicate update detected");

        projects[projectId].isCompleted = isCompleted;
        projectHashes[updateHash] = true;

        emit ProjectUpdated(projectId, isCompleted, updateHash);
    }
}

### File: /home/errick/core/packages/contracts/src/core/management/DAO.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // اتصال به رابط IERC20 برای تعامل با توکن‌های ERC20

/**
 * @title DAO
 * @dev قرارداد برای مدیریت سازمان خودمختار غیرمتمرکز (DAO)
 */
contract DAO is Ownable {
    struct Proposal {
        string description; // توضیحات پیشنهاد
        uint256 deadline; // مهلت رأی‌گیری
        uint256 votesFor; // تعداد آراء موافق
        uint256 votesAgainst; // تعداد آراء مخالف
        bool executed; // وضعیت اجرای پیشنهاد
        mapping(address => bool) hasVoted; // نگاشت برای پیگیری آراء داده شده توسط اعضا
    }

    mapping(uint256 => Proposal) private proposals; // نگاشت برای ذخیره‌سازی پیشنهادات
    uint256 public proposalCount; // تعداد پیشنهادات ایجاد شده
    address public tokenAddress; // آدرس قرارداد توکن
    uint256 public votingThreshold; // حداقل تعداد توکن برای شرکت در رأی‌گیری

    // رویدادها برای ثبت تغییرات در قرارداد
    event ProposalCreated(uint256 proposalId, string description, uint256 deadline);
    event VoteCast(address indexed voter, uint256 proposalId, bool support);
    event ProposalExecuted(uint256 proposalId, bool success);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param _tokenAddress آدرس قرارداد توکن
     * @param _votingThreshold حداقل تعداد توکن برای شرکت در رأی‌گیری
     */
    constructor(address initialOwner, address _tokenAddress, uint256 _votingThreshold) Ownable(initialOwner) {
        require(_tokenAddress != address(0), "Invalid token address");
        require(_votingThreshold > 0, "Voting threshold must be greater than zero");

        tokenAddress = _tokenAddress;
        votingThreshold = _votingThreshold;
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها دارندگان توکن می‌توانند عمل انجام دهند
     */
    modifier onlyTokenHolders() {
        require(balanceOf(msg.sender) >= votingThreshold, "Not enough tokens to participate");
        _;
    }

    /**
     * @dev بررسی موجودی توکن یک حساب
     * @param account آدرس حساب
     * @return تعداد توکن‌های حساب
     */
    function balanceOf(address account) internal view returns (uint256) {
        return IERC20(tokenAddress).balanceOf(account);
    }

    /**
     * @dev ایجاد پیشنهاد جدید
     * @param description توضیحات پیشنهاد
     * @param duration مدت زمان رأی‌گیری به ثانیه
     */
    function createProposal(string memory description, uint256 duration) external onlyTokenHolders {
        require(duration > 0, "Duration must be greater than zero");

        Proposal storage newProposal = proposals[proposalCount];
        newProposal.description = description;
        newProposal.deadline = block.timestamp + duration;

        emit ProposalCreated(proposalCount, description, newProposal.deadline);
        proposalCount++;
    }

    /**
     * @dev رأی دادن به یک پیشنهاد
     * @param proposalId شناسه پیشنهاد
     * @param support رأی موافق یا مخالف
     */
    function vote(uint256 proposalId, bool support) external onlyTokenHolders {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp <= proposal.deadline, "Voting period has ended");
        require(!proposal.hasVoted[msg.sender], "You have already voted");

        if (support) {
            proposal.votesFor++;
        } else {
            proposal.votesAgainst++;
        }

        proposal.hasVoted[msg.sender] = true;

        emit VoteCast(msg.sender, proposalId, support);
    }

    /**
     * @dev اجرای پیشنهاد پس از پایان دوره رأی‌گیری
     * @param proposalId شناسه پیشنهاد
     */
    function executeProposal(uint256 proposalId) external onlyOwner {
        Proposal storage proposal = proposals[proposalId];
        require(block.timestamp > proposal.deadline, "Voting period has not ended");
        require(!proposal.executed, "Proposal already executed");

        proposal.executed = true;
        bool success = proposal.votesFor > proposal.votesAgainst;

        emit ProposalExecuted(proposalId, success);
    }

    /**
     * @dev به‌روزرسانی حد نصاب رأی‌گیری
     * @param newThreshold حد نصاب جدید
     */
    function updateVotingThreshold(uint256 newThreshold) external onlyOwner {
        require(newThreshold > 0, "Threshold must be greater than zero");
        votingThreshold = newThreshold;
    }

    /**
     * @dev دریافت اطلاعات یک پیشنهاد
     * @param proposalId شناسه پیشنهاد
     * @return description توضیحات پیشنهاد
     * @return deadline مهلت پیشنهاد
     * @return votesFor تعداد آراء موافق
     * @return votesAgainst تعداد آراء مخالف
     * @return executed وضعیت اجرای پیشنهاد
     */
    function getProposal(uint256 proposalId)
        external
        view
        returns (
            string memory description,
            uint256 deadline,
            uint256 votesFor,
            uint256 votesAgainst,
            bool executed
        )
    {
        Proposal storage proposal = proposals[proposalId];
        return (
            proposal.description,
            proposal.deadline,
            proposal.votesFor,
            proposal.votesAgainst,
            proposal.executed
        );
    }
}

### File: /home/errick/core/packages/contracts/src/core/investment/Payments.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./Token.sol"; // اتصال به قرارداد Token برای مدیریت توکن‌ها
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به قرارداد CustomHash برای هش کردن اطلاعات

/**
 * @title Payments
 * @dev مدیریت پرداخت‌ها و تراکنش‌های مالی در شبکه DAO-VC
 */
contract Payments is Ownable {
    Token public token; // متغیر عمومی برای نگهداری آدرس قرارداد توکن
    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // نگاشت برای پیگیری هش تراکنش‌ها به منظور جلوگیری از تراکنش‌های تکراری
    mapping(bytes32 => bool) public transactionHashes;

    // رویدادها برای ثبت تغییرات در قرارداد
    event PaymentTransferred(address indexed from, address indexed to, uint256 amount, bytes32 hash);
    event FundsWithdrawn(address indexed user, uint256 amount, bytes32 hash);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param _token آدرس قرارداد توکن
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     */
    constructor(address initialOwner, address _token, address _accControl, address _hasher) Ownable(initialOwner) {
        token = Token(_token);
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها اعضای مجاز می‌توانند عمل انجام دهند
     */
    modifier onlyAuthorized() {
        require(accControl.isDAONode(msg.sender) || accControl.isValidator(msg.sender), "Unauthorized action");
        _;
    }

    /**
     * @dev انتقال پرداخت از یک آدرس به آدرس دیگر
     * @param to آدرس گیرنده
     * @param amount مقدار توکن‌های انتقالی
     */
    function transferPayment(address to, uint256 amount) external onlyAuthorized {
        require(token.balanceOf(msg.sender) >= amount, "Insufficient balance");
        bytes32 paymentHash = hasher.customHash(abi.encodePacked(msg.sender, to, amount, block.timestamp), keccak256(abi.encodePacked("payment")));
        require(!transactionHashes[paymentHash], "Duplicate transaction detected");

        token.transferFrom(msg.sender, to, amount);
        transactionHashes[paymentHash] = true;

        emit PaymentTransferred(msg.sender, to, amount, paymentHash);
    }

    /**
     * @dev برداشت وجه از قرارداد
     * @param amount مقدار توکن‌های برداشتی
     */
    function withdrawFunds(uint256 amount) external onlyAuthorized {
        require(token.balanceOf(address(this)) >= amount, "Insufficient contract balance");
        bytes32 withdrawHash = hasher.customHash(abi.encodePacked(msg.sender, amount, block.timestamp), keccak256(abi.encodePacked("withdraw")));
        require(!transactionHashes[withdrawHash], "Duplicate withdrawal detected");

        token.transfer(msg.sender, amount);
        transactionHashes[withdrawHash] = true;

        emit FundsWithdrawn(msg.sender, amount, withdrawHash);
    }
}

### File: /home/errick/core/packages/contracts/src/core/investment/Investment.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "./Token.sol"; // اتصال به قرارداد Token برای مدیریت توکن‌ها
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به قرارداد CustomHash برای هش کردن اطلاعات

/**
 * @title Investment
 * @dev مدیریت سرمایه‌گذاری‌ها در شبکه DAO-VC
 */
contract Investment is Ownable {
    Token public token; // متغیر عمومی برای نگهداری آدرس قرارداد توکن
    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // ساختار InvestmentInfo شامل مقدار سرمایه‌گذاری، زمان‌بندی و هش
    struct InvestmentInfo {
        uint256 amount;
        uint256 timestamp;
        bytes32 hash;
    }

    // نگاشت برای ذخیره‌سازی اطلاعات سرمایه‌گذاری‌ها
    mapping(address => InvestmentInfo) public investments;
    // نگاشت برای پیگیری هش تراکنش‌ها به منظور جلوگیری از تراکنش‌های تکراری
    mapping(bytes32 => bool) public transactionHashes;

    // رویدادها برای ثبت تغییرات در قرارداد
    event InvestmentMade(address indexed investor, uint256 amount, bytes32 hash);
    event InvestmentWithdrawn(address indexed investor, uint256 amount, bytes32 hash);

    /**
     * @dev سازنده قرارداد
     * @param initialOwner آدرس مالک اولیه
     * @param _token آدرس قرارداد توکن
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     */
    constructor(address initialOwner, address _token, address _accControl, address _hasher) Ownable(initialOwner) {
        token = Token(_token);
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها سرمایه‌گذاران می‌توانند عمل انجام دهند
     */
    modifier onlyInvestor() {
        require(accControl.getRole(msg.sender) == AccControl.Role.Investor, "Only investors can perform this action");
        _;
    }

    /**
     * @dev سرمایه‌گذاری توکن‌ها
     * @param amount مقدار توکن‌های سرمایه‌گذاری شده
     */
    function stakeTokens(uint256 amount) external onlyInvestor {
        require(token.balanceOf(msg.sender) >= amount, "Insufficient balance");
        bytes32 stakeHash = hasher.customHash(abi.encodePacked(msg.sender, amount, block.timestamp), keccak256(abi.encodePacked("stake")));
        require(!transactionHashes[stakeHash], "Duplicate transaction detected");

        token.transferFrom(msg.sender, address(this), amount);
        investments[msg.sender] = InvestmentInfo(amount, block.timestamp, stakeHash);
        transactionHashes[stakeHash] = true;

        emit InvestmentMade(msg.sender, amount, stakeHash);
    }

    /**
     * @dev برداشت سرمایه‌گذاری
     */
    function withdrawInvestment() external onlyInvestor {
        InvestmentInfo storage userInvestment = investments[msg.sender];
        require(userInvestment.amount > 0, "No investment found");
        bytes32 withdrawHash = hasher.customHash(abi.encodePacked(msg.sender, userInvestment.amount, block.timestamp), keccak256(abi.encodePacked("withdraw")));
        require(!transactionHashes[withdrawHash], "Duplicate withdrawal detected");

        token.transfer(msg.sender, userInvestment.amount);
        delete investments[msg.sender];
        transactionHashes[withdrawHash] = true;

        emit InvestmentWithdrawn(msg.sender, userInvestment.amount, withdrawHash);
    }
}

### File: /home/errick/core/packages/contracts/src/core/dao/IEIP4824.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @title EIP-4824 Common Interfaces for DAOs
/// @dev See https://eips.ethereum.org/EIPS/eip-4824
/// @author Aragon X - 2021-2023
/// @custom:security-contact sirt@aragon.org
interface IEIP4824 {
    /// @notice A distinct Uniform Resource Identifier (URI) pointing to a JSON object following the "EIP-4824 DAO JSON-LD Schema". This JSON file splits into four URIs: membersURI, proposalsURI, activityLogURI, and governanceURI. The membersURI should point to a JSON file that conforms to the "EIP-4824 Members JSON-LD Schema". The proposalsURI should point to a JSON file that conforms to the "EIP-4824 Proposals JSON-LD Schema". The activityLogURI should point to a JSON file that conforms to the "EIP-4824 Activity Log JSON-LD Schema". The governanceURI should point to a flatfile, normatively a .md file. Each of the JSON files named above can be statically hosted or dynamically-generated.
    /// @return _daoURI The DAO URI.
    function daoURI() external view returns (string memory _daoURI);
}


### File: /home/errick/core/packages/contracts/src/core/dao/DAO.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC165StorageUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165StorageUpgradeable.sol";
import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {SafeERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import {IERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import {IERC721ReceiverUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol";
import {IERC1155Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol";
import {IERC1155ReceiverUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol";
import {AddressUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";

import {IProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol";
import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {VersionComparisonLib} from "@aragon/osx-commons-contracts/src/utils/versioning/VersionComparisonLib.sol";
import {hasBit, flipBit} from "@aragon/osx-commons-contracts/src/utils/math/BitMap.sol";
import {Action} from "@aragon/osx-commons-contracts/src/executors/Executor.sol";
import {IExecutor} from "@aragon/osx-commons-contracts/src/executors/IExecutor.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

import {PermissionManager} from "../permission/PermissionManager.sol";
import {CallbackHandler} from "../utils/CallbackHandler.sol";
import {IEIP4824} from "./IEIP4824.sol";

/// @title DAO
/// @author Aragon X - 2021-2024
/// @notice This contract is the entry point to the Aragon DAO framework and provides our users a simple and easy to use public interface.
/// @dev Public API of the Aragon DAO framework.
/// @custom:security-contact sirt@aragon.org
contract DAO is
    IEIP4824,
    Initializable,
    IERC1271,
    ERC165StorageUpgradeable,
    IDAO,
    IExecutor,
    UUPSUpgradeable,
    ProtocolVersion,
    PermissionManager,
    CallbackHandler
{
    using SafeERC20Upgradeable for IERC20Upgradeable;
    using AddressUpgradeable for address;
    using VersionComparisonLib for uint8[3];

    /// @notice The ID of the permission required to call the `execute` function.
    bytes32 public constant EXECUTE_PERMISSION_ID = keccak256("EXECUTE_PERMISSION");

    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.
    bytes32 public constant UPGRADE_DAO_PERMISSION_ID = keccak256("UPGRADE_DAO_PERMISSION");

    /// @notice The ID of the permission required to call the `setMetadata` function.
    bytes32 public constant SET_METADATA_PERMISSION_ID = keccak256("SET_METADATA_PERMISSION");

    /// @notice The ID of the permission required to call the `setTrustedForwarder` function.
    bytes32 public constant SET_TRUSTED_FORWARDER_PERMISSION_ID =
        keccak256("SET_TRUSTED_FORWARDER_PERMISSION");

    /// @notice The ID of the permission required to call the `registerStandardCallback` function.
    bytes32 public constant REGISTER_STANDARD_CALLBACK_PERMISSION_ID =
        keccak256("REGISTER_STANDARD_CALLBACK_PERMISSION");

    /// @notice The ID of the permission required to validate [ERC-1271](https://eips.ethereum.org/EIPS/eip-1271) signatures.
    bytes32 public constant VALIDATE_SIGNATURE_PERMISSION_ID =
        keccak256("VALIDATE_SIGNATURE_PERMISSION");

    /// @notice The internal constant storing the maximal action array length.
    uint256 internal constant MAX_ACTIONS = 256;

    /// @notice The first out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set indicating that a function was not entered.
    uint256 private constant _NOT_ENTERED = 1;

    /// @notice The second out of two values to which the `_reentrancyStatus` state variable (used by the `nonReentrant` modifier) can be set indicating that a function was entered.
    uint256 private constant _ENTERED = 2;

    /// @notice Removed variable that is left here to maintain the storage layout.
    /// @dev Introduced in v1.0.0. Removed in v1.4.0.
    /// @custom:oz-renamed-from signatureValidator
    address private __removed0;

    /// @notice The address of the trusted forwarder verifying meta transactions.
    /// @dev Added in v1.0.0.
    address private trustedForwarder;

    /// @notice The [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI.
    /// @dev Added in v1.0.0.
    string private _daoURI;

    /// @notice The state variable for the reentrancy guard of the `execute` function.
    /// @dev Added in v1.3.0. The variable can be of value `_NOT_ENTERED = 1` or `_ENTERED = 2` in usage and is initialized with `_NOT_ENTERED`.
    uint256 private _reentrancyStatus;

    /// @notice Thrown if a call is reentrant.
    error ReentrantCall();

    /// @notice Thrown if the action array length is larger than `MAX_ACTIONS`.
    error TooManyActions();

    /// @notice Thrown if action execution has failed.
    /// @param index The index of the action in the action array that failed.
    error ActionFailed(uint256 index);

    /// @notice Thrown if an action has insufficient gas left.
    error InsufficientGas();

    /// @notice Thrown if the deposit amount is zero.
    error ZeroAmount();

    /// @notice Thrown if there is a mismatch between the expected and actually deposited amount of native tokens.
    /// @param expected The expected native token amount.
    /// @param actual The actual native token amount deposited.
    error NativeTokenDepositAmountMismatch(uint256 expected, uint256 actual);

    /// @notice Thrown if an upgrade is not supported from a specific protocol version .
    error ProtocolVersionUpgradeNotSupported(uint8[3] protocolVersion);

    /// @notice Thrown when a function is removed but left to not corrupt the interface ID.
    error FunctionRemoved();

    /// @notice Thrown when initialize is called after it has already been executed.
    error AlreadyInitialized();

    /// @notice Emitted when a new DAO URI is set.
    /// @param daoURI The new URI.
    event NewURI(string daoURI);

    /// @notice A modifier to protect a function from calling itself, directly or indirectly (reentrancy).
    /// @dev Currently, this modifier is only applied to the `execute()` function. If this is used multiple times, private `_beforeNonReentrant()` and `_afterNonReentrant()` functions should be created to prevent code duplication.
    modifier nonReentrant() {
        if (_reentrancyStatus == _ENTERED) {
            revert ReentrantCall();
        }
        _reentrancyStatus = _ENTERED;

        _;

        _reentrancyStatus = _NOT_ENTERED;
    }

    /// @notice This ensures that the initialize function cannot be called during the upgrade process.
    modifier onlyCallAtInitialization() {
        if (_getInitializedVersion() != 0) {
            revert AlreadyInitialized();
        }

        _;
    }

    /// @notice Disables the initializers on the implementation contract to prevent it from being left uninitialized.
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the DAO by
    /// - setting the reentrancy status variable to `_NOT_ENTERED`
    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID
    /// - setting the trusted forwarder for meta transactions
    /// - giving the `ROOT_PERMISSION_ID` permission to the initial owner (that should be revoked and transferred to the DAO after setup).
    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).
    /// @param _metadata IPFS hash that points to all the metadata (logo, description, tags, etc.) of a DAO.
    /// @param _initialOwner The initial owner of the DAO having the `ROOT_PERMISSION_ID` permission.
    /// @param _trustedForwarder The trusted forwarder responsible for verifying meta transactions.
    /// @param daoURI_ The DAO URI required to support [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824).
    function initialize(
        bytes calldata _metadata,
        address _initialOwner,
        address _trustedForwarder,
        string calldata daoURI_
    ) external onlyCallAtInitialization reinitializer(3) {
        _reentrancyStatus = _NOT_ENTERED; // added in v1.3.0

        // In addition to the current interfaceId, also support previous version of the interfaceId.
        _registerInterface(type(IDAO).interfaceId ^ IExecutor.execute.selector);

        _registerInterface(type(IDAO).interfaceId);
        _registerInterface(type(IExecutor).interfaceId);
        _registerInterface(type(IERC1271).interfaceId);
        _registerInterface(type(IEIP4824).interfaceId);
        _registerInterface(type(IProtocolVersion).interfaceId); // added in v1.3.0
        _registerTokenInterfaces();

        _setMetadata(_metadata);
        _setTrustedForwarder(_trustedForwarder);
        _setDaoURI(daoURI_);
        __PermissionManager_init(_initialOwner);
    }

    /// @notice Initializes the DAO after an upgrade from a previous protocol version.
    /// @param _previousProtocolVersion The semantic protocol version number of the previous DAO implementation contract this upgrade is transitioning from.
    /// @param _initData The initialization data to be passed to via `upgradeToAndCall` (see [ERC-1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade)).
    function initializeFrom(
        uint8[3] calldata _previousProtocolVersion,
        bytes calldata _initData
    ) external reinitializer(3) {
        _initData; // Silences the unused function parameter warning.

        // Check that the contract is not upgrading from a different major release.
        if (_previousProtocolVersion[0] != 1) {
            revert ProtocolVersionUpgradeNotSupported(_previousProtocolVersion);
        }

        // Initialize `_reentrancyStatus` that was added in v1.3.0.
        // Register Interface `ProtocolVersion` that was added in v1.3.0.
        if (_previousProtocolVersion.lt([1, 3, 0])) {
            _reentrancyStatus = _NOT_ENTERED;
            _registerInterface(type(IProtocolVersion).interfaceId);
        }

        // Revoke the `SET_SIGNATURE_VALIDATOR_PERMISSION` that was deprecated in v1.4.0.
        if (_previousProtocolVersion.lt([1, 4, 0])) {
            _revoke({
                _where: address(this),
                _who: address(this),
                _permissionId: keccak256("SET_SIGNATURE_VALIDATOR_PERMISSION")
            });

            _registerInterface(type(IDAO).interfaceId);
            _registerInterface(type(IExecutor).interfaceId);
        }
    }

    /// @inheritdoc PermissionManager
    function isPermissionRestrictedForAnyAddr(
        bytes32 _permissionId
    ) internal pure override returns (bool) {
        return
            _permissionId == EXECUTE_PERMISSION_ID ||
            _permissionId == UPGRADE_DAO_PERMISSION_ID ||
            _permissionId == SET_METADATA_PERMISSION_ID ||
            _permissionId == SET_TRUSTED_FORWARDER_PERMISSION_ID ||
            _permissionId == REGISTER_STANDARD_CALLBACK_PERMISSION_ID;
    }

    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).
    /// @dev The caller must have the `UPGRADE_DAO_PERMISSION_ID` permission.
    function _authorizeUpgrade(address) internal virtual override auth(UPGRADE_DAO_PERMISSION_ID) {}

    /// @inheritdoc IDAO
    function setTrustedForwarder(
        address _newTrustedForwarder
    ) external override auth(SET_TRUSTED_FORWARDER_PERMISSION_ID) {
        _setTrustedForwarder(_newTrustedForwarder);
    }

    /// @inheritdoc IDAO
    function getTrustedForwarder() external view virtual override returns (address) {
        return trustedForwarder;
    }

    /// @inheritdoc IDAO
    function hasPermission(
        address _where,
        address _who,
        bytes32 _permissionId,
        bytes memory _data
    ) external view override returns (bool) {
        return isGranted({_where: _where, _who: _who, _permissionId: _permissionId, _data: _data});
    }

    /// @inheritdoc IDAO
    function setMetadata(
        bytes calldata _metadata
    ) external override auth(SET_METADATA_PERMISSION_ID) {
        _setMetadata(_metadata);
    }

    /// @inheritdoc IExecutor
    function execute(
        bytes32 _callId,
        Action[] calldata _actions,
        uint256 _allowFailureMap
    )
        external
        override
        nonReentrant
        auth(EXECUTE_PERMISSION_ID)
        returns (bytes[] memory execResults, uint256 failureMap)
    {
        // Check that the action array length is within bounds.
        if (_actions.length > MAX_ACTIONS) {
            revert TooManyActions();
        }

        execResults = new bytes[](_actions.length);

        uint256 gasBefore;
        uint256 gasAfter;

        for (uint256 i = 0; i < _actions.length; ) {
            gasBefore = gasleft();

            (bool success, bytes memory result) = _actions[i].to.call{value: _actions[i].value}(
                _actions[i].data
            );
            gasAfter = gasleft();

            // Check if failure is allowed
            if (!hasBit(_allowFailureMap, uint8(i))) {
                // Check if the call failed.
                if (!success) {
                    revert ActionFailed(i);
                }
            } else {
                // Check if the call failed.
                if (!success) {
                    // Make sure that the action call did not fail because 63/64 of `gasleft()` was insufficient to execute the external call `.to.call` (see [ERC-150](https://eips.ethereum.org/EIPS/eip-150)).
                    // In specific scenarios, i.e. proposal execution where the last action in the action array is allowed to fail, the account calling `execute` could force-fail this action by setting a gas limit
                    // where 63/64 is insufficient causing the `.to.call` to fail, but where the remaining 1/64 gas are sufficient to successfully finish the `execute` call.
                    if (gasAfter < gasBefore / 64) {
                        revert InsufficientGas();
                    }

                    // Store that this action failed.
                    failureMap = flipBit(failureMap, uint8(i));
                }
            }

            execResults[i] = result;

            unchecked {
                ++i;
            }
        }

        emit Executed({
            actor: msg.sender,
            callId: _callId,
            actions: _actions,
            allowFailureMap: _allowFailureMap,
            failureMap: failureMap,
            execResults: execResults
        });
    }

    /// @inheritdoc IDAO
    function deposit(
        address _token,
        uint256 _amount,
        string calldata _reference
    ) external payable override {
        if (_amount == 0) revert ZeroAmount();

        if (_token == address(0)) {
            if (msg.value != _amount)
                revert NativeTokenDepositAmountMismatch({expected: _amount, actual: msg.value});
        } else {
            if (msg.value != 0)
                revert NativeTokenDepositAmountMismatch({expected: 0, actual: msg.value});

            IERC20Upgradeable(_token).safeTransferFrom(msg.sender, address(this), _amount);
        }

        emit Deposited(msg.sender, _token, _amount, _reference);
    }

    /// @inheritdoc IDAO
    function setSignatureValidator(address) external pure override {
        revert FunctionRemoved();
    }

    /// @inheritdoc IDAO
    /// @dev Relays the validation logic determining who is allowed to sign on behalf of the DAO to its permission manager.
    /// Caller specific bypassing can be set direct granting (i.e., `grant({_where: dao, _who: specificErc1271Caller, _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID})`).
    /// Caller specific signature validation logic can be set by granting with a `PermissionCondition` (i.e., `grantWithCondition({_where: dao, _who: specificErc1271Caller, _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID, _condition: yourConditionImplementation})`)
    /// Generic signature validation logic can be set for all calling contracts by granting with a `PermissionCondition` to `PermissionManager.ANY_ADDR()` (i.e., `grantWithCondition({_where: dao, _who: PermissionManager.ANY_ADDR(), _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID, _condition: yourConditionImplementation})`).
    function isValidSignature(
        bytes32 _hash,
        bytes memory _signature
    ) external view override(IDAO, IERC1271) returns (bytes4) {
        if (
            isGranted({
                _where: address(this),
                _who: msg.sender,
                _permissionId: VALIDATE_SIGNATURE_PERMISSION_ID,
                _data: abi.encode(_hash, _signature)
            })
        ) {
            return 0x1626ba7e; // `type(IERC1271).interfaceId` = bytes4(keccak256("isValidSignature(bytes32,bytes)")`
        }
        return 0xffffffff; // `bytes4(uint32(type(uint32).max-1))`
    }

    /// @notice Emits the `NativeTokenDeposited` event to track native token deposits that weren't made via the deposit method.
    /// @dev This call is bound by the gas limitations for `send`/`transfer` calls introduced by [ERC-2929](https://eips.ethereum.org/EIPS/eip-2929).
    /// Gas cost increases in future hard forks might break this function. As an alternative, [ERC-2930](https://eips.ethereum.org/EIPS/eip-2930)-type transactions using access lists can be employed.
    receive() external payable {
        emit NativeTokenDeposited(msg.sender, msg.value);
    }

    /// @notice Fallback to handle future versions of the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) standard.
    /// @param _input An alias being equivalent to `msg.data`. This feature of the fallback function was introduced with the [solidity compiler version 0.7.6](https://github.com/ethereum/solidity/releases/tag/v0.7.6)
    /// @return The magic number registered for the function selector triggering the fallback.
    fallback(bytes calldata _input) external returns (bytes memory) {
        bytes4 magicNumber = _handleCallback(msg.sig, _input);
        return abi.encode(magicNumber);
    }

    /// @notice Emits the MetadataSet event if new metadata is set.
    /// @param _metadata Hash of the IPFS metadata object.
    function _setMetadata(bytes calldata _metadata) internal {
        emit MetadataSet(_metadata);
    }

    /// @notice Sets the trusted forwarder on the DAO and emits the associated event.
    /// @param _trustedForwarder The trusted forwarder address.
    function _setTrustedForwarder(address _trustedForwarder) internal {
        trustedForwarder = _trustedForwarder;

        emit TrustedForwarderSet(_trustedForwarder);
    }

    /// @notice Registers the [ERC-721](https://eips.ethereum.org/EIPS/eip-721) and [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155) interfaces and callbacks.
    function _registerTokenInterfaces() private {
        _registerInterface(type(IERC721ReceiverUpgradeable).interfaceId);
        _registerInterface(type(IERC1155ReceiverUpgradeable).interfaceId);

        _registerCallback(
            IERC721ReceiverUpgradeable.onERC721Received.selector,
            IERC721ReceiverUpgradeable.onERC721Received.selector
        );
        _registerCallback(
            IERC1155ReceiverUpgradeable.onERC1155Received.selector,
            IERC1155ReceiverUpgradeable.onERC1155Received.selector
        );
        _registerCallback(
            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector,
            IERC1155ReceiverUpgradeable.onERC1155BatchReceived.selector
        );
    }

    /// @inheritdoc IDAO
    function registerStandardCallback(
        bytes4 _interfaceId,
        bytes4 _callbackSelector,
        bytes4 _magicNumber
    ) external override auth(REGISTER_STANDARD_CALLBACK_PERMISSION_ID) {
        _registerInterface(_interfaceId);
        _registerCallback(_callbackSelector, _magicNumber);
        emit StandardCallbackRegistered(_interfaceId, _callbackSelector, _magicNumber);
    }

    /// @inheritdoc IEIP4824
    function daoURI() external view returns (string memory) {
        return _daoURI;
    }

    /// @notice Updates the set DAO URI to a new value.
    /// @param newDaoURI The new DAO URI to be set.
    function setDaoURI(string calldata newDaoURI) external auth(SET_METADATA_PERMISSION_ID) {
        _setDaoURI(newDaoURI);
    }

    /// @notice Sets the new [ERC-4824](https://eips.ethereum.org/EIPS/eip-4824) DAO URI and emits the associated event.
    /// @param daoURI_ The new DAO URI.
    function _setDaoURI(string calldata daoURI_) internal {
        _daoURI = daoURI_;

        emit NewURI(daoURI_);
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[46] private __gap;
}


### File: /home/errick/core/packages/contracts/src/core/token/Token.sol ###
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.28;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol"; // اتصال به قرارداد ERC20 از OpenZeppelin
import "@openzeppelin/contracts/access/Ownable.sol"; // اتصال به قرارداد Ownable از OpenZeppelin
import "@openzeppelin/contracts/utils/Counters.sol"; // اتصال به کتابخانه Counters از OpenZeppelin
import "./AccControl.sol"; // اتصال به قرارداد AccControl برای مدیریت نقش‌ها
import "./CustomHash.sol"; // اتصال به قرارداد CustomHash برای هش کردن اطلاعات

/**
 * @title Token
 * @dev مدیریت توکن و دارایی‌های شبکه DAO-VC
 */
contract Token is ERC20, Ownable {
    using Counters for Counters.Counter; // استفاده از کتابخانه Counters برای شمارش شناسه‌ها

    AccControl public accControl; // متغیر عمومی برای نگهداری آدرس قرارداد AccControl
    CustomHash public hasher; // متغیر عمومی برای نگهداری آدرس قرارداد تابع هش

    // ساختار Asset شامل شناسه، نوع دارایی، متاداده، مقدار توکن، مالک و هش
    struct Asset {
        uint256 id;
        string assetType;
        string metadata;
        uint256 valueInTokens;
        address owner;
        bytes32 hash;
    }

    Counters.Counter private assetIdCounter; // شمارنده شناسه دارایی‌ها
    mapping(uint256 => Asset) public assets; // نگاشت برای ذخیره‌سازی دارایی‌ها
    mapping(address => uint256[]) public ownedAssets; // نگاشت برای ذخیره دارایی‌های متعلق به هر آدرس
    mapping(bytes32 => bool) public transactionHashes; // نگاشت برای پیگیری هش تراکنش‌ها به منظور جلوگیری از تراکنش‌های تکراری

    // رویدادها برای ثبت تغییرات در قرارداد
    event AssetRegistered(uint256 indexed assetId, string assetType, uint256 valueInTokens, address indexed owner, bytes32 hash);
    event AssetTransferred(uint256 indexed assetId, address indexed from, address indexed to, uint256 valueInTokens, bytes32 hash);
    event Tokenized(uint256 indexed assetId, address indexed owner, uint256 valueInTokens, bytes32 hash);

    /**
     * @dev سازنده قرارداد
     * @param initialSupply میزان اولیه توکن‌ها
     * @param initialOwner آدرس مالک اولیه
     * @param _accControl آدرس قرارداد AccControl
     * @param _hasher آدرس قرارداد تابع هش
     */
    constructor(uint256 initialSupply, address initialOwner, address _accControl, address _hasher) 
        ERC20("Rayan Token", "RYC") Ownable(initialOwner) {
        _mint(msg.sender, initialSupply); // ضرب توکن‌های اولیه
        accControl = AccControl(_accControl);
        hasher = CustomHash(_hasher);
    }

    /**
     * @dev Modifier برای اطمینان از اینکه تنها DAO می‌تواند عمل انجام دهد
     */
    modifier onlyDAO() {
        require(accControl.isDAONode(msg.sender), "Only DAO can execute this action");
        _;
    }

    /**
     * @dev ثبت دارایی جدید
     * @param assetType نوع دارایی
     * @param metadata متاداده دارایی
     * @param valueInTokens مقدار توکن‌های دارایی
     */
    function registerAsset(string memory assetType, string memory metadata, uint256 valueInTokens) external {
        require(valueInTokens > 0, "Asset value must be greater than zero");
        assetIdCounter.increment(); // افزایش شمارنده شناسه دارایی‌ها
        uint256 newAssetId = assetIdCounter.current();
        bytes32 assetHash = hasher.customHash(abi.encodePacked(metadata, block.timestamp), keccak256(abi.encodePacked("registerAsset")));

        assets[newAssetId] = Asset({
            id: newAssetId,
            assetType: assetType,
            metadata: metadata,
            valueInTokens: valueInTokens,
            owner: msg.sender,
            hash: assetHash
        });
        ownedAssets[msg.sender].push(newAssetId); // اضافه کردن دارایی به لیست دارایی‌های مالک
        transactionHashes[assetHash] = true; // ذخیره هش تراکنش به منظور جلوگیری از تراکنش‌های تکراری

        emit AssetRegistered(newAssetId, assetType, valueInTokens, msg.sender, assetHash);
    }

    /**
     * @dev انتقال دارایی به آدرس جدید
     * @param assetId شناسه دارایی
     * @param to آدرس گیرنده
     */
    function transferAsset(uint256 assetId, address to) external {
        Asset storage asset = assets[assetId];
        require(asset.owner == msg.sender, "You are not the owner of this asset");
        bytes32 transferHash = hasher.customHash(abi.encodePacked(assetId, msg.sender, to, block.timestamp), keccak256(abi.encodePacked("transferAsset")));

        asset.owner = to; // تغییر مالک دارایی
        ownedAssets[to].push(assetId); // اضافه کردن دارایی به لیست دارایی‌های مالک جدید
        transactionHashes[transferHash] = true; // ذخیره هش تراکنش به منظور جلوگیری از تراکنش‌های تکراری

        emit AssetTransferred(assetId, msg.sender, to, asset.valueInTokens, transferHash);
    }

    /**
     * @dev تبدیل دارایی به توکن
     * @param assetId شناسه دارایی
     */
    function tokenizeAsset(uint256 assetId) external {
        Asset storage asset = assets[assetId];
        require(asset.owner == msg.sender, "You are not the owner of this asset");
        bytes32 tokenizeHash = hasher.customHash(abi.encodePacked(assetId, msg.sender, block.timestamp), keccak256(abi.encodePacked("tokenizeAsset")));

        _mint(msg.sender, asset.valueInTokens); // ضرب توکن‌ها به میزان ارزش دارایی
        delete assets[assetId]; // حذف دارایی از لیست
        transactionHashes[tokenizeHash] = true; // ذخیره هش تراکنش به منظور جلوگیری از تراکنش‌های تکراری

        emit Tokenized(assetId, msg.sender, asset.valueInTokens, tokenizeHash);
    }
}

### File: /home/errick/core/packages/contracts/src/framework/README.adoc ###
== Framework Contracts API

The natspec generated API for the framework contracts. You can also find the contracts on the following link:https://github.com/aragon/osx[repository].

== Factories

{{DAOFactory}}

{{PluginRepoFactory}}

== Registries

{{DAORegistry}}

{{PluginRepoRegistry}}

== Framework 

{{PluginRepo}}

{{PluginSetupProcessor}}

### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/PluginRepo.sol ###
// SPDX-License-Identifier:    AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import {ERC165Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol";
import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {AddressUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol";
import {ERC165CheckerUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol";

import {IProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol";
import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";

import {PermissionManager} from "../../../core/permission/PermissionManager.sol";
import {IPluginRepo} from "./IPluginRepo.sol";

/// @title PluginRepo
/// @author Aragon X - 2020 - 2023
/// @notice The plugin repository contract required for managing and publishing different plugin versions within the Aragon DAO framework.
/// @custom:security-contact sirt@aragon.org
contract PluginRepo is
    Initializable,
    ERC165Upgradeable,
    IPluginRepo,
    UUPSUpgradeable,
    ProtocolVersion,
    PermissionManager
{
    using AddressUpgradeable for address;
    using ERC165CheckerUpgradeable for address;

    /// @notice The struct describing the tag of a version obtained by a release and build number as `RELEASE.BUILD`.
    /// @param release The release number.
    /// @param build The build number
    /// @dev Releases mark incompatible changes (e.g., the plugin interface, storage layout, or incompatible behavior) whereas builds mark compatible changes (e.g., patches and compatible feature additions).
    struct Tag {
        uint8 release;
        uint16 build;
    }

    /// @notice The struct describing a plugin version (release and build).
    /// @param tag The version tag.
    /// @param pluginSetup The setup contract associated with this version.
    /// @param buildMetadata The build metadata URI.
    struct Version {
        Tag tag;
        address pluginSetup;
        bytes buildMetadata;
    }

    /// @notice The ID of the permission required to call the `createVersion` function.
    bytes32 public constant MAINTAINER_PERMISSION_ID = keccak256("MAINTAINER_PERMISSION");

    /// @notice The ID of the permission required to call the `createVersion` function.
    bytes32 public constant UPGRADE_REPO_PERMISSION_ID = keccak256("UPGRADE_REPO_PERMISSION");

    /// @notice The mapping between release and build numbers.
    mapping(uint8 => uint16) internal buildsPerRelease;

    /// @notice The mapping between the version hash and the corresponding version information.
    mapping(bytes32 => Version) internal versions;

    /// @notice The mapping between the plugin setup address and its corresponding version hash.
    mapping(address => bytes32) internal latestTagHashForPluginSetup;

    /// @notice The ID of the latest release.
    /// @dev The maximum release number is 255.
    uint8 public latestRelease;

    /// @notice Thrown if a version does not exist.
    /// @param versionHash The tag hash.
    error VersionHashDoesNotExist(bytes32 versionHash);

    /// @notice Thrown if a plugin setup contract does not inherit from `PluginSetup`.
    error InvalidPluginSetupInterface();

    /// @notice Thrown if a release number is zero.
    error ReleaseZeroNotAllowed();

    /// @notice Thrown if a release number is incremented by more than one.
    /// @param latestRelease The latest release number.
    /// @param newRelease The new release number.
    error InvalidReleaseIncrement(uint8 latestRelease, uint8 newRelease);

    /// @notice Thrown if the same plugin setup contract exists already in a previous releases.
    /// @param release The release number of the already existing plugin setup.
    /// @param build The build number of the already existing plugin setup.
    /// @param pluginSetup The plugin setup contract address.
    error PluginSetupAlreadyInPreviousRelease(uint8 release, uint16 build, address pluginSetup);

    /// @notice Thrown if the metadata URI is empty.
    error EmptyReleaseMetadata();

    /// @notice Thrown if release does not exist.
    error ReleaseDoesNotExist();

    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract by
    /// - initializing the permission manager
    /// - granting the `MAINTAINER_PERMISSION_ID` permission to the initial owner.
    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).
    function initialize(address initialOwner) external initializer {
        __PermissionManager_init(initialOwner);

        _grant(address(this), initialOwner, MAINTAINER_PERMISSION_ID);
        _grant(address(this), initialOwner, UPGRADE_REPO_PERMISSION_ID);
    }

    /// @notice Initializes the pluginRepo after an upgrade from a previous protocol version.
    /// @param _previousProtocolVersion The semantic protocol version number of the previous DAO implementation contract this upgrade is transitioning from.
    /// @param _initData The initialization data to be passed to via `upgradeToAndCall` (see [ERC-1967](https://docs.openzeppelin.com/contracts/4.x/api/proxy#ERC1967Upgrade)).
    /// @dev This function is a placeholder until we require reinitialization.
    function initializeFrom(
        uint8[3] calldata _previousProtocolVersion,
        bytes calldata _initData
    ) external reinitializer(2) {
        // Silences the unused function parameter warning.
        _previousProtocolVersion;
        _initData;

        // Revert because this is a placeholder until this contract requires reinitialization.
        revert();
    }

    /// @inheritdoc IPluginRepo
    function createVersion(
        uint8 _release,
        address _pluginSetup,
        bytes calldata _buildMetadata,
        bytes calldata _releaseMetadata
    ) external auth(MAINTAINER_PERMISSION_ID) {
        if (!_pluginSetup.supportsInterface(type(IPluginSetup).interfaceId)) {
            revert InvalidPluginSetupInterface();
        }

        if (_release == 0) {
            revert ReleaseZeroNotAllowed();
        }

        // Check that the release number is not incremented by more than one
        if (_release - latestRelease > 1) {
            revert InvalidReleaseIncrement({latestRelease: latestRelease, newRelease: _release});
        }

        if (_release > latestRelease) {
            latestRelease = _release;

            if (_releaseMetadata.length == 0) {
                revert EmptyReleaseMetadata();
            }
        }

        // Make sure the same plugin setup wasn't used in previous releases.
        Version storage version = versions[latestTagHashForPluginSetup[_pluginSetup]];
        if (version.tag.release != 0 && version.tag.release != _release) {
            revert PluginSetupAlreadyInPreviousRelease(
                version.tag.release,
                version.tag.build,
                _pluginSetup
            );
        }

        uint16 build = ++buildsPerRelease[_release];

        Tag memory tag = Tag(_release, build);
        bytes32 _tagHash = tagHash(tag);

        versions[_tagHash] = Version(tag, _pluginSetup, _buildMetadata);

        latestTagHashForPluginSetup[_pluginSetup] = _tagHash;

        emit VersionCreated({
            release: _release,
            build: build,
            pluginSetup: _pluginSetup,
            buildMetadata: _buildMetadata
        });

        if (_releaseMetadata.length > 0) {
            emit ReleaseMetadataUpdated(_release, _releaseMetadata);
        }
    }

    /// @inheritdoc IPluginRepo
    function updateReleaseMetadata(
        uint8 _release,
        bytes calldata _releaseMetadata
    ) external auth(MAINTAINER_PERMISSION_ID) {
        if (_release == 0) {
            revert ReleaseZeroNotAllowed();
        }

        if (_release > latestRelease) {
            revert ReleaseDoesNotExist();
        }

        if (_releaseMetadata.length == 0) {
            revert EmptyReleaseMetadata();
        }

        emit ReleaseMetadataUpdated(_release, _releaseMetadata);
    }

    /// @notice Returns the latest version for a given release number.
    /// @param _release The release number.
    /// @return The latest version of this release.
    function getLatestVersion(uint8 _release) public view returns (Version memory) {
        uint16 latestBuild = uint16(buildsPerRelease[_release]);
        return getVersion(tagHash(Tag(_release, latestBuild)));
    }

    /// @notice Returns the latest version for a given plugin setup.
    /// @param _pluginSetup The plugin setup address
    /// @return The latest version associated with the plugin Setup.
    function getLatestVersion(address _pluginSetup) public view returns (Version memory) {
        return getVersion(latestTagHashForPluginSetup[_pluginSetup]);
    }

    /// @notice Returns the version associated with a tag.
    /// @param _tag The version tag.
    /// @return The version associated with the tag.
    function getVersion(Tag calldata _tag) public view returns (Version memory) {
        return getVersion(tagHash(_tag));
    }

    /// @notice Returns the version for a tag hash.
    /// @param _tagHash The tag hash.
    /// @return The version associated with a tag hash.
    function getVersion(bytes32 _tagHash) public view returns (Version memory) {
        Version storage version = versions[_tagHash];

        if (version.tag.release == 0) {
            revert VersionHashDoesNotExist(_tagHash);
        }

        return version;
    }

    /// @notice Gets the total number of builds for a given release number.
    /// @param _release The release number.
    /// @return The number of builds of this release.
    function buildCount(uint8 _release) public view returns (uint256) {
        return buildsPerRelease[_release];
    }

    /// @notice The hash of the version tag obtained from the packed, bytes-encoded release and build number.
    /// @param _tag The version tag.
    /// @return The version tag hash.
    function tagHash(Tag memory _tag) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(_tag.release, _tag.build));
    }

    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).
    /// @dev The caller must have the `UPGRADE_REPO_PERMISSION_ID` permission.
    function _authorizeUpgrade(
        address
    ) internal virtual override auth(UPGRADE_REPO_PERMISSION_ID) {}

    /// @notice Checks if this or the parent contract supports an interface by its ID.
    /// @param _interfaceId The ID of the interface.
    /// @return Returns `true` if the interface is supported.
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IPluginRepo).interfaceId ||
            _interfaceId == type(IProtocolVersion).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[46] private __gap;
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/PluginRepoFactory.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {IProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol";
import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {ProxyLib} from "@aragon/osx-commons-contracts/src/utils/deployment/ProxyLib.sol";
import {PluginRepoRegistry} from "./PluginRepoRegistry.sol";
import {PluginRepo} from "./PluginRepo.sol";

/// @title PluginRepoFactory
/// @author Aragon X - 2022-2023
/// @notice This contract creates `PluginRepo` proxies and registers them on a `PluginRepoRegistry` contract.
/// @custom:security-contact sirt@aragon.org
contract PluginRepoFactory is ERC165, ProtocolVersion {
    using ProxyLib for address;

    /// @notice The Aragon plugin registry contract.
    PluginRepoRegistry public pluginRepoRegistry;

    /// @notice The address of the `PluginRepo` base contract to proxy to..
    address public pluginRepoBase;

    /// @notice Initializes the addresses of the Aragon plugin registry and `PluginRepo` base contract to proxy to.
    /// @param _pluginRepoRegistry The aragon plugin registry address.
    constructor(PluginRepoRegistry _pluginRepoRegistry) {
        pluginRepoRegistry = _pluginRepoRegistry;

        pluginRepoBase = address(new PluginRepo());
    }

    /// @notice Checks if this or the parent contract supports an interface by its ID.
    /// @param _interfaceId The ID of the interface.
    /// @return Returns `true` if the interface is supported.
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IProtocolVersion).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @notice Creates a plugin repository proxy pointing to the `pluginRepoBase` implementation and registers it in the Aragon plugin registry.
    /// @param _subdomain The plugin repository subdomain.
    /// @param _initialOwner The plugin maintainer address.
    function createPluginRepo(
        string calldata _subdomain,
        address _initialOwner
    ) external returns (PluginRepo) {
        return _createPluginRepo(_subdomain, _initialOwner);
    }

    /// @notice Creates and registers a `PluginRepo` with an ENS subdomain and publishes an initial version `1.1`.
    /// @param _subdomain The plugin repository subdomain.
    /// @param _pluginSetup The plugin factory contract associated with the plugin version.
    /// @param _maintainer The maintainer of the plugin repo. This address has permission to update metadata, upgrade the repo logic, and manage the repo permissions.
    /// @param _releaseMetadata The release metadata URI.
    /// @param _buildMetadata The build metadata URI.
    /// @dev After the creation of the `PluginRepo` and release of the first version by the factory, ownership is transferred to the `_maintainer` address.
    function createPluginRepoWithFirstVersion(
        string calldata _subdomain,
        address _pluginSetup,
        address _maintainer,
        bytes memory _releaseMetadata,
        bytes memory _buildMetadata
    ) external returns (PluginRepo pluginRepo) {
        // Sets `address(this)` as initial owner which is later replaced with the maintainer address.
        pluginRepo = _createPluginRepo(_subdomain, address(this));

        pluginRepo.createVersion(1, _pluginSetup, _buildMetadata, _releaseMetadata);

        // Setup permissions and transfer ownership from `address(this)` to `_maintainer`.
        _setPluginRepoPermissions(pluginRepo, _maintainer);
    }

    /// @notice Set the final permissions for the published plugin repository maintainer. All permissions are revoked from the plugin factory and granted to the specified plugin maintainer.
    /// @param pluginRepo The plugin repository instance just created.
    /// @param maintainer The plugin maintainer address.
    /// @dev The plugin maintainer is granted the `MAINTAINER_PERMISSION_ID`, `UPGRADE_REPO_PERMISSION_ID`, and `ROOT_PERMISSION_ID`.
    function _setPluginRepoPermissions(PluginRepo pluginRepo, address maintainer) internal {
        // Set permissions on the `PluginRepo`s `PermissionManager`
        PermissionLib.SingleTargetPermission[]
            memory items = new PermissionLib.SingleTargetPermission[](6);

        bytes32 rootPermissionID = pluginRepo.ROOT_PERMISSION_ID();
        bytes32 maintainerPermissionID = pluginRepo.MAINTAINER_PERMISSION_ID();
        bytes32 upgradePermissionID = pluginRepo.UPGRADE_REPO_PERMISSION_ID();

        // Grant the plugin maintainer all the permissions required
        items[0] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            maintainer,
            maintainerPermissionID
        );
        items[1] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            maintainer,
            upgradePermissionID
        );
        items[2] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            maintainer,
            rootPermissionID
        );

        // Revoke permissions from the plugin repository factory (`address(this)`).
        items[3] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Revoke,
            address(this),
            rootPermissionID
        );
        items[4] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Revoke,
            address(this),
            maintainerPermissionID
        );
        items[5] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Revoke,
            address(this),
            upgradePermissionID
        );

        pluginRepo.applySingleTargetPermissions(address(pluginRepo), items);
    }

    /// @notice Internal method creating a `PluginRepo` via the [ERC-1967](https://eips.ethereum.org/EIPS/eip-1967) proxy pattern from the provided base contract and registering it in the Aragon plugin registry.
    /// @dev Passing an empty `_subdomain` will cause the transaction to revert.
    /// @param _subdomain The plugin repository subdomain.
    /// @param _initialOwner The initial owner address.
    function _createPluginRepo(
        string calldata _subdomain,
        address _initialOwner
    ) internal returns (PluginRepo pluginRepo) {
        pluginRepo = PluginRepo(
            pluginRepoBase.deployUUPSProxy(abi.encodeCall(PluginRepo.initialize, (_initialOwner)))
        );

        pluginRepoRegistry.registerPluginRepo(_subdomain, address(pluginRepo));
    }
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/IPluginRepo.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @title IPluginRepo
/// @author Aragon X - 2022-2023
/// @notice The interface required for a plugin repository.
/// @custom:security-contact sirt@aragon.org
interface IPluginRepo {
    /// @notice Updates the metadata for release with content `@fromHex(_releaseMetadata)`.
    /// @param _release The release number.
    /// @param _releaseMetadata The release metadata URI.
    function updateReleaseMetadata(uint8 _release, bytes calldata _releaseMetadata) external;

    /// @notice Creates a new plugin version as the latest build for an existing release number or the first build for a new release number for the provided `PluginSetup` contract address and metadata.
    /// @param _release The release number.
    /// @param _pluginSetupAddress The address of the plugin setup contract.
    /// @param _buildMetadata The build metadata URI.
    /// @param _releaseMetadata The release metadata URI.
    function createVersion(
        uint8 _release,
        address _pluginSetupAddress,
        bytes calldata _buildMetadata,
        bytes calldata _releaseMetadata
    ) external;

    /// @notice Emitted if the same plugin setup exists in previous releases.
    /// @param release The release number.
    /// @param build The build number.
    /// @param pluginSetup The address of the plugin setup contract.
    /// @param buildMetadata The build metadata URI.
    event VersionCreated(
        uint8 release,
        uint16 build,
        address indexed pluginSetup,
        bytes buildMetadata
    );

    /// @notice Emitted when a release's metadata was updated.
    /// @param release The release number.
    /// @param releaseMetadata The release metadata URI.
    event ReleaseMetadataUpdated(uint8 release, bytes releaseMetadata);
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/PluginRepoRegistry.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";
import {ENSSubdomainRegistrar} from "../../utils/ens/ENSSubdomainRegistrar.sol";
import {InterfaceBasedRegistry} from "../../utils/InterfaceBasedRegistry.sol";
import {isSubdomainValid} from "../../utils/RegistryUtils.sol";
import {IPluginRepo} from "./IPluginRepo.sol";

/// @title PluginRepoRegistry
/// @author Aragon X - 2022-2023
/// @notice This contract maintains an address-based registry of plugin repositories in the Aragon App DAO framework.
/// @custom:security-contact sirt@aragon.org
contract PluginRepoRegistry is InterfaceBasedRegistry, ProtocolVersion {
    /// @notice The ID of the permission required to call the `register` function.
    bytes32 public constant REGISTER_PLUGIN_REPO_PERMISSION_ID =
        keccak256("REGISTER_PLUGIN_REPO_PERMISSION");

    /// @notice The ENS subdomain registrar registering the PluginRepo subdomains.
    ENSSubdomainRegistrar public subdomainRegistrar;

    /// @notice Emitted if a new plugin repository is registered.
    /// @param subdomain The subdomain of the plugin repository.
    /// @param pluginRepo The address of the plugin repository.
    event PluginRepoRegistered(string subdomain, address pluginRepo);

    /// @notice Thrown if the plugin subdomain doesn't match the regex `[0-9a-z\-]`
    error InvalidPluginSubdomain(string subdomain);

    /// @notice Thrown if the subdomain is present, but registrar is address(0).
    error ENSNotSupported();

    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract by setting calling the `InterfaceBasedRegistry` base class initialize method.
    /// @param _dao The address of the managing DAO.
    /// @param _subdomainRegistrar The `ENSSubdomainRegistrar` where `ENS` subdomain will be registered.
    function initialize(IDAO _dao, ENSSubdomainRegistrar _subdomainRegistrar) external initializer {
        bytes4 pluginRepoInterfaceId = type(IPluginRepo).interfaceId;
        __InterfaceBasedRegistry_init(_dao, pluginRepoInterfaceId);

        subdomainRegistrar = _subdomainRegistrar;
    }

    /// @notice Registers a plugin repository with a subdomain and address.
    /// @dev If subdomain is empty, registration on ENS is skipped.
    /// @param subdomain The subdomain of the PluginRepo.
    /// @param pluginRepo The address of the PluginRepo contract.
    function registerPluginRepo(
        string calldata subdomain,
        address pluginRepo
    ) external auth(REGISTER_PLUGIN_REPO_PERMISSION_ID) {
        if (bytes(subdomain).length > 0) {
            if (address(subdomainRegistrar) == address(0)) {
                revert ENSNotSupported();
            }

            if (!isSubdomainValid(subdomain)) {
                revert InvalidPluginSubdomain({subdomain: subdomain});
            }

            bytes32 labelhash = keccak256(bytes(subdomain));
            subdomainRegistrar.registerSubnode(labelhash, pluginRepo);
        }

        _register(pluginRepo);

        emit PluginRepoRegistered(subdomain, pluginRepo);
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[49] private __gap;
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/placeholder/placeholder-build-metadata.json ###
{
  "ui": "",
  "change": "",
  "pluginSetup": {
    "prepareInstallation": "",
    "prepareUpdate": "",
    "prepareUninstallation": ""
  }
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/repo/placeholder/PlaceholderSetup.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";

/// @title PlaceholderSetup
/// @author Aragon X - 2023
/// @notice A placeholder setup contract for outdated plugin builds. When moving plugin repos to new chains or layers, where only the latest release and build should be available, this placeholder can be used to populate previous builds.
/// @custom:security-contact sirt@aragon.org
contract PlaceholderSetup is PluginSetup {
    /// @notice Thrown if the dummy is used.
    error PlaceholderSetupCannotBeUsed();

    constructor() PluginSetup(address(0)) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address /*_dao*/,
        bytes calldata /*_data*/
    ) external pure returns (address /*plugin*/, PreparedSetupData memory /*preparedSetupData*/) {
        revert PlaceholderSetupCannotBeUsed();
    }

    /// @inheritdoc IPluginSetup
    function prepareUninstallation(
        address /*_dao*/,
        SetupPayload calldata /*_payload*/
    ) external pure returns (PermissionLib.MultiTargetPermission[] memory /*permissions*/) {
        revert PlaceholderSetupCannotBeUsed();
    }
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/setup/PluginSetupProcessor.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC165Checker} from "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol";

import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";
import {DAO} from "../../../core/dao/DAO.sol";
import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {PluginUUPSUpgradeable} from "@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol";
import {IPlugin} from "@aragon/osx-commons-contracts/src/plugin/IPlugin.sol";

import {PluginRepoRegistry} from "../repo/PluginRepoRegistry.sol";
import {PluginRepo} from "../repo/PluginRepo.sol";

import {PluginSetupRef, hashHelpers, hashPermissions, _getPreparedSetupId, _getAppliedSetupId, _getPluginInstallationId, PreparationType} from "./PluginSetupProcessorHelpers.sol";

/// @title PluginSetupProcessor
/// @author Aragon X - 2022-2023
/// @notice This contract processes the preparation and application of plugin setups (installation, update, uninstallation) on behalf of a requesting DAO.
/// @dev This contract is temporarily granted the `ROOT_PERMISSION_ID` permission on the applying DAO and therefore is highly security critical.
/// @custom:security-contact sirt@aragon.org
contract PluginSetupProcessor is ProtocolVersion {
    using ERC165Checker for address;

    /// @notice The ID of the permission required to call the `applyInstallation` function.
    bytes32 public constant APPLY_INSTALLATION_PERMISSION_ID =
        keccak256("APPLY_INSTALLATION_PERMISSION");

    /// @notice The ID of the permission required to call the `applyUpdate` function.
    bytes32 public constant APPLY_UPDATE_PERMISSION_ID = keccak256("APPLY_UPDATE_PERMISSION");

    /// @notice The ID of the permission required to call the `applyUninstallation` function.
    bytes32 public constant APPLY_UNINSTALLATION_PERMISSION_ID =
        keccak256("APPLY_UNINSTALLATION_PERMISSION");

    /// @notice The hash obtained from the bytes-encoded empty array to be used for UI updates being required to submit an empty permission array.
    /// @dev The hash is computed via `keccak256(abi.encode([]))`.
    bytes32 private constant EMPTY_ARRAY_HASH =
        0x569e75fc77c1a856f6daaf9e69d8a9566ca34aa47f9133711ce065a571af0cfd;

    /// @notice The hash obtained from the bytes-encoded zero value.
    /// @dev The hash is computed via `keccak256(abi.encode(0))`.
    bytes32 private constant ZERO_BYTES_HASH =
        0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;

    /// @notice A struct containing information related to plugin setups that have been applied.
    /// @param blockNumber The block number at which the `applyInstallation`, `applyUpdate` or `applyUninstallation` was executed.
    /// @param currentAppliedSetupId The current setup id that plugin holds. Needed to confirm that `prepareUpdate` or `prepareUninstallation` happens for the plugin's current/valid dependencies.
    /// @param preparedSetupIdToBlockNumber The mapping between prepared setup IDs and block numbers at which `prepareInstallation`, `prepareUpdate` or `prepareUninstallation` was executed.
    struct PluginState {
        uint256 blockNumber;
        bytes32 currentAppliedSetupId;
        mapping(bytes32 => uint256) preparedSetupIdToBlockNumber;
    }

    /// @notice A mapping between the plugin installation ID (obtained from the DAO and plugin address) and the plugin state information.
    /// @dev This variable is public on purpose to allow future versions to access and migrate the storage.
    mapping(bytes32 => PluginState) public states;

    /// @notice The struct containing the parameters for the `prepareInstallation` function.
    /// @param pluginSetupRef The reference to the plugin setup to be used for the installation.
    /// @param data The bytes-encoded data containing the input parameters for the installation preparation as specified in the corresponding ABI on the version's metadata.
    struct PrepareInstallationParams {
        PluginSetupRef pluginSetupRef;
        bytes data;
    }

    /// @notice The struct containing the parameters for the `applyInstallation` function.
    /// @param pluginSetupRef The reference to the plugin setup used for the installation.
    /// @param plugin The address of the plugin contract to be installed.
    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the DAO.
    /// @param helpersHash The hash of helpers that were deployed in `prepareInstallation`. This helps to derive the setup ID.
    struct ApplyInstallationParams {
        PluginSetupRef pluginSetupRef;
        address plugin;
        PermissionLib.MultiTargetPermission[] permissions;
        bytes32 helpersHash;
    }

    /// @notice The struct containing the parameters for the `prepareUpdate` function.
    /// @param currentVersionTag The tag of the current plugin version to update from.
    /// @param newVersionTag The tag of the new plugin version to update to.
    /// @param pluginSetupRepo The plugin setup repository address on which the plugin exists.
    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.
    ///  This includes the bytes-encoded data containing the input parameters for the update preparation as specified in the corresponding ABI on the version's metadata.
    struct PrepareUpdateParams {
        PluginRepo.Tag currentVersionTag;
        PluginRepo.Tag newVersionTag;
        PluginRepo pluginSetupRepo;
        IPluginSetup.SetupPayload setupPayload;
    }

    /// @notice The struct containing the parameters for the `applyUpdate` function.
    /// @param plugin The address of the plugin contract to be updated.
    /// @param pluginSetupRef The reference to the plugin setup used for the update.
    /// @param initData The encoded data (function selector and arguments) to be provided to `upgradeToAndCall`.
    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcessor` to the DAO.
    /// @param helpersHash The hash of helpers that were deployed in `prepareUpdate`. This helps to derive the setup ID.
    struct ApplyUpdateParams {
        address plugin;
        PluginSetupRef pluginSetupRef;
        bytes initData;
        PermissionLib.MultiTargetPermission[] permissions;
        bytes32 helpersHash;
    }

    /// @notice The struct containing the parameters for the `prepareUninstallation` function.
    /// @param pluginSetupRef The reference to the plugin setup to be used for the uninstallation.
    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.
    ///  This includes the bytes-encoded data containing the input parameters for the uninstallation preparation as specified in the corresponding ABI on the version's metadata.
    struct PrepareUninstallationParams {
        PluginSetupRef pluginSetupRef;
        IPluginSetup.SetupPayload setupPayload;
    }

    /// @notice The struct containing the parameters for the `applyInstallation` function.
    /// @param plugin The address of the plugin contract to be uninstalled.
    /// @param pluginSetupRef The reference to the plugin setup used for the uninstallation.
    /// @param permissions The array of multi-targeted permission operations to be applied by the `PluginSetupProcess.
    struct ApplyUninstallationParams {
        address plugin;
        PluginSetupRef pluginSetupRef;
        PermissionLib.MultiTargetPermission[] permissions;
    }

    /// @notice The plugin repo registry listing the `PluginRepo` contracts versioning the `PluginSetup` contracts.
    PluginRepoRegistry public repoRegistry;

    /// @notice Thrown if a setup is unauthorized and cannot be applied because of a missing permission of the associated DAO.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param caller The address (EOA or contract) that requested the application of a setup on the associated DAO.
    /// @param permissionId The permission identifier.
    /// @dev This is thrown if the `APPLY_INSTALLATION_PERMISSION_ID`, `APPLY_UPDATE_PERMISSION_ID`, or APPLY_UNINSTALLATION_PERMISSION_ID is missing.
    error SetupApplicationUnauthorized(address dao, address caller, bytes32 permissionId);

    /// @notice Thrown if a plugin is not upgradeable.
    /// @param plugin The address of the plugin contract.
    error PluginNonupgradeable(address plugin);

    /// @notice Thrown if the upgrade of an `UUPSUpgradeable` proxy contract (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)) failed.
    /// @param proxy The address of the proxy.
    /// @param implementation The address of the implementation contract.
    /// @param initData The initialization data to be passed to the upgradeable plugin contract via `upgradeToAndCall`.
    error PluginProxyUpgradeFailed(address proxy, address implementation, bytes initData);

    /// @notice Thrown if a contract does not support the `IPlugin` interface.
    /// @param plugin The address of the contract.
    error IPluginNotSupported(address plugin);

    /// @notice Thrown if a plugin repository does not exist on the plugin repo registry.
    error PluginRepoNonexistent();

    /// @notice Thrown if a plugin setup was already prepared indicated by the prepared setup ID.
    /// @param preparedSetupId The prepared setup ID.
    error SetupAlreadyPrepared(bytes32 preparedSetupId);

    /// @notice Thrown if a prepared setup ID is not eligible to be applied. This can happen if another setup has been already applied or if the setup wasn't prepared in the first place.
    /// @param preparedSetupId The prepared setup ID.
    error SetupNotApplicable(bytes32 preparedSetupId);

    /// @notice Thrown if the update version is invalid.
    /// @param currentVersionTag The tag of the current version to update from.
    /// @param newVersionTag The tag of the new version to update to.
    error InvalidUpdateVersion(PluginRepo.Tag currentVersionTag, PluginRepo.Tag newVersionTag);

    /// @notice Thrown if plugin is already installed and one tries to prepare or apply install on it.
    error PluginAlreadyInstalled();

    /// @notice Thrown if the applied setup ID resulting from the supplied setup payload does not match with the current applied setup ID.
    /// @param currentAppliedSetupId The current applied setup ID with which the data in the supplied payload must match.
    /// @param appliedSetupId The applied setup ID obtained from the data in the supplied setup payload.
    error InvalidAppliedSetupId(bytes32 currentAppliedSetupId, bytes32 appliedSetupId);

    /// @notice Emitted with a prepared plugin installation to store data relevant for the application step.
    /// @param sender The sender that prepared the plugin installation.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param preparedSetupId The prepared setup ID obtained from the supplied data.
    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.
    /// @param versionTag The version tag of the plugin setup of the prepared installation.
    /// @param data The bytes-encoded data containing the input parameters for the preparation as specified in the corresponding ABI on the version's metadata.
    /// @param plugin The address of the plugin contract.
    /// @param preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.
    event InstallationPrepared(
        address indexed sender,
        address indexed dao,
        bytes32 preparedSetupId,
        PluginRepo indexed pluginSetupRepo,
        PluginRepo.Tag versionTag,
        bytes data,
        address plugin,
        IPluginSetup.PreparedSetupData preparedSetupData
    );

    /// @notice Emitted after a plugin installation was applied.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param plugin The address of the plugin contract.
    /// @param preparedSetupId The prepared setup ID.
    /// @param appliedSetupId The applied setup ID.
    event InstallationApplied(
        address indexed dao,
        address indexed plugin,
        bytes32 preparedSetupId,
        bytes32 appliedSetupId
    );

    /// @notice Emitted with a prepared plugin update to store data relevant for the application step.
    /// @param sender The sender that prepared the plugin update.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param preparedSetupId The prepared setup ID.
    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.
    /// @param versionTag The version tag of the plugin setup of the prepared update.
    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.
    /// @param preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.
    /// @param initData The initialization data to be passed to the upgradeable plugin contract.
    event UpdatePrepared(
        address indexed sender,
        address indexed dao,
        bytes32 preparedSetupId,
        PluginRepo indexed pluginSetupRepo,
        PluginRepo.Tag versionTag,
        IPluginSetup.SetupPayload setupPayload,
        IPluginSetup.PreparedSetupData preparedSetupData,
        bytes initData
    );

    /// @notice Emitted after a plugin update was applied.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param plugin The address of the plugin contract.
    /// @param preparedSetupId The prepared setup ID.
    /// @param appliedSetupId The applied setup ID.
    event UpdateApplied(
        address indexed dao,
        address indexed plugin,
        bytes32 preparedSetupId,
        bytes32 appliedSetupId
    );

    /// @notice Emitted with a prepared plugin uninstallation to store data relevant for the application step.
    /// @param sender The sender that prepared the plugin uninstallation.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param preparedSetupId The prepared setup ID.
    /// @param pluginSetupRepo The repository storing the `PluginSetup` contracts of all versions of a plugin.
    /// @param versionTag The version tag of the plugin to used for install preparation.
    /// @param setupPayload The payload containing the plugin and helper contract addresses deployed in a preparation step as well as optional data to be consumed by the plugin setup.
    /// @param permissions The list of multi-targeted permission operations to be applied to the installing DAO.
    event UninstallationPrepared(
        address indexed sender,
        address indexed dao,
        bytes32 preparedSetupId,
        PluginRepo indexed pluginSetupRepo,
        PluginRepo.Tag versionTag,
        IPluginSetup.SetupPayload setupPayload,
        PermissionLib.MultiTargetPermission[] permissions
    );

    /// @notice Emitted after a plugin installation was applied.
    /// @param dao The address of the DAO to which the plugin belongs.
    /// @param plugin The address of the plugin contract.
    /// @param preparedSetupId The prepared setup ID.
    event UninstallationApplied(
        address indexed dao,
        address indexed plugin,
        bytes32 preparedSetupId
    );

    /// @notice A modifier to check if a caller has the permission to apply a prepared setup.
    /// @param _dao The address of the DAO.
    /// @param _permissionId The permission identifier.
    modifier canApply(address _dao, bytes32 _permissionId) {
        _canApply(_dao, _permissionId);
        _;
    }

    /// @notice Constructs the plugin setup processor by setting the associated plugin repo registry.
    /// @param _repoRegistry The plugin repo registry contract.
    constructor(PluginRepoRegistry _repoRegistry) {
        repoRegistry = _repoRegistry;
    }

    /// @notice Prepares the installation of a plugin.
    /// @param _dao The address of the installing DAO.
    /// @param _params The struct containing the parameters for the `prepareInstallation` function.
    /// @return plugin The prepared plugin contract address.
    /// @return preparedSetupData The data struct containing the array of helper contracts and permissions that the setup has prepared.
    function prepareInstallation(
        address _dao,
        PrepareInstallationParams calldata _params
    ) external returns (address plugin, IPluginSetup.PreparedSetupData memory preparedSetupData) {
        PluginRepo pluginSetupRepo = _params.pluginSetupRef.pluginSetupRepo;

        // Check that the plugin repository exists on the plugin repo registry.
        if (!repoRegistry.entries(address(pluginSetupRepo))) {
            revert PluginRepoNonexistent();
        }

        // reverts if not found
        PluginRepo.Version memory version = pluginSetupRepo.getVersion(
            _params.pluginSetupRef.versionTag
        );

        // Prepare the installation
        (plugin, preparedSetupData) = PluginSetup(version.pluginSetup).prepareInstallation(
            _dao,
            _params.data
        );

        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, plugin);

        bytes32 preparedSetupId = _getPreparedSetupId(
            _params.pluginSetupRef,
            hashPermissions(preparedSetupData.permissions),
            hashHelpers(preparedSetupData.helpers),
            bytes(""),
            PreparationType.Installation
        );

        PluginState storage pluginState = states[pluginInstallationId];

        // Check if this plugin is already installed.
        if (pluginState.currentAppliedSetupId != bytes32(0)) {
            revert PluginAlreadyInstalled();
        }

        // Check if this setup has already been prepared before and is pending.
        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {
            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});
        }

        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;

        emit InstallationPrepared({
            sender: msg.sender,
            dao: _dao,
            preparedSetupId: preparedSetupId,
            pluginSetupRepo: pluginSetupRepo,
            versionTag: _params.pluginSetupRef.versionTag,
            data: _params.data,
            plugin: plugin,
            preparedSetupData: preparedSetupData
        });

        return (plugin, preparedSetupData);
    }

    /// @notice Applies the permissions of a prepared installation to a DAO.
    /// @param _dao The address of the installing DAO.
    /// @param _params The struct containing the parameters for the `applyInstallation` function.
    function applyInstallation(
        address _dao,
        ApplyInstallationParams calldata _params
    ) external canApply(_dao, APPLY_INSTALLATION_PERMISSION_ID) {
        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);

        PluginState storage pluginState = states[pluginInstallationId];

        bytes32 preparedSetupId = _getPreparedSetupId(
            _params.pluginSetupRef,
            hashPermissions(_params.permissions),
            _params.helpersHash,
            bytes(""),
            PreparationType.Installation
        );

        // Check if this plugin is already installed.
        if (pluginState.currentAppliedSetupId != bytes32(0)) {
            revert PluginAlreadyInstalled();
        }

        validatePreparedSetupId(pluginInstallationId, preparedSetupId);

        bytes32 appliedSetupId = _getAppliedSetupId(_params.pluginSetupRef, _params.helpersHash);

        pluginState.currentAppliedSetupId = appliedSetupId;
        pluginState.blockNumber = block.number;

        // If the list of requested permission changes is not empty, process them.
        // Note, that this requires the `PluginSetupProcessor` to have the `ROOT_PERMISSION_ID` permission on the
        // installing DAO. Make sure this permission is only granted TEMPORARILY.
        if (_params.permissions.length > 0) {
            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);
        }

        emit InstallationApplied({
            dao: _dao,
            plugin: _params.plugin,
            preparedSetupId: preparedSetupId,
            appliedSetupId: appliedSetupId
        });
    }

    /// @notice Prepares the update of an UUPS upgradeable plugin.
    /// @param _dao The address of the DAO For which preparation of update happens.
    /// @param _params The struct containing the parameters for the `prepareUpdate` function.
    /// @return initData The initialization data to be passed to upgradeable contracts when the update is applied
    /// @return preparedSetupData The data struct containing the array of helper contracts and permissions that the setup has prepared.
    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happened) on which the update is prepared for.
    function prepareUpdate(
        address _dao,
        PrepareUpdateParams calldata _params
    )
        external
        returns (bytes memory initData, IPluginSetup.PreparedSetupData memory preparedSetupData)
    {
        if (
            _params.currentVersionTag.release != _params.newVersionTag.release ||
            _params.currentVersionTag.build >= _params.newVersionTag.build
        ) {
            revert InvalidUpdateVersion({
                currentVersionTag: _params.currentVersionTag,
                newVersionTag: _params.newVersionTag
            });
        }

        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.setupPayload.plugin);

        PluginState storage pluginState = states[pluginInstallationId];

        bytes32 currentHelpersHash = hashHelpers(_params.setupPayload.currentHelpers);

        bytes32 appliedSetupId = _getAppliedSetupId(
            PluginSetupRef(_params.currentVersionTag, _params.pluginSetupRepo),
            currentHelpersHash
        );

        // The following check implicitly confirms that plugin is currently installed.
        // Otherwise, `currentAppliedSetupId` would not be set.
        if (pluginState.currentAppliedSetupId != appliedSetupId) {
            revert InvalidAppliedSetupId({
                currentAppliedSetupId: pluginState.currentAppliedSetupId,
                appliedSetupId: appliedSetupId
            });
        }

        PluginRepo.Version memory currentVersion = _params.pluginSetupRepo.getVersion(
            _params.currentVersionTag
        );

        PluginRepo.Version memory newVersion = _params.pluginSetupRepo.getVersion(
            _params.newVersionTag
        );

        bytes32 preparedSetupId;

        // If the current and new plugin setup are identical, this is an UI update.
        // In this case, the permission hash is set to the empty array hash and the `prepareUpdate` call is skipped to avoid side effects.
        if (currentVersion.pluginSetup == newVersion.pluginSetup) {
            preparedSetupId = _getPreparedSetupId(
                PluginSetupRef(_params.newVersionTag, _params.pluginSetupRepo),
                EMPTY_ARRAY_HASH,
                currentHelpersHash,
                bytes(""),
                PreparationType.Update
            );

            // Because UI updates do not change the plugin functionality, the array of helpers
            // associated with this plugin version `preparedSetupData.helpers` and being returned must
            // equal `_params.setupPayload.currentHelpers` returned by the previous setup step (installation or update )
            // that this update is transitioning from.
            preparedSetupData.helpers = _params.setupPayload.currentHelpers;
        } else {
            // Check that plugin is `PluginUUPSUpgradable`.
            if (!_params.setupPayload.plugin.supportsInterface(type(IPlugin).interfaceId)) {
                revert IPluginNotSupported({plugin: _params.setupPayload.plugin});
            }
            if (IPlugin(_params.setupPayload.plugin).pluginType() != IPlugin.PluginType.UUPS) {
                revert PluginNonupgradeable({plugin: _params.setupPayload.plugin});
            }

            // Prepare the update.
            (initData, preparedSetupData) = PluginSetup(newVersion.pluginSetup).prepareUpdate(
                _dao,
                _params.currentVersionTag.build,
                _params.setupPayload
            );

            preparedSetupId = _getPreparedSetupId(
                PluginSetupRef(_params.newVersionTag, _params.pluginSetupRepo),
                hashPermissions(preparedSetupData.permissions),
                hashHelpers(preparedSetupData.helpers),
                initData,
                PreparationType.Update
            );
        }

        // Check if this setup has already been prepared before and is pending.
        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {
            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});
        }

        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;

        // Avoid stack too deep.
        emitPrepareUpdateEvent(_dao, preparedSetupId, _params, preparedSetupData, initData);

        return (initData, preparedSetupData);
    }

    /// @notice Applies the permissions of a prepared update of an UUPS upgradeable proxy contract to a DAO.
    /// @param _dao The address of the updating DAO.
    /// @param _params The struct containing the parameters for the `applyUpdate` function.
    function applyUpdate(
        address _dao,
        ApplyUpdateParams calldata _params
    ) external canApply(_dao, APPLY_UPDATE_PERMISSION_ID) {
        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);

        PluginState storage pluginState = states[pluginInstallationId];

        bytes32 preparedSetupId = _getPreparedSetupId(
            _params.pluginSetupRef,
            hashPermissions(_params.permissions),
            _params.helpersHash,
            _params.initData,
            PreparationType.Update
        );

        validatePreparedSetupId(pluginInstallationId, preparedSetupId);

        bytes32 appliedSetupId = _getAppliedSetupId(_params.pluginSetupRef, _params.helpersHash);

        pluginState.blockNumber = block.number;
        pluginState.currentAppliedSetupId = appliedSetupId;

        PluginRepo.Version memory version = _params.pluginSetupRef.pluginSetupRepo.getVersion(
            _params.pluginSetupRef.versionTag
        );

        address currentImplementation = PluginUUPSUpgradeable(_params.plugin).implementation();
        address newImplementation = PluginSetup(version.pluginSetup).implementation();

        if (currentImplementation != newImplementation) {
            _upgradeProxy(_params.plugin, newImplementation, _params.initData);
        }

        // If the list of requested permission changes is not empty, process them.
        // Note, that this requires the `PluginSetupProcessor` to have the `ROOT_PERMISSION_ID` permission on the
        // updating DAO. Make sure this permission is only granted TEMPORARILY.
        if (_params.permissions.length > 0) {
            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);
        }

        emit UpdateApplied({
            dao: _dao,
            plugin: _params.plugin,
            preparedSetupId: preparedSetupId,
            appliedSetupId: appliedSetupId
        });
    }

    /// @notice Prepares the uninstallation of a plugin.
    /// @param _dao The address of the uninstalling DAO.
    /// @param _params The struct containing the parameters for the `prepareUninstallation` function.
    /// @return permissions The list of multi-targeted permission operations to be applied to the uninstalling DAO.
    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happened) on which the uninstallation was prepared for.
    function prepareUninstallation(
        address _dao,
        PrepareUninstallationParams calldata _params
    ) external returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.setupPayload.plugin);

        PluginState storage pluginState = states[pluginInstallationId];

        bytes32 appliedSetupId = _getAppliedSetupId(
            _params.pluginSetupRef,
            hashHelpers(_params.setupPayload.currentHelpers)
        );

        if (pluginState.currentAppliedSetupId != appliedSetupId) {
            revert InvalidAppliedSetupId({
                currentAppliedSetupId: pluginState.currentAppliedSetupId,
                appliedSetupId: appliedSetupId
            });
        }

        PluginRepo.Version memory version = _params.pluginSetupRef.pluginSetupRepo.getVersion(
            _params.pluginSetupRef.versionTag
        );

        permissions = PluginSetup(version.pluginSetup).prepareUninstallation(
            _dao,
            _params.setupPayload
        );

        bytes32 preparedSetupId = _getPreparedSetupId(
            _params.pluginSetupRef,
            hashPermissions(permissions),
            ZERO_BYTES_HASH,
            bytes(""),
            PreparationType.Uninstallation
        );

        // Check if this setup has already been prepared before and is pending.
        if (pluginState.blockNumber < pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {
            revert SetupAlreadyPrepared({preparedSetupId: preparedSetupId});
        }

        pluginState.preparedSetupIdToBlockNumber[preparedSetupId] = block.number;

        emit UninstallationPrepared({
            sender: msg.sender,
            dao: _dao,
            preparedSetupId: preparedSetupId,
            pluginSetupRepo: _params.pluginSetupRef.pluginSetupRepo,
            versionTag: _params.pluginSetupRef.versionTag,
            setupPayload: _params.setupPayload,
            permissions: permissions
        });
    }

    /// @notice Applies the permissions of a prepared uninstallation to a DAO.
    /// @param _dao The address of the DAO.
    /// @param _dao The address of the uninstalling DAO.
    /// @param _params The struct containing the parameters for the `applyUninstallation` function.
    /// @dev The list of `_params.setupPayload.currentHelpers` has to be specified in the same order as they were returned from previous setups preparation steps (the latest `prepareInstallation` or `prepareUpdate` step that has happened) on which the uninstallation was prepared for.
    function applyUninstallation(
        address _dao,
        ApplyUninstallationParams calldata _params
    ) external canApply(_dao, APPLY_UNINSTALLATION_PERMISSION_ID) {
        bytes32 pluginInstallationId = _getPluginInstallationId(_dao, _params.plugin);

        PluginState storage pluginState = states[pluginInstallationId];

        bytes32 preparedSetupId = _getPreparedSetupId(
            _params.pluginSetupRef,
            hashPermissions(_params.permissions),
            ZERO_BYTES_HASH,
            bytes(""),
            PreparationType.Uninstallation
        );

        validatePreparedSetupId(pluginInstallationId, preparedSetupId);

        // Since the plugin is uninstalled, only the current block number must be updated.
        pluginState.blockNumber = block.number;
        pluginState.currentAppliedSetupId = bytes32(0);

        // If the list of requested permission changes is not empty, process them.
        // Note, that this requires the `PluginSetupProcessor` to have the `ROOT_PERMISSION_ID` permission on the
        // uninstalling DAO. Make sure this permission is only granted TEMPORARILY.
        if (_params.permissions.length > 0) {
            DAO(payable(_dao)).applyMultiTargetPermissions(_params.permissions);
        }

        emit UninstallationApplied({
            dao: _dao,
            plugin: _params.plugin,
            preparedSetupId: preparedSetupId
        });
    }

    /// @notice Validates that a setup ID can be applied for `applyInstallation`, `applyUpdate`, or `applyUninstallation`.
    /// @param pluginInstallationId The plugin installation ID obtained from the hash of `abi.encode(daoAddress, pluginAddress)`.
    /// @param preparedSetupId The prepared setup ID to be validated.
    /// @dev If the block number stored in `states[pluginInstallationId].blockNumber` exceeds the one stored in `pluginState.preparedSetupIdToBlockNumber[preparedSetupId]`, the prepared setup with `preparedSetupId` is outdated and not applicable anymore.
    function validatePreparedSetupId(
        bytes32 pluginInstallationId,
        bytes32 preparedSetupId
    ) public view {
        PluginState storage pluginState = states[pluginInstallationId];
        if (pluginState.blockNumber >= pluginState.preparedSetupIdToBlockNumber[preparedSetupId]) {
            revert SetupNotApplicable({preparedSetupId: preparedSetupId});
        }
    }

    /// @notice Upgrades a UUPS upgradeable proxy contract (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).
    /// @param _proxy The address of the proxy.
    /// @param _implementation The address of the implementation contract.
    /// @param _initData The initialization data to be passed to the upgradeable plugin contract via `upgradeToAndCall`.
    function _upgradeProxy(
        address _proxy,
        address _implementation,
        bytes memory _initData
    ) private {
        if (_initData.length > 0) {
            try
                PluginUUPSUpgradeable(_proxy).upgradeToAndCall(_implementation, _initData)
            {} catch Error(string memory reason) {
                revert(reason);
            } catch (bytes memory /*lowLevelData*/) {
                revert PluginProxyUpgradeFailed({
                    proxy: _proxy,
                    implementation: _implementation,
                    initData: _initData
                });
            }
        } else {
            try PluginUUPSUpgradeable(_proxy).upgradeTo(_implementation) {} catch Error(
                string memory reason
            ) {
                revert(reason);
            } catch (bytes memory /*lowLevelData*/) {
                revert PluginProxyUpgradeFailed({
                    proxy: _proxy,
                    implementation: _implementation,
                    initData: _initData
                });
            }
        }
    }

    /// @notice Checks if a caller can apply a setup. The caller can be either the DAO to which the plugin setup is applied to or another account to which the DAO has granted the respective permission.
    /// @param _dao The address of the applying DAO.
    /// @param _permissionId The permission ID.
    function _canApply(address _dao, bytes32 _permissionId) private view {
        if (
            msg.sender != _dao &&
            !DAO(payable(_dao)).hasPermission(address(this), msg.sender, _permissionId, bytes(""))
        ) {
            revert SetupApplicationUnauthorized({
                dao: _dao,
                caller: msg.sender,
                permissionId: _permissionId
            });
        }
    }

    /// @notice A helper to emit the `UpdatePrepared` event from the supplied, structured data.
    /// @param _dao The address of the updating DAO.
    /// @param _preparedSetupId The prepared setup ID.
    /// @param _params The struct containing the parameters for the `prepareUpdate` function.
    /// @param _preparedSetupData The deployed plugin's relevant data which consists of helpers and permissions.
    /// @param _initData The initialization data to be passed to upgradeable contracts when the update is applied
    /// @dev This functions exists to avoid stack-too-deep errors.
    function emitPrepareUpdateEvent(
        address _dao,
        bytes32 _preparedSetupId,
        PrepareUpdateParams calldata _params,
        IPluginSetup.PreparedSetupData memory _preparedSetupData,
        bytes memory _initData
    ) private {
        emit UpdatePrepared({
            sender: msg.sender,
            dao: _dao,
            preparedSetupId: _preparedSetupId,
            pluginSetupRepo: _params.pluginSetupRepo,
            versionTag: _params.newVersionTag,
            setupPayload: _params.setupPayload,
            preparedSetupData: _preparedSetupData,
            initData: _initData
        });
    }
}


### File: /home/errick/core/packages/contracts/src/framework/plugin/setup/PluginSetupProcessorHelpers.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";
import {PluginRepo} from "../repo/PluginRepo.sol";

/// @notice The struct containing a reference to a plugin setup by specifying the containing plugin repository and the associated version tag.
/// @param versionTag The tag associated with the plugin setup version.
/// @param pluginSetupRepo The plugin setup repository.
struct PluginSetupRef {
    PluginRepo.Tag versionTag;
    PluginRepo pluginSetupRepo;
}

/// @notice The different types describing a prepared setup.
/// @param None The default indicating the lack of a preparation type.
/// @param Installation The prepared setup installs a new plugin.
/// @param Update The prepared setup updates an existing plugin.
/// @param Uninstallation The prepared setup uninstalls an existing plugin.
enum PreparationType {
    None,
    Installation,
    Update,
    Uninstallation
}

/// @notice Returns an ID for plugin installation by hashing the DAO and plugin address.
/// @param _dao The address of the DAO conducting the setup.
/// @param _plugin The plugin address.
/// @custom:security-contact sirt@aragon.org
function _getPluginInstallationId(address _dao, address _plugin) pure returns (bytes32) {
    return keccak256(abi.encode(_dao, _plugin));
}

/// @notice Returns an ID for prepared setup obtained from hashing characterizing elements.
/// @param _pluginSetupRef The reference of the plugin setup containing plugin setup repo and version tag.
/// @param _permissionsHash The hash of the permission operations requested by the setup.
/// @param _helpersHash The hash of the helper contract addresses.
/// @param _data The bytes-encoded initialize data for the upgrade that is returned by `prepareUpdate`.
/// @param _preparationType The type of preparation the plugin is currently undergoing. Without this, it is possible to call `applyUpdate` even after `applyInstallation` is called.
/// @return The prepared setup id.
/// @custom:security-contact sirt@aragon.org
function _getPreparedSetupId(
    PluginSetupRef memory _pluginSetupRef,
    bytes32 _permissionsHash,
    bytes32 _helpersHash,
    bytes memory _data,
    PreparationType _preparationType
) pure returns (bytes32) {
    return
        keccak256(
            abi.encode(
                _pluginSetupRef.versionTag,
                _pluginSetupRef.pluginSetupRepo,
                _permissionsHash,
                _helpersHash,
                keccak256(_data),
                _preparationType
            )
        );
}

/// @notice Returns an identifier for applied installations.
/// @param _pluginSetupRef The reference of the plugin setup containing plugin setup repo and version tag.
/// @param _helpersHash The hash of the helper contract addresses.
/// @return The applied setup id.
/// @custom:security-contact sirt@aragon.org
function _getAppliedSetupId(
    PluginSetupRef memory _pluginSetupRef,
    bytes32 _helpersHash
) pure returns (bytes32) {
    return
        keccak256(
            abi.encode(_pluginSetupRef.versionTag, _pluginSetupRef.pluginSetupRepo, _helpersHash)
        );
}

/// @notice Returns a hash of an array of helper addresses (contracts or EOAs).
/// @param _helpers The array of helper addresses (contracts or EOAs) to be hashed.
/// @custom:security-contact sirt@aragon.org
function hashHelpers(address[] memory _helpers) pure returns (bytes32) {
    return keccak256(abi.encode(_helpers));
}

/// @notice Returns a hash of an array of multi-targeted permission operations.
/// @param _permissions The array of of multi-targeted permission operations.
/// @return The hash of the array of permission operations.
/// @custom:security-contact sirt@aragon.org
function hashPermissions(
    PermissionLib.MultiTargetPermission[] memory _permissions
) pure returns (bytes32) {
    return keccak256(abi.encode(_permissions));
}


### File: /home/errick/core/packages/contracts/src/framework/utils/RegistryUtils.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @notice Validates that a subdomain name is composed only from characters in the allowed character set:
/// - the lowercase letters `a-z`
/// - the digits `0-9`
/// - the hyphen `-`
/// @dev This function allows empty (zero-length) subdomains. If this should not be allowed, make sure to add a respective check when using this function in your code.
/// @param subDomain The name of the DAO.
/// @return `true` if the name is valid or `false` if at least one char is invalid.
/// @dev Aborts on the first invalid char found.
/// @custom:security-contact sirt@aragon.org
function isSubdomainValid(string calldata subDomain) pure returns (bool) {
    bytes calldata nameBytes = bytes(subDomain);
    uint256 nameLength = nameBytes.length;
    for (uint256 i; i < nameLength; i++) {
        uint8 char = uint8(nameBytes[i]);

        // if char is between a-z
        if (char > 96 && char < 123) {
            continue;
        }

        // if char is between 0-9
        if (char > 47 && char < 58) {
            continue;
        }

        // if char is -
        if (char == 45) {
            continue;
        }

        // invalid if one char doesn't work with the rules above
        return false;
    }
    return true;
}


### File: /home/errick/core/packages/contracts/src/framework/utils/InterfaceBasedRegistry.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {ERC165CheckerUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol";

import {DaoAuthorizableUpgradeable} from "@aragon/osx-commons-contracts/src/permission/auth/DaoAuthorizableUpgradeable.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

/// @title InterfaceBasedRegistry
/// @author Aragon X - 2022-2023
/// @notice An [ERC-165](https://eips.ethereum.org/EIPS/eip-165)-based registry for contracts.
/// @custom:security-contact sirt@aragon.org
abstract contract InterfaceBasedRegistry is UUPSUpgradeable, DaoAuthorizableUpgradeable {
    using ERC165CheckerUpgradeable for address;

    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.
    bytes32 public constant UPGRADE_REGISTRY_PERMISSION_ID =
        keccak256("UPGRADE_REGISTRY_PERMISSION");

    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID that the target contracts being registered must support.
    bytes4 public targetInterfaceId;

    /// @notice The mapping containing the registry entries returning true for registered contract addresses.
    mapping(address => bool) public entries;

    /// @notice Thrown if the contract is already registered.
    /// @param registrant The address of the contract to be registered.
    error ContractAlreadyRegistered(address registrant);

    /// @notice Thrown if the contract does not support the required interface.
    /// @param registrant The address of the contract to be registered.
    error ContractInterfaceInvalid(address registrant);

    /// @notice Thrown if the contract does not support ERC165.
    /// @param registrant The address of the contract.
    error ContractERC165SupportInvalid(address registrant);

    /// @notice Initializes the component.
    /// @dev This is required for the UUPS upgradeability pattern.
    /// @param _managingDao The interface of the DAO managing the components permissions.
    /// @param _targetInterfaceId The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface id of the contracts to be registered.
    function __InterfaceBasedRegistry_init(
        IDAO _managingDao,
        bytes4 _targetInterfaceId
    ) internal virtual onlyInitializing {
        __DaoAuthorizableUpgradeable_init(_managingDao);

        targetInterfaceId = _targetInterfaceId;
    }

    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).
    /// @dev The caller must have the `UPGRADE_REGISTRY_PERMISSION_ID` permission.
    function _authorizeUpgrade(
        address
    ) internal virtual override auth(UPGRADE_REGISTRY_PERMISSION_ID) {}

    /// @notice Register an [ERC-165](https://eips.ethereum.org/EIPS/eip-165) contract address.
    /// @dev The managing DAO needs to grant REGISTER_PERMISSION_ID to registrar.
    /// @param _registrant The address of an [ERC-165](https://eips.ethereum.org/EIPS/eip-165) contract.
    function _register(address _registrant) internal {
        if (entries[_registrant]) {
            revert ContractAlreadyRegistered({registrant: _registrant});
        }

        // Will revert if address is not a contract or doesn't fully support targetInterfaceId + ERC165.
        if (!_registrant.supportsInterface(targetInterfaceId)) {
            revert ContractInterfaceInvalid(_registrant);
        }

        entries[_registrant] = true;
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[48] private __gap;
}


### File: /home/errick/core/packages/contracts/src/framework/utils/ens/ENSSubdomainRegistrar.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import "@ensdomains/ens-contracts/contracts/registry/ENS.sol";
import "@ensdomains/ens-contracts/contracts/resolvers/Resolver.sol";

import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";

import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {DaoAuthorizableUpgradeable} from "@aragon/osx-commons-contracts/src/permission/auth/DaoAuthorizableUpgradeable.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

/// @title ENSSubdomainRegistrar
/// @author Aragon X - 2022-2023
/// @notice This contract registers ENS subdomains under a parent domain specified in the initialization process and maintains ownership of the subdomain since only the resolver address is set. This contract must either be the domain node owner or an approved operator of the node owner. The default resolver being used is the one specified in the parent domain.
/// @custom:security-contact sirt@aragon.org
contract ENSSubdomainRegistrar is UUPSUpgradeable, DaoAuthorizableUpgradeable, ProtocolVersion {
    /// @notice The ID of the permission required to call the `_authorizeUpgrade` function.
    bytes32 public constant UPGRADE_REGISTRAR_PERMISSION_ID =
        keccak256("UPGRADE_REGISTRAR_PERMISSION");

    /// @notice The ID of the permission required to call the `registerSubnode` and `setDefaultResolver` function.
    bytes32 public constant REGISTER_ENS_SUBDOMAIN_PERMISSION_ID =
        keccak256("REGISTER_ENS_SUBDOMAIN_PERMISSION");

    /// @notice The ENS registry contract
    ENS public ens;

    /// @notice The namehash of the domain on which subdomains are registered.
    bytes32 public node;

    /// @notice The address of the ENS resolver resolving the names to an address.
    address public resolver;

    /// @notice Thrown if the subnode is already registered.
    /// @param subnode The subnode namehash.
    /// @param nodeOwner The node owner address.
    error AlreadyRegistered(bytes32 subnode, address nodeOwner);

    /// @notice Thrown if node's resolver is invalid.
    /// @param node The node namehash.
    /// @param resolver The node resolver address.
    error InvalidResolver(bytes32 node, address resolver);

    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the component by
    /// - checking that the contract is the domain node owner or an approved operator
    /// - initializing the underlying component
    /// - registering the [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID
    /// - setting the ENS contract, the domain node hash, and resolver.
    /// @param _managingDao The interface of the DAO managing the components permissions.
    /// @param _ens The interface of the ENS registry to be used.
    /// @param _node The ENS parent domain node under which the subdomains are to be registered.
    function initialize(IDAO _managingDao, ENS _ens, bytes32 _node) external initializer {
        __DaoAuthorizableUpgradeable_init(_managingDao);

        ens = _ens;
        node = _node;

        address nodeResolver = ens.resolver(_node);

        if (nodeResolver == address(0)) {
            revert InvalidResolver({node: _node, resolver: nodeResolver});
        }

        resolver = nodeResolver;
    }

    /// @notice Internal method authorizing the upgrade of the contract via the [upgradeability mechanism for UUPS proxies](https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable) (see [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822)).
    /// @dev The caller must have the `UPGRADE_REGISTRAR_PERMISSION_ID` permission.
    function _authorizeUpgrade(
        address
    ) internal virtual override auth(UPGRADE_REGISTRAR_PERMISSION_ID) {}

    /// @notice Registers a new subdomain with this registrar as the owner and set the target address in the resolver.
    /// @dev It reverts with no message if this contract isn't the owner nor an approved operator for the given node.
    /// @param _label The labelhash of the subdomain name.
    /// @param _targetAddress The address to which the subdomain resolves.
    function registerSubnode(
        bytes32 _label,
        address _targetAddress
    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {
        bytes32 subnode = keccak256(abi.encodePacked(node, _label));
        address currentOwner = ens.owner(subnode);

        if (currentOwner != address(0)) {
            revert AlreadyRegistered(subnode, currentOwner);
        }

        ens.setSubnodeOwner(node, _label, address(this));
        ens.setResolver(subnode, resolver);
        Resolver(resolver).setAddr(subnode, _targetAddress);
    }

    /// @notice Sets the default resolver contract address that the subdomains being registered will use.
    /// @param _resolver The resolver contract to be used.
    function setDefaultResolver(
        address _resolver
    ) external auth(REGISTER_ENS_SUBDOMAIN_PERMISSION_ID) {
        if (_resolver == address(0)) {
            revert InvalidResolver({node: node, resolver: _resolver});
        }

        resolver = _resolver;
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[47] private __gap;
}


### File: /home/errick/core/packages/contracts/src/framework/utils/ens/ENSMigration.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later
// This is a migration file as suggested here https://docs.ens.domains/deploying-ens-on-a-private-chain#migration-file-example to compile the contracts and make their artifacts available in our tests.

pragma solidity ^0.8.28;

import "@ensdomains/ens-contracts/contracts/registry/ENSRegistry.sol";
import "@ensdomains/ens-contracts/contracts/resolvers/PublicResolver.sol";

contract Dummy {}


### File: /home/errick/core/packages/contracts/src/framework/dao/DAOFactory.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC165} from "@openzeppelin/contracts/utils/introspection/ERC165.sol";

import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";
import {IProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/IProtocolVersion.sol";
import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {ProxyLib} from "@aragon/osx-commons-contracts/src/utils/deployment/ProxyLib.sol";

import {DAO} from "../../core/dao/DAO.sol";
import {PluginRepo} from "../plugin/repo/PluginRepo.sol";
import {PluginSetupProcessor} from "../plugin/setup/PluginSetupProcessor.sol";
import {hashHelpers, PluginSetupRef} from "../plugin/setup/PluginSetupProcessorHelpers.sol";
import {DAORegistry} from "./DAORegistry.sol";

/// @title DAOFactory
/// @author Aragon X - 2022-2023
/// @notice This contract is used to create a DAO.
/// @custom:security-contact sirt@aragon.org
contract DAOFactory is ERC165, ProtocolVersion {
    using ProxyLib for address;

    /// @notice The DAO base contract, to be used for creating new `DAO`s via `createERC1967Proxy` function.
    address public immutable daoBase;

    /// @notice The DAO registry listing the `DAO` contracts created via this contract.
    DAORegistry public immutable daoRegistry;

    /// @notice The plugin setup processor for installing plugins on the newly created `DAO`s.
    PluginSetupProcessor public immutable pluginSetupProcessor;

    // Cache permission IDs for optimized access
    bytes32 internal immutable ROOT_PERMISSION_ID;
    bytes32 internal immutable UPGRADE_DAO_PERMISSION_ID;
    bytes32 internal immutable SET_TRUSTED_FORWARDER_PERMISSION_ID;
    bytes32 internal immutable SET_METADATA_PERMISSION_ID;
    bytes32 internal immutable REGISTER_STANDARD_CALLBACK_PERMISSION_ID;
    bytes32 internal immutable EXECUTE_PERMISSION_ID;
    bytes32 internal immutable APPLY_INSTALLATION_PERMISSION_ID;

    /// @notice The container for the DAO settings to be set during the DAO initialization.
    /// @param trustedForwarder The address of the trusted forwarder required for meta transactions.
    /// @param daoURI The DAO uri used with [EIP-4824](https://eips.ethereum.org/EIPS/eip-4824).
    /// @param subdomain The ENS subdomain to be registered for the DAO contract.
    /// @param metadata The metadata of the DAO.
    struct DAOSettings {
        address trustedForwarder;
        string daoURI;
        string subdomain;
        bytes metadata;
    }

    /// @notice The container with the information required to install a plugin on the DAO.
    /// @param pluginSetupRef The `PluginSetupRepo` address of the plugin and the version tag.
    /// @param data The bytes-encoded data containing the input parameters for the installation as specified in the plugin's build metadata JSON file.
    struct PluginSettings {
        PluginSetupRef pluginSetupRef;
        bytes data;
    }

    /// @notice The container with the information about an installed plugin on a DAO.
    /// @param plugin The address of the deployed plugin instance.
    /// @param preparedSetupData The applied preparedSetupData which contains arrays of helpers and permissions.
    struct InstalledPlugin {
        address plugin;
        IPluginSetup.PreparedSetupData preparedSetupData;
    }

    /// @notice Thrown if `PluginSettings` array is empty, and no plugin is provided.
    error NoPluginProvided();

    /// @notice The constructor setting the registry and plugin setup processor and creating the base contracts for the factory.
    /// @param _registry The DAO registry to register the DAO by its name.
    /// @param _pluginSetupProcessor The address of PluginSetupProcessor.
    constructor(DAORegistry _registry, PluginSetupProcessor _pluginSetupProcessor) {
        daoRegistry = _registry;
        pluginSetupProcessor = _pluginSetupProcessor;

        DAO dao = new DAO();
        daoBase = address(dao);

        // Cache permission IDs for reduced gas usage in future function calls
        ROOT_PERMISSION_ID = dao.ROOT_PERMISSION_ID();
        UPGRADE_DAO_PERMISSION_ID = dao.UPGRADE_DAO_PERMISSION_ID();
        SET_TRUSTED_FORWARDER_PERMISSION_ID = dao.SET_TRUSTED_FORWARDER_PERMISSION_ID();
        SET_METADATA_PERMISSION_ID = dao.SET_METADATA_PERMISSION_ID();
        REGISTER_STANDARD_CALLBACK_PERMISSION_ID = dao.REGISTER_STANDARD_CALLBACK_PERMISSION_ID();
        EXECUTE_PERMISSION_ID = dao.EXECUTE_PERMISSION_ID();
        APPLY_INSTALLATION_PERMISSION_ID = pluginSetupProcessor.APPLY_INSTALLATION_PERMISSION_ID();
    }

    /// @notice Checks if this or the parent contract supports an interface by its ID.
    /// @param _interfaceId The ID of the interface.
    /// @return Returns `true` if the interface is supported.
    function supportsInterface(bytes4 _interfaceId) public view virtual override returns (bool) {
        return
            _interfaceId == type(IProtocolVersion).interfaceId ||
            super.supportsInterface(_interfaceId);
    }

    /// @notice Creates a new DAO, registers it in the DAO registry, and optionally installs plugins via the plugin setup processor.
    /// @dev If `_pluginSettings` is empty, the caller is granted `EXECUTE_PERMISSION` on the DAO.
    /// @param _daoSettings The settings to configure during DAO initialization.
    /// @param _pluginSettings An array containing plugin references and settings. If provided, each plugin is installed
    /// after the DAO creation.
    /// @return createdDao The address of the newly created DAO instance.
    /// @return installedPlugins An array of `InstalledPlugin` structs, each containing the plugin address and associated
    /// helper contracts and permissions, if plugins were installed; otherwise, an empty array.
    function createDao(
        DAOSettings calldata _daoSettings,
        PluginSettings[] calldata _pluginSettings
    ) external returns (DAO createdDao, InstalledPlugin[] memory installedPlugins) {
        // Create DAO.
        createdDao = _createDAO(_daoSettings);

        // Register DAO.
        daoRegistry.register(createdDao, msg.sender, _daoSettings.subdomain);

        // Cache address to save gas
        address daoAddress = address(createdDao);

        // Install plugins if plugin settings are provided.
        if (_pluginSettings.length != 0) {
            installedPlugins = new InstalledPlugin[](_pluginSettings.length);

            // Cache address to save gas
            address pluginSetupProcessorAddress = address(pluginSetupProcessor);

            // Grant the temporary permissions.
            // Grant Temporarily `ROOT_PERMISSION` to `pluginSetupProcessor`.
            createdDao.grant(daoAddress, pluginSetupProcessorAddress, ROOT_PERMISSION_ID);

            // Grant Temporarily `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` to this `DAOFactory`.
            createdDao.grant(
                pluginSetupProcessorAddress,
                address(this),
                APPLY_INSTALLATION_PERMISSION_ID
            );

            // Install plugins on the newly created DAO.
            for (uint256 i; i < _pluginSettings.length; ++i) {
                // Prepare plugin.
                (
                    address plugin,
                    IPluginSetup.PreparedSetupData memory preparedSetupData
                ) = pluginSetupProcessor.prepareInstallation(
                        daoAddress,
                        PluginSetupProcessor.PrepareInstallationParams(
                            _pluginSettings[i].pluginSetupRef,
                            _pluginSettings[i].data
                        )
                    );

                // Apply plugin.
                pluginSetupProcessor.applyInstallation(
                    daoAddress,
                    PluginSetupProcessor.ApplyInstallationParams(
                        _pluginSettings[i].pluginSetupRef,
                        plugin,
                        preparedSetupData.permissions,
                        hashHelpers(preparedSetupData.helpers)
                    )
                );

                installedPlugins[i] = InstalledPlugin(plugin, preparedSetupData);
            }

            // Revoke the temporarily granted permissions.
            // Revoke Temporarily `ROOT_PERMISSION` from `pluginSetupProcessor`.
            createdDao.revoke(daoAddress, pluginSetupProcessorAddress, ROOT_PERMISSION_ID);

            // Revoke `APPLY_INSTALLATION_PERMISSION` on `pluginSetupProcessor` from this `DAOFactory` .
            createdDao.revoke(
                pluginSetupProcessorAddress,
                address(this),
                APPLY_INSTALLATION_PERMISSION_ID
            );
        } else {
            // if no plugin setting is provided, grant EXECUTE_PERMISSION_ID to msg.sender
            createdDao.grant(daoAddress, msg.sender, EXECUTE_PERMISSION_ID);
        }

        // Set the rest of DAO's permissions.
        _setDAOPermissions(daoAddress);

        // Revoke Temporarily `ROOT_PERMISSION_ID` that implicitly granted to this `DaoFactory`
        // at the create dao step `address(this)` being the initial owner of the new created DAO.
        createdDao.revoke(daoAddress, address(this), ROOT_PERMISSION_ID);

        return (createdDao, installedPlugins);
    }

    /// @notice Deploys a new DAO `ERC1967` proxy, and initialize it with this contract as the initial owner.
    /// @param _daoSettings The trusted forwarder, name and metadata hash of the DAO it creates.
    function _createDAO(DAOSettings calldata _daoSettings) internal returns (DAO dao) {
        // Create a DAO proxy and initialize it with the DAOFactory (`address(this)`) as the initial owner.
        // As a result, the DAOFactory has `ROOT_PERMISSION_`ID` permission on the DAO.
        dao = DAO(
            payable(
                daoBase.deployUUPSProxy(
                    abi.encodeCall(
                        DAO.initialize,
                        (
                            _daoSettings.metadata,
                            address(this),
                            _daoSettings.trustedForwarder,
                            _daoSettings.daoURI
                        )
                    )
                )
            )
        );
    }

    /// @notice Sets the required permissions for the new DAO.
    /// @param _daoAddress The address of the DAO just created.
    function _setDAOPermissions(address _daoAddress) internal {
        // set permissionIds on the dao itself.
        PermissionLib.SingleTargetPermission[]
            memory items = new PermissionLib.SingleTargetPermission[](5);

        // Grant DAO all the permissions required
        items[0] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            _daoAddress,
            ROOT_PERMISSION_ID
        );
        items[1] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            _daoAddress,
            UPGRADE_DAO_PERMISSION_ID
        );
        items[2] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            _daoAddress,
            SET_TRUSTED_FORWARDER_PERMISSION_ID
        );
        items[3] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            _daoAddress,
            SET_METADATA_PERMISSION_ID
        );
        items[4] = PermissionLib.SingleTargetPermission(
            PermissionLib.Operation.Grant,
            _daoAddress,
            REGISTER_STANDARD_CALLBACK_PERMISSION_ID
        );

        DAO(payable(_daoAddress)).applySingleTargetPermissions(_daoAddress, items);
    }
}


### File: /home/errick/core/packages/contracts/src/framework/dao/DAORegistry.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

import {ENSSubdomainRegistrar} from "../utils/ens/ENSSubdomainRegistrar.sol";
import {InterfaceBasedRegistry} from "../utils/InterfaceBasedRegistry.sol";
import {isSubdomainValid} from "../utils/RegistryUtils.sol";

/// @title Register your unique DAO subdomain
/// @author Aragon X - 2022-2023
/// @notice This contract provides the possibility to register a DAO.
/// @custom:security-contact sirt@aragon.org
contract DAORegistry is InterfaceBasedRegistry, ProtocolVersion {
    /// @notice The ID of the permission required to call the `register` function.
    bytes32 public constant REGISTER_DAO_PERMISSION_ID = keccak256("REGISTER_DAO_PERMISSION");

    /// @notice The ENS subdomain registrar registering the DAO subdomains.
    ENSSubdomainRegistrar public subdomainRegistrar;

    /// @notice Thrown if the DAO subdomain doesn't match the regex `[0-9a-z\-]`
    error InvalidDaoSubdomain(string subdomain);

    /// @notice Thrown if the subdomain is present, but registrar is address(0).
    error ENSNotSupported();

    /// @notice Emitted when a new DAO is registered.
    /// @param dao The address of the DAO contract.
    /// @param creator The address of the creator.
    /// @param subdomain The DAO subdomain.
    event DAORegistered(address indexed dao, address indexed creator, string subdomain);

    /// @dev Used to disallow initializing the implementation contract by an attacker for extra safety.
    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    /// @notice Initializes the contract.
    /// @param _managingDao the managing DAO address.
    /// @param _subdomainRegistrar The `ENSSubdomainRegistrar` where `ENS` subdomain will be registered.
    function initialize(
        IDAO _managingDao,
        ENSSubdomainRegistrar _subdomainRegistrar
    ) external initializer {
        __InterfaceBasedRegistry_init(_managingDao, type(IDAO).interfaceId);
        subdomainRegistrar = _subdomainRegistrar;
    }

    /// @notice Registers a DAO by its address. If a non-empty subdomain name is provided that is not taken already, the DAO becomes the owner of the ENS name.
    /// @dev A subdomain is unique within the Aragon DAO framework and can get stored here.
    /// @param dao The address of the DAO contract.
    /// @param creator The address of the creator.
    /// @param subdomain The DAO subdomain.
    function register(
        IDAO dao,
        address creator,
        string calldata subdomain
    ) external auth(REGISTER_DAO_PERMISSION_ID) {
        address daoAddr = address(dao);

        _register(daoAddr);

        if ((bytes(subdomain).length > 0)) {
            if (address(subdomainRegistrar) == address(0)) {
                revert ENSNotSupported();
            }

            if (!isSubdomainValid(subdomain)) {
                revert InvalidDaoSubdomain({subdomain: subdomain});
            }

            bytes32 labelhash = keccak256(bytes(subdomain));

            subdomainRegistrar.registerSubnode(labelhash, daoAddr);
        }

        emit DAORegistered(daoAddr, creator, subdomain);
    }

    /// @notice This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain (see [OpenZeppelin's guide about storage gaps](https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).
    uint256[49] private __gap;
}


### File: /home/errick/core/packages/contracts/src/test/ProtocolVersionMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ProtocolVersion} from "@aragon/osx-commons-contracts/src/utils/versioning/ProtocolVersion.sol";

/// @title ProtocolVersionMock
// solhint-disable-next-line no-empty-blocks
contract ProtocolVersionMock is ProtocolVersion {}


### File: /home/errick/core/packages/contracts/src/test/Migration.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/**
 * @title Migration
 *
 * @dev This file imports contracts from
 * - previous versions of `@aragon/osx`
 * - the current or previous versions of @aragon/osx-commons
 * with the purpose of integration and regression testing
 *
 * Each imported contract is aliased as `<contract-name>_<versions_name>` for clarity and to avoid
 * name collisions when the same contract is imported from different versions. This aliasing is only
 * necessary in the context of this Migration.sol file to differentiate between contract versions.
 *
 * After a contract is imported here and the project is compiled, an associated artifact will be
 * generated inside artifacts/@aragon/{version-name}/*,
 * and TypeChain typings will be generated inside typechain/osx-version/{version-name}/* for type-safe interactions with the contract
 * in our tests.
 */

/* solhint-disable no-unused-import */

// Deploy Script
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

// Regression Testing
import {DAO as DAO_v1_0_0} from "@aragon/osx-v1.0.1/core/dao/DAO.sol";
import {DAO as DAO_v1_3_0} from "@aragon/osx-v1.3.0/core/dao/DAO.sol";
import {DAORegistry as DAORegistry_v1_0_0} from "@aragon/osx-v1.0.1/framework/dao/DAORegistry.sol";
import {DAORegistry as DAORegistry_v1_3_0} from "@aragon/osx-v1.3.0/framework/dao/DAORegistry.sol";

import {PluginRepo as PluginRepo_v1_0_0} from "@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepo.sol";
import {PluginRepo as PluginRepo_v1_3_0} from "@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepo.sol";

import {PluginRepoRegistry as PluginRepoRegistry_v1_0_0} from "@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepoRegistry.sol";
import {PluginRepoRegistry as PluginRepoRegistry_v1_3_0} from "@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepoRegistry.sol";

import {ENSSubdomainRegistrar as ENSSubdomainRegistrar_v1_0_0} from "@aragon/osx-v1.0.1/framework/utils/ens/ENSSubdomainRegistrar.sol";
import {ENSSubdomainRegistrar as ENSSubdomainRegistrar_v1_3_0} from "@aragon/osx-v1.3.0/framework/utils/ens/ENSSubdomainRegistrar.sol";

// Integration Testing
import {ProxyFactory} from "@aragon/osx-commons-contracts/src/utils/deployment/ProxyFactory.sol";

/* solhint-enable no-unused-import */


### File: /home/errick/core/packages/contracts/src/test/plugin/PluginMockData.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {ProxyLib} from "@aragon/osx-commons-contracts/src/utils/deployment/ProxyLib.sol";

address constant NO_CONDITION = address(0);

error ConflictingValues();

function mockPermissions(
    uint160 start,
    uint160 end,
    PermissionLib.Operation op
) pure returns (PermissionLib.MultiTargetPermission[] memory permissions) {
    if (start > end) revert ConflictingValues();

    permissions = new PermissionLib.MultiTargetPermission[](end - start);

    for (uint160 i = start; i < end; i++) {
        permissions[i - start] = PermissionLib.MultiTargetPermission({
            operation: op,
            where: address(i),
            who: address(i),
            condition: PermissionLib.NO_CONDITION,
            permissionId: keccak256("MOCK_PERMISSION")
        });
    }
}

function mockHelpers(uint160 amount) pure returns (address[] memory helpers) {
    helpers = new address[](amount);

    for (uint160 i = 0; i < amount; i++) {
        helpers[i] = address(i);
    }
}

function mockPluginProxy(address _pluginBase, address _dao) returns (address) {
    return
        ProxyLib.deployUUPSProxy(
            _pluginBase,
            abi.encodeWithSelector(bytes4(keccak256("initialize(address)")), _dao)
        );
}


### File: /home/errick/core/packages/contracts/src/test/plugin/Cloneable/PluginCloneableMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

/* solhint-disable one-contract-per-file */
pragma solidity ^0.8.28;

import {PluginCloneable} from "@aragon/osx-commons-contracts/src/plugin/PluginCloneable.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

contract PluginCloneableV1Mock is PluginCloneable {
    uint256 public state1;

    function initialize(IDAO _dao) external initializer {
        __PluginCloneable_init(_dao);
        state1 = 1;
    }
}

// Doesn't support IPlugin Interface. // TODO revisit tests
contract PluginCloneableV1MockBad {
    uint256 public state1;

    function initialize(IDAO _dao) external {
        (_dao);
        state1 = 1;
    }
}

contract PluginCloneableV2Mock is PluginCloneable {
    uint256 public state1;
    uint256 public state2;

    function initialize(IDAO _dao) external initializer {
        __PluginCloneable_init(_dao);
        state1 = 1;
        state2 = 2;
    }
}


### File: /home/errick/core/packages/contracts/src/test/plugin/Cloneable/PluginCloneableSetupMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

/* solhint-disable one-contract-per-file */
pragma solidity ^0.8.28;

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";

import {mockPermissions, mockHelpers, mockPluginProxy} from "../PluginMockData.sol";
import {PluginCloneableV1Mock, PluginCloneableV1MockBad, PluginCloneableV2Mock} from "./PluginCloneableMock.sol";

contract PluginCloneableSetupV1Mock is PluginSetup {
    constructor(address implementation) PluginSetup(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = mockHelpers(1);
        preparedSetupData.permissions = mockPermissions(5, 6, PermissionLib.Operation.Grant);
    }

    /// @inheritdoc IPluginSetup
    function prepareUninstallation(
        address _dao,
        SetupPayload calldata _payload
    ) external virtual override returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        (_dao, _payload);
        permissions = mockPermissions(5, 6, PermissionLib.Operation.Revoke);
    }
}

contract PluginCloneableSetupV1MockBad is PluginSetup {
    constructor(address implementation) PluginSetup(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = mockHelpers(1);
        preparedSetupData.permissions = mockPermissions(5, 6, PermissionLib.Operation.Grant);
    }

    /// @inheritdoc IPluginSetup
    function prepareUninstallation(
        address _dao,
        SetupPayload calldata _payload
    ) external virtual override returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        (_dao, _payload);
        permissions = mockPermissions(5, 6, PermissionLib.Operation.Revoke);
    }
}

contract PluginCloneableSetupV2Mock is PluginCloneableSetupV1Mock {
    constructor(address implementation) PluginCloneableSetupV1Mock(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = mockHelpers(1);
        preparedSetupData.permissions = mockPermissions(5, 7, PermissionLib.Operation.Grant);
    }

    /// @inheritdoc IPluginSetup
    function prepareUninstallation(
        address _dao,
        SetupPayload calldata _payload
    ) external virtual override returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        (_dao, _payload);
        permissions = mockPermissions(5, 7, PermissionLib.Operation.Revoke);
    }
}


### File: /home/errick/core/packages/contracts/src/test/plugin/UUPSUpgradeable/PluginUUPSUpgradeableMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

/* solhint-disable one-contract-per-file */
pragma solidity ^0.8.28;

import {PluginUUPSUpgradeable} from "@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

contract PluginUUPSUpgradeableV1Mock is PluginUUPSUpgradeable {
    uint256 public state1;

    function initialize(IDAO _dao) external initializer {
        __PluginUUPSUpgradeable_init(_dao);
        state1 = 1;
    }
}

contract PluginUUPSUpgradeableV2Mock is PluginUUPSUpgradeable {
    uint256 public state1;
    uint256 public state2;

    function initialize(IDAO _dao) external reinitializer(2) {
        __PluginUUPSUpgradeable_init(_dao);
        state1 = 1;
        state2 = 2;
    }

    function initializeV1toV2() external reinitializer(2) {
        state2 = 2;
    }
}

contract PluginUUPSUpgradeableV3Mock is PluginUUPSUpgradeable {
    uint256 public state1;
    uint256 public state2;
    uint256 public state3;

    function initialize(IDAO _dao) external reinitializer(3) {
        __PluginUUPSUpgradeable_init(_dao);
        state1 = 1;
        state2 = 2;
        state3 = 3;
    }

    function initializeV1toV3() external reinitializer(3) {
        state2 = 2;
        state3 = 3;
    }

    function initializeV2toV3() external reinitializer(3) {
        state3 = 3;
    }
}


### File: /home/errick/core/packages/contracts/src/test/plugin/UUPSUpgradeable/PluginUUPSUpgradeableSetupMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

/* solhint-disable one-contract-per-file */
pragma solidity ^0.8.28;

import {PermissionLib} from "@aragon/osx-commons-contracts/src/permission/PermissionLib.sol";
import {IPluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/IPluginSetup.sol";
import {PluginSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginSetup.sol";

import {PluginUpgradeableSetup} from "@aragon/osx-commons-contracts/src/plugin/setup/PluginUpgradeableSetup.sol";

import {mockPermissions, mockHelpers, mockPluginProxy} from "../PluginMockData.sol";
import {PluginUUPSUpgradeableV1Mock, PluginUUPSUpgradeableV2Mock, PluginUUPSUpgradeableV3Mock} from "./PluginUUPSUpgradeableMock.sol";
import "hardhat/console.sol";

abstract contract MockedHelper is IPluginSetup {
    // Used for mocking in tests
    uint160 private helpersCount;
    uint160 private permissionMockLowerIndex;
    uint160 private permissionMockUpperIndex;

    // Helper emits to help with testing
    event InstallationPrepared(address dao, bytes data);
    event UninstallationPrepared(address dao, SetupPayload payload);
    event UpdatePrepared(address dao, uint16 build, SetupPayload payload);

    // helper functions to help with testing
    function emitInstallationPrepared(address dao, bytes memory data) internal {
        emit InstallationPrepared(dao, data);
    }

    function emitUpdatePrepared(address dao, uint16 build, SetupPayload memory payload) internal {
        emit UpdatePrepared(dao, build, payload);
    }

    function emitUninstallationPrepared(address dao, SetupPayload memory payload) internal {
        emit UninstallationPrepared(dao, payload);
    }

    // called externally to allow mock behaviour
    function mockPermissionIndexes(uint160 _lowerIndex, uint160 _upperIndex) public {
        permissionMockLowerIndex = _lowerIndex;
        permissionMockUpperIndex = _upperIndex;
    }

    function mockHelperCount(uint160 _helpersCount) public {
        helpersCount = _helpersCount;
    }

    // called internally from the setup contracts
    function _mockHelpers(uint160 _helpersCount) internal view returns (address[] memory) {
        return mockHelpers(helpersCount != 0 ? helpersCount : _helpersCount);
    }

    function _mockPermissions(
        uint160 lower,
        uint160 upper,
        PermissionLib.Operation _op
    ) internal view returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        return
            mockPermissions(
                permissionMockLowerIndex != 0 ? permissionMockLowerIndex : lower,
                permissionMockUpperIndex != 0 ? permissionMockUpperIndex : upper,
                _op
            );
    }

    function reset() public {
        permissionMockLowerIndex = 0;
        permissionMockUpperIndex = 0;
        helpersCount = 0;
    }
}

contract PluginUUPSUpgradeableSetupV1Mock is PluginUpgradeableSetup, MockedHelper {
    constructor(address implementation) PluginUpgradeableSetup(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory _data
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = _mockHelpers(2);
        preparedSetupData.permissions = _mockPermissions(0, 2, PermissionLib.Operation.Grant);

        emitInstallationPrepared(_dao, _data);
    }

    /// @inheritdoc IPluginSetup
    /// @dev The default implementation for the initial build 1 that reverts because no earlier build exists.
    function prepareUpdate(
        address _dao,
        uint16 _fromBuild,
        SetupPayload calldata _payload
    ) external virtual returns (bytes memory, PreparedSetupData memory) {
        (_dao, _fromBuild, _payload);
    }

    /// @inheritdoc IPluginSetup
    function prepareUninstallation(
        address _dao,
        SetupPayload calldata _payload
    ) external virtual override returns (PermissionLib.MultiTargetPermission[] memory permissions) {
        (_dao, _payload);
        permissions = _mockPermissions(0, 1, PermissionLib.Operation.Revoke);

        emitUninstallationPrepared(_dao, _payload);
    }
}

contract PluginUUPSUpgradeableSetupV1MockBad is PluginUUPSUpgradeableSetupV1Mock {
    constructor(address implementation) PluginUUPSUpgradeableSetupV1Mock(implementation) {}

    function prepareInstallation(
        address _dao,
        bytes memory _data
    ) public override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        (_dao);
        plugin = address(0); // The bad behaviour is returning the same address over and over again
        preparedSetupData.helpers = mockHelpers(1);
        preparedSetupData.permissions = super._mockPermissions(0, 1, PermissionLib.Operation.Grant);

        emitInstallationPrepared(_dao, _data);
    }
}

contract PluginUUPSUpgradeableSetupV2Mock is PluginUUPSUpgradeableSetupV1Mock {
    constructor(address implementation) PluginUUPSUpgradeableSetupV1Mock(implementation) {}

    event amazing(uint k);

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory _data
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = super._mockHelpers(2);
        preparedSetupData.permissions = super._mockPermissions(0, 2, PermissionLib.Operation.Grant);

        emitInstallationPrepared(_dao, _data);
    }

    function prepareUpdate(
        address _dao,
        uint16 _currentBuild,
        SetupPayload calldata _payload
    )
        public
        virtual
        override
        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)
    {
        (_dao, _payload);

        // Update from V1
        if (_currentBuild == 1) {
            preparedSetupData.helpers = super._mockHelpers(2);
            initData = abi.encodeCall(PluginUUPSUpgradeableV2Mock.initializeV1toV2, ());
            preparedSetupData.permissions = super._mockPermissions(
                1,
                2,
                PermissionLib.Operation.Grant
            );
        }

        emitUpdatePrepared(_dao, _currentBuild, _payload);
    }
}

contract PluginUUPSUpgradeableSetupV3Mock is PluginUUPSUpgradeableSetupV2Mock {
    constructor(address implementation) PluginUUPSUpgradeableSetupV2Mock(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory _data
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = super._mockHelpers(3);
        preparedSetupData.permissions = super._mockPermissions(0, 3, PermissionLib.Operation.Grant);

        emitInstallationPrepared(_dao, _data);
    }

    function prepareUpdate(
        address _dao,
        uint16 _currentBuild,
        SetupPayload calldata _payload
    )
        public
        virtual
        override
        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)
    {
        (_dao, _payload);

        // Update from V1
        if (_currentBuild == 1) {
            preparedSetupData.helpers = super._mockHelpers(3);
            initData = abi.encodeCall(PluginUUPSUpgradeableV3Mock.initializeV1toV3, ());
            preparedSetupData.permissions = super._mockPermissions(
                1,
                3,
                PermissionLib.Operation.Grant
            );
        }

        // Update from V2
        if (_currentBuild == 2) {
            preparedSetupData.helpers = super._mockHelpers(3);
            initData = abi.encodeCall(PluginUUPSUpgradeableV3Mock.initializeV2toV3, ());
            preparedSetupData.permissions = super._mockPermissions(
                2,
                3,
                PermissionLib.Operation.Grant
            );
        }

        emitUpdatePrepared(_dao, _currentBuild, _payload);
    }
}

/// @dev With this plugin setup, the plugin base implementation doesn't change.
/// This setup is a good example when you want to design a new plugin setup
/// which uses the same base implementation(doesn't update the logic contract)
/// but applies new/modifier permissions on it.

contract PluginUUPSUpgradeableSetupV4Mock is PluginUUPSUpgradeableSetupV3Mock {
    constructor(address implementation) PluginUUPSUpgradeableSetupV3Mock(implementation) {}

    /// @inheritdoc IPluginSetup
    function prepareInstallation(
        address _dao,
        bytes memory _data
    ) public virtual override returns (address plugin, PreparedSetupData memory preparedSetupData) {
        plugin = mockPluginProxy(implementation(), _dao);
        preparedSetupData.helpers = super._mockHelpers(3);
        preparedSetupData.permissions = super._mockPermissions(0, 3, PermissionLib.Operation.Grant);

        emitInstallationPrepared(_dao, _data);
    }

    function prepareUpdate(
        address _dao,
        uint16 _currentBuild,
        SetupPayload calldata _payload
    )
        public
        virtual
        override
        returns (bytes memory initData, PreparedSetupData memory preparedSetupData)
    {
        // If one tries to upgrade from v3 to this(v4), developer of this v4
        // knows that logic contract doesn't change as he specified the same address
        // in `implementation()`. This means this update should only include returning
        // the desired updated permissions. PluginSetupProcessor will take care of
        // not calling `upgradeTo` on the plugin in such cases.
        if (_currentBuild == 3) {
            preparedSetupData.permissions = super._mockPermissions(
                3,
                4,
                PermissionLib.Operation.Grant
            );
        }
        // If the update happens from those that have different implementation addresses(v1,v2)
        // proxy(plugin) contract should be upgraded to the new base implementation which requires(not always though)
        // returning the `initData` that will be called upon `upradeToAndCall` by plugin setup processor.
        // NOTE that dev is free to do what he wishes.
        else if (_currentBuild == 1 || _currentBuild == 2) {
            (initData, preparedSetupData) = super.prepareUpdate(_dao, _currentBuild, _payload);
            // Even for this case, dev might decide to modify the permissions..
            preparedSetupData.permissions = super._mockPermissions(
                4,
                5,
                PermissionLib.Operation.Grant
            );
        }

        emitUpdatePrepared(_dao, _currentBuild, _payload);
    }
}


### File: /home/errick/core/packages/contracts/src/test/plugin/Constructable/PluginMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {Plugin} from "@aragon/osx-commons-contracts/src/plugin/Plugin.sol";
import {IDAO} from "@aragon/osx-commons-contracts/src/dao/IDAO.sol";

contract PluginV1Mock is Plugin {
    uint256 public state1;

    constructor(IDAO _dao) Plugin(_dao) {
        state1 = 1;
    }
}


### File: /home/errick/core/packages/contracts/src/test/permission/PermissionManagerTest.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

import "../../core/permission/PermissionManager.sol";

contract PermissionManagerTest is PermissionManager {
    // Restricted permissionIds that shouldn't be allowed to grant for who == ANY_ADDR or where == ANY_ADDR
    bytes32 public constant TEST_PERMISSION_1_ID = keccak256("TEST_PERMISSION_1");
    bytes32 public constant TEST_PERMISSION_2_ID = keccak256("TEST_PERMISSION_2");

    function init(address _who) public initializer {
        super.__PermissionManager_init(_who);
    }

    function getAuthPermission(
        address _where,
        address _who,
        bytes32 _permissionId
    ) public view returns (address) {
        return permissionsHashed[permissionHash(_where, _who, _permissionId)];
    }

    function getPermissionHash(
        address _where,
        address _who,
        bytes32 _permissionId
    ) public pure returns (bytes32) {
        return permissionHash(_where, _who, _permissionId);
    }

    function getAnyAddr() public pure returns (address) {
        return ANY_ADDR;
    }

    function hasPermission(
        address _where,
        address _who,
        bytes32 _permissionId,
        bytes memory _data
    ) public view returns (bool) {
        return isGranted(_where, _who, _permissionId, _data);
    }

    function isPermissionRestrictedForAnyAddr(
        bytes32 _permissionId
    ) internal view virtual override returns (bool) {
        return _permissionId == TEST_PERMISSION_1_ID || _permissionId == TEST_PERMISSION_2_ID;
    }
}


### File: /home/errick/core/packages/contracts/src/test/permission/PermissionConditionMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {PermissionCondition} from "@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol";

/// @notice A mock permission condition that can be set to permit or deny every call.
/// @dev DO NOT USE IN PRODUCTION!
contract PermissionConditionMock is PermissionCondition {
    bool public answer;

    constructor() {
        answer = true;
    }

    function setAnswer(bool _answer) external {
        answer = _answer;
    }

    function isGranted(
        address _where,
        address _who,
        bytes32 _permissionId,
        bytes memory _data
    ) external view returns (bool) {
        (_where, _who, _permissionId, _data);
        return answer;
    }
}


### File: /home/errick/core/packages/contracts/src/test/utils/RegistryUtilsTest.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {isSubdomainValid as _isSubdomainValid} from "../../framework/utils/RegistryUtils.sol";

contract RegistryUtils {
    function isSubdomainValid(string calldata subdomain) external pure returns (bool) {
        return _isSubdomainValid(subdomain);
    }
}


### File: /home/errick/core/packages/contracts/src/test/utils/InterfaceBasedRegistryMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import "../../framework/utils/InterfaceBasedRegistry.sol";

contract InterfaceBasedRegistryMock is InterfaceBasedRegistry {
    bytes32 public constant REGISTER_PERMISSION_ID = keccak256("REGISTER_PERMISSION");

    event Registered(address);

    function initialize(IDAO _dao, bytes4 targetInterface) external initializer {
        __InterfaceBasedRegistry_init(_dao, targetInterface);
    }

    function register(address registrant) external auth(REGISTER_PERMISSION_ID) {
        _register(registrant);

        emit Registered(registrant);
    }
}


### File: /home/errick/core/packages/contracts/src/test/dao/GasConsumerHelper.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @notice This contract is used for testing to consume gas.
contract GasConsumer {
    mapping(uint256 => uint256) public store;

    function consumeGas(uint256 count) external {
        for (uint256 i = 0; i < count; i++) {
            store[i] = 1;
        }
    }
}


### File: /home/errick/core/packages/contracts/src/test/dao/ActionExecute.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

/// @notice A dummy contract to test if DAO can successfully execute an action
contract ActionExecute {
    uint num = 10;

    function setTest(uint newNum) public returns (uint) {
        num = newNum;
        return num;
    }

    function fail() public pure {
        revert("ActionExecute:Revert");
    }
}


### File: /home/errick/core/packages/contracts/src/test/dao/CallbackHandlerHelperMock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {CallbackHandler} from "../../core/utils/CallbackHandler.sol";

contract CallbackHandlerMockHelper is CallbackHandler {
    address callbackHandlerMockAddr;

    /// @notice Calls the internal `_handleCallback` on the parent `CallbackHandler` for testing purposes.
    /// @param selector The function selector of the callback function to be tested.
    /// @param data Arbitrary data accompanying the callback that will be emitted with the `CallbackReceived` event.
    function handleCallback(bytes4 selector, bytes memory data) external returns (bytes4) {
        bytes4 magicNumber = _handleCallback(selector, data);
        return magicNumber;
    }

    /// @notice Executes `_registerCallback` on the parent to register magic number per selector.
    /// @param selector The function selector.
    /// @param magicNumber The selector's magic number.
    function registerCallback(bytes4 selector, bytes4 magicNumber) external {
        _registerCallback(selector, magicNumber);
    }
}


### File: /home/errick/core/packages/contracts/src/test/token/ERC721Mock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC721} from "@openzeppelin/contracts/token/ERC721/ERC721.sol";

/// @notice A mock [ERC-721](https://eips.ethereum.org/EIPS/eip-721) token that can be minted and burned by everyone.
/// @dev DO NOT USE IN PRODUCTION!
contract ERC721Mock is ERC721 {
    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}

    function mint(address account, uint256 tokenId) public {
        _mint(account, tokenId);
    }

    function burn(uint256 tokenId) public {
        _burn(tokenId);
    }
}


### File: /home/errick/core/packages/contracts/src/test/token/ERC1155Mock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC1155} from "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";

/// @notice A mock [ERC-1155](https://eips.ethereum.org/EIPS/eip-1155) token that can be minted and burned by everyone.
/// @dev DO NOT USE IN PRODUCTION!
contract ERC1155Mock is ERC1155 {
    constructor(string memory _uri) ERC1155(_uri) {}

    function mint(address account, uint256 tokenId, uint256 amount) public {
        _mint(account, tokenId, amount, bytes(""));
    }

    function burn(address account, uint256 tokenId, uint256 amount) public {
        _burn(account, tokenId, amount);
    }
}


### File: /home/errick/core/packages/contracts/src/test/token/ERC20Mock.sol ###
// SPDX-License-Identifier: AGPL-3.0-or-later

pragma solidity ^0.8.28;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

/// @notice A mock [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token that can be minted and burned by everyone.
/// @dev DO NOT USE IN PRODUCTION!
contract ERC20Mock is ERC20 {
    uint8 public decimals_ = 18;

    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}

    function setDecimals(uint8 _decimals) public {
        decimals_ = _decimals;
    }

    function decimals() public view override returns (uint8) {
        return decimals_;
    }

    // sets the balance of the address
    // this mints/burns the amount depending on the current balance
    function setBalance(address to, uint256 amount) public {
        uint256 old = balanceOf(to);
        if (old < amount) {
            _mint(to, amount - old);
        } else if (old > amount) {
            _burn(to, old - amount);
        }
    }
}


### File: /home/errick/core/packages/contracts/test/chai-setup.ts ###
/**
 * Enable additional matchers for chai and smock
 * import this file in place of chai, i.e:
 * import {expect} from './chai-setup';
 **/
import {smock} from '@defi-wonderland/smock';
import chai from 'chai';

chai.use(smock.matchers);
export = chai;


### File: /home/errick/core/packages/contracts/test/protocol-version.ts ###
import {ProtocolVersionMock__factory} from '../typechain';
import {osxContractsVersion} from './test-utils/protocol-version';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

describe('ProtocolVersion', function () {
  let signers: SignerWithAddress[];
  before(async () => {
    signers = await ethers.getSigners();
  });

  it('returns the current protocol version that must match the semantic version of the `osx-contracts` package', async () => {
    const versionedContract = await hre.wrapper.deploy('ProtocolVersionMock');

    expect(await versionedContract.protocolVersion()).to.deep.equal(
      osxContractsVersion()
    );
  });
});


### File: /home/errick/core/packages/contracts/test/deploy/default-env.ts ###
import {
  HARDHAT_ACCOUNTS,
  daoDomainEnv,
  env,
  ethKeyEnv,
  managementDaoMultisigApproversEnv,
  managementDaoMultisigListedOnlyEnv,
  managementDaoMultisigMinApprovalsEnv,
  managementDaoSubdomainEnv,
  pluginDomainEnv,
} from '../../utils/environment';
import {skipTestSuiteIfNetworkIsZkSync} from '../test-utils/skip-functions';
import {expect} from 'chai';
import {network} from 'hardhat';
import {Network} from 'hardhat/types';

skipTestSuiteIfNetworkIsZkSync('detect network', () => {
  beforeEach(() => {
    process.env = {};
  });

  it('should detect the hardhat network', () => {
    expect(network.name).to.equal('hardhat');
  });

  it('provides default values for env vars if using the hardhat network', () => {
    const daoDomain = env(network, 'DAO_ENS_DOMAIN', 'dao.eth');
    expect(daoDomain).to.equal('dao.eth');
  });

  it('uses the environment variable if set', () => {
    process.env['DAO_ENS_DOMAIN'] = 'mydao.eth';
    const daoDomain = env(network, 'DAO_ENS_DOMAIN', 'dao.eth');
    expect(daoDomain).to.equal('mydao.eth');
  });

  it("Throws if env vars aren't set for the network other than hardhat", () => {
    const network = {name: 'mainnet'} as unknown as Network;
    delete process.env['DAO_ENS_DOMAIN'];
    expect(() => env(network, 'DAO_ENS_DOMAIN', 'dao.eth')).to.throw(
      'Missing env var: DAO_ENS_DOMAIN'
    );
  });

  it("Doesn't throw if env vars are set for the network other than hardhat", () => {
    const network: Network = {name: 'mainnet'} as unknown as Network;
    process.env['DAO_ENS_DOMAIN'] = 'mydao.eth';
    const daoDomain = env(network, 'DAO_ENS_DOMAIN', 'dao.eth');
    expect(daoDomain).to.equal('mydao.eth');
  });

  it('sets the correct fallbacks for each environment variable', () => {
    expect(daoDomainEnv(network)).to.equal('dao.eth');
    expect(pluginDomainEnv(network)).to.equal('plugin.dao.eth');
    expect(managementDaoSubdomainEnv(network)).to.equal('management');
    expect(managementDaoMultisigApproversEnv(network)).to.equal(
      HARDHAT_ACCOUNTS[0].ADDRESS
    );
    expect(managementDaoMultisigMinApprovalsEnv(network)).to.equal('1');
    expect(managementDaoMultisigListedOnlyEnv(network)).to.equal('true');
    expect(ethKeyEnv(network)).to.equal(HARDHAT_ACCOUNTS[1].KEY);
  });

  it('string interpolates the ENS subdomains', () => {
    const network: Network = {name: 'FakeNet'} as unknown as Network;
    process.env['FAKENET_DAO_ENS_DOMAIN'] = 'mydao.eth';
    process.env['FAKENET_PLUGIN_ENS_DOMAIN'] = 'myplugin.dao.eth';
    expect(daoDomainEnv(network)).to.equal('mydao.eth');
    expect(pluginDomainEnv(network)).to.equal('myplugin.dao.eth');
  });
});


### File: /home/errick/core/packages/contracts/test/deploy/managing-dao.ts ###
import {
  DAO,
  DAORegistry,
  DAORegistry__factory,
  DAO__factory,
  ENSSubdomainRegistrar,
  ENSSubdomainRegistrar__factory,
  PluginRepoRegistry,
  PluginRepoRegistry__factory,
  PluginRepo__factory,
} from '../../typechain';
import {initializeDeploymentFixture} from '../test-utils/fixture';
import {
  DAO_PERMISSIONS,
  DAO_REGISTRY_PERMISSIONS,
  ENS_REGISTRAR_PERMISSIONS,
  PLUGIN_REGISTRY_PERMISSIONS,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers, deployments} from 'hardhat';
import {Deployment} from 'hardhat-deploy/dist/types';

async function deployAll() {
  await initializeDeploymentFixture('New');
}

describe('Management DAO', function () {
  let deployer: SignerWithAddress;

  let managementDaoDeployment: Deployment;
  let managementDao: DAO;
  let daoRegistryDeployment: Deployment;
  let daoRegistry: DAORegistry;
  let pluginRepoRegistryDeployment: Deployment;
  let pluginRepoRegistry: PluginRepoRegistry;
  let ensSubdomainRegistrars: {
    pluginRegistrar: ENSSubdomainRegistrar;
    daoRegistrar: ENSSubdomainRegistrar;
  };

  before(async () => {
    [deployer] = await ethers.getSigners();

    // deployment should be empty
    expect(await deployments.all()).to.be.empty;

    // deploy framework
    await deployAll();

    // ManagementDAO
    managementDaoDeployment = await deployments.get('ManagementDAOProxy');
    managementDao = DAO__factory.connect(
      managementDaoDeployment.address,
      deployer
    );

    // DAORegistry
    daoRegistryDeployment = await deployments.get('DAORegistryProxy');
    daoRegistry = DAORegistry__factory.connect(
      daoRegistryDeployment.address,
      deployer
    );

    // PluginRepoRegistry
    pluginRepoRegistryDeployment = await deployments.get(
      'PluginRepoRegistryProxy'
    );
    pluginRepoRegistry = PluginRepoRegistry__factory.connect(
      pluginRepoRegistryDeployment.address,
      deployer
    );

    // ENSSubdomainRegistrar
    ensSubdomainRegistrars = {
      daoRegistrar: ENSSubdomainRegistrar__factory.connect(
        (await deployments.get('DAOENSSubdomainRegistrarProxy')).address,
        deployer
      ),
      pluginRegistrar: ENSSubdomainRegistrar__factory.connect(
        (await deployments.get('PluginENSSubdomainRegistrarProxy')).address,
        deployer
      ),
    };
  });

  it('has deployments', async function () {
    expect(await deployments.all()).to.not.be.empty;
  });

  it('has the `ROOT_PERMISSION_ID` permission on itself', async function () {
    expect(
      await managementDao.hasPermission(
        managementDao.address,
        managementDao.address,
        DAO_PERMISSIONS.ROOT_PERMISSION_ID,
        []
      )
    ).to.be.true;
  });

  describe('permissions', function () {
    it('has permission to upgrade itself', async function () {
      expect(
        await managementDao.hasPermission(
          managementDao.address,
          managementDao.address,
          DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID,
          []
        )
      ).to.be.true;
    });

    it('has permission to upgrade DaoRegistry', async function () {
      expect(
        await managementDao.hasPermission(
          daoRegistry.address,
          managementDao.address,
          DAO_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          []
        )
      ).to.be.true;
    });

    it('has permission to upgrade PluginRepoRegistry', async function () {
      expect(
        await managementDao.hasPermission(
          pluginRepoRegistry.address,
          managementDao.address,
          PLUGIN_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          []
        )
      ).to.be.true;
    });

    it('has permission to upgrade DAO_ENSSubdomainRegistrar', async function () {
      expect(
        await managementDao.hasPermission(
          ensSubdomainRegistrars.daoRegistrar.address,
          managementDao.address,
          ENS_REGISTRAR_PERMISSIONS.UPGRADE_REGISTRAR_PERMISSION_ID,
          []
        )
      ).to.be.true;
    });
    it('has permission to upgrade Plugin_ENSSubdomainRegistrar', async function () {
      expect(
        await managementDao.hasPermission(
          ensSubdomainRegistrars.pluginRegistrar.address,
          managementDao.address,
          ENS_REGISTRAR_PERMISSIONS.UPGRADE_REGISTRAR_PERMISSION_ID,
          []
        )
      ).to.be.true;
    });
  });
});


### File: /home/errick/core/packages/contracts/test/deploy/update-1.4.0.ts ###
import {getLatestContractAddress} from '../../deploy/helpers';
import {
  DAO,
  DAO__factory,
  DAOFactory__factory,
  DAORegistry__factory,
  PluginRepoRegistry__factory,
} from '../../typechain';
import {PluginRepoRegisteredEvent} from '../../typechain/PluginRepoRegistry';
import {getAnticipatedAddress} from '../framework/dao/dao-factory';
import {daoExampleURI} from '../test-utils/dao';
import {
  closeFork,
  initForkForOsxVersion,
  initializeDeploymentFixture,
} from '../test-utils/fixture';
import {createPrepareInstallationParams} from '../test-utils/psp/create-params';
import {PluginRepoPointer} from '../test-utils/psp/types';
import {skipTestSuiteIfNetworkIsZkSync} from '../test-utils/skip-functions';
import {findEventTopicLog} from '@aragon/osx-commons-sdk';
import {PluginRepoFactory__factory} from '@aragon/osx-ethers-v1.2.0';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {defaultAbiCoder} from 'ethers/lib/utils';
import hre, {ethers, deployments} from 'hardhat';

const IMPLEMENTATION_ADDRESS_SLOT =
  '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc';

const daoSettings = {
  trustedForwarder: ethers.constants.AddressZero,
  subdomain: 'dao1',
  metadata: '0x0000',
  daoURI: daoExampleURI,
};

const EVENTS = {
  PluginRepoRegistered: 'PluginRepoRegistered',
  DAORegistered: 'DAORegistered',
};

async function forkSepolia() {
  hre.network.deploy = ['./deploy/update/to_v1.4.0'];

  // console.log(hre);
  await initForkForOsxVersion('sepolia', {
    version: '1.3.0',
    forkBlockNumber: 7296100,
    activeContracts: [],
  });
}

function getAddress(name: string) {
  return getLatestContractAddress(name, hre);
}

async function assertImplementation(contract: string, expected: string) {
  const actual = defaultAbiCoder
    .decode(
      ['address'],
      await ethers.provider.getStorageAt(contract, IMPLEMENTATION_ADDRESS_SLOT)
    )[0]
    .toLowerCase();

  expect(actual).to.equal(expected.toLowerCase());
}

type Permission = {
  where: string;
  who: string;
  isSet: boolean;
};

async function validatePermissions(dao: DAO, p1: Permission, p2: Permission) {
  const registerDAOPermission = ethers.utils.id('REGISTER_DAO_PERMISSION');
  const registerPluginRepoPermission = ethers.utils.id(
    'REGISTER_PLUGIN_REPO_PERMISSION'
  );

  expect(
    await dao.hasPermission(p1.where, p1.who, registerDAOPermission, '0x')
  ).to.be.equal(p1.isSet);
  expect(
    await dao.hasPermission(
      p2.where,
      p2.who,
      registerPluginRepoPermission,
      '0x'
    )
  ).to.be.equal(p2.isSet);
}

async function impersonateAccount(addr: string) {
  await hre.network.provider.send('hardhat_setBalance', [
    addr,
    '0x100000000000000',
  ]);

  await hre.network.provider.request({
    method: 'hardhat_impersonateAccount',
    params: [addr],
  });

  return ethers.getSigner(addr);
}

// This will need to be skipped after managing dao and framework is upgraded to 1.4.0
// and addresses are added in osx-commons. This is because update script and the below tests
// use `getLatestContractAddress` which is currently 1.3.0, but once update to 1.4.0 happens,
// getLatestContractAddress then will return 1.4.0 addresses.
skipTestSuiteIfNetworkIsZkSync('Update to 1.4.0', function () {
  let deployer: SignerWithAddress;

  before(async () => {
    await forkSepolia();

    [deployer] = await ethers.getSigners();
  });

  // Close fork so that other tests(not related to this file) are
  // not run in forked network.
  after(async () => {
    closeFork();
  });

  it('should update dao, daoRegistry, PluginRepoRegistry and set permissions correctly', async () => {
    const previousPluginRepoFactory = getAddress('PluginRepoFactory');
    const previousDAOFactoryAddress = getAddress('DAOFactory');

    const dao = DAO__factory.connect(
      getAddress('ManagementDAOProxy'),
      deployer
    );
    const daoRegistry = DAORegistry__factory.connect(
      getAddress('DAORegistryProxy'),
      deployer
    );
    const pluginRepoRegistry = PluginRepoRegistry__factory.connect(
      getAddress('PluginRepoRegistryProxy'),
      deployer
    );

    const multisigAddr = '0xfcead61339e3e73090b587968fce8b090e0600ef';

    await validatePermissions(
      dao,
      {
        where: daoRegistry.address,
        who: previousDAOFactoryAddress,
        isSet: true,
      },
      {
        where: pluginRepoRegistry.address,
        who: previousPluginRepoFactory,
        isSet: true,
      }
    );

    expect(await dao.protocolVersion()).to.deep.equal([1, 3, 0]);
    await expect(daoRegistry.protocolVersion()).to.be.reverted;
    await expect(pluginRepoRegistry.protocolVersion()).to.be.reverted;

    const oldDaoImplementation = await DAOFactory__factory.connect(
      previousDAOFactoryAddress,
      hre.ethers.provider
    ).daoBase();

    await assertImplementation(
      dao.address,
      getLatestContractAddress('ManagementDAOImplementation', hre)
    );
    await assertImplementation(
      daoRegistry.address,
      getLatestContractAddress('DAORegistryImplementation', hre)
    );
    await assertImplementation(
      pluginRepoRegistry.address,
      getLatestContractAddress('PluginRepoRegistryImplementation', hre)
    );

    await initializeDeploymentFixture('v1.4.0');

    let actions = hre.managementDAOActions.map(item => {
      return {to: item.to, value: item.value, data: item.data};
    });

    const signer = await impersonateAccount(multisigAddr);

    await dao
      .connect(signer)
      .execute(ethers.utils.id('someCallId'), actions, 0);

    await validatePermissions(
      dao,
      {
        where: daoRegistry.address,
        who: previousDAOFactoryAddress,
        isSet: true, // Makes sure we keep the the permission of the previouse DAO factory
      },
      {
        where: pluginRepoRegistry.address,
        who: previousPluginRepoFactory,
        isSet: false,
      }
    );

    const newDAOFactoryAddress = (await deployments.get('DAOFactory')).address;
    const newPluginRepoFactoryAddress = (
      await deployments.get('PluginRepoFactory')
    ).address;

    await validatePermissions(
      dao,
      {
        where: daoRegistry.address,
        who: newDAOFactoryAddress,
        isSet: true,
      },
      {
        where: pluginRepoRegistry.address,
        who: newPluginRepoFactoryAddress,
        isSet: true,
      }
    );

    expect(await dao.protocolVersion()).to.deep.equal([1, 4, 0]);
    expect(await daoRegistry.protocolVersion()).to.deep.equal([1, 4, 0]);
    expect(await pluginRepoRegistry.protocolVersion()).to.deep.equal([1, 4, 0]);

    const daoFactoryAddress = (await deployments.get('DAOFactory')).address;
    const newDaoImplementation = await DAOFactory__factory.connect(
      daoFactoryAddress,
      hre.ethers.provider
    ).daoBase();

    await assertImplementation(dao.address, newDaoImplementation);
    await assertImplementation(
      daoRegistry.address,
      (
        await deployments.get('DAORegistryImplementation')
      ).address
    );
    await assertImplementation(
      pluginRepoRegistry.address,
      (
        await deployments.get('PluginRepoRegistryImplementation')
      ).address
    );
  });

  it('Previous (v1.3) DAO Factory can still register DAOs', async () => {
    // get previouse DAO factory from OSx 1.4
    const previousDAOFactoryAddress = getAddress('DAOFactory');
    const daoFactory = new DAOFactory__factory(deployer).attach(
      previousDAOFactoryAddress
    );

    // publish a plugin based on OSx 1.4
    const pluginImp = await hre.wrapper.deploy('PluginUUPSUpgradeableV1Mock');
    const pluginSetupMock = await hre.wrapper.deploy(
      'PluginUUPSUpgradeableSetupV1Mock',
      {args: [pluginImp.address]}
    );

    const newPluginRepoFactoryAddress = (
      await deployments.get('PluginRepoFactory')
    ).address;

    const pluginRepoFactory = new PluginRepoFactory__factory(deployer).attach(
      newPluginRepoFactoryAddress
    );

    const tx = await pluginRepoFactory.createPluginRepoWithFirstVersion(
      'plugin-uupsupgradeable-setup-v1-mock',
      pluginSetupMock.address,
      deployer.address,
      '0x00',
      '0x00'
    );

    const event = findEventTopicLog<PluginRepoRegisteredEvent>(
      await tx.wait(),
      PluginRepoRegistry__factory.createInterface(),
      EVENTS.PluginRepoRegistered
    );

    const pluginSetupMockRepoAddress = event.args.pluginRepo;

    const pluginRepoPointer: PluginRepoPointer = [
      pluginSetupMockRepoAddress,
      1,
      1,
    ];

    // Get anticipated DAO contract
    const dao = await getAnticipatedAddress(previousDAOFactoryAddress);

    // Get dao registry
    const daoRegistryAddress = getAddress('DAORegistryProxy');
    const daoRegistryContract = new DAOFactory__factory(deployer).attach(
      daoRegistryAddress
    );

    expect(
      await daoFactory.createDao(daoSettings, [
        createPrepareInstallationParams(pluginRepoPointer, '0x'),
      ])
    )
      .to.emit(daoRegistryContract, EVENTS.DAORegistered)
      .withArgs(dao, deployer.address, daoSettings.subdomain);
  });
});


### File: /home/errick/core/packages/contracts/test/core/permission/permission-manager.ts ###
import {
  PermissionManagerTest,
  PermissionConditionMock,
  PermissionManagerTest__factory,
  PermissionConditionMock__factory,
} from '../../../typechain';
import {MultiTargetPermission, Operation} from '@aragon/osx-commons-sdk';
import {DAO_PERMISSIONS} from '@aragon/osx-commons-sdk';
import {PluginUUPSUpgradeableV1Mock__factory} from '@aragon/osx-ethers-v1.2.0';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

const ADMIN_PERMISSION_ID = ethers.utils.id('ADMIN_PERMISSION');
const RESTRICTED_PERMISSIONS_FOR_ANY_ADDR = [
  DAO_PERMISSIONS.ROOT_PERMISSION_ID,
  ethers.utils.id('TEST_PERMISSION_1'),
  ethers.utils.id('TEST_PERMISSION_2'),
];

const UNSET_FLAG = ethers.utils.getAddress(
  '0x0000000000000000000000000000000000000000'
);
const ALLOW_FLAG = ethers.utils.getAddress(
  '0x0000000000000000000000000000000000000002'
);
export const ANY_ADDR = '0xffffffffffffffffffffffffffffffffffffffff';

const addressZero = ethers.constants.AddressZero;

let conditionMock: PermissionConditionMock;

interface SingleTargetPermission {
  operation: Operation;
  who: string;
  permissionId: string;
}

describe('Core: PermissionManager', function () {
  let pm: PermissionManagerTest;
  let signers: SignerWithAddress[];
  let ownerSigner: SignerWithAddress;
  let otherSigner: SignerWithAddress;

  before(async () => {
    signers = await ethers.getSigners();
    ownerSigner = signers[0];
    otherSigner = signers[1];
  });

  beforeEach(async () => {
    pm = await hre.wrapper.deploy('PermissionManagerTest');
    await pm.init(ownerSigner.address);
  });

  describe('init', () => {
    it('should allow init call only once', async () => {
      await expect(pm.init(ownerSigner.address)).to.be.revertedWith(
        'Initializable: contract is already initialized'
      );
    });

    it('should emit Granted', async () => {
      pm = await hre.wrapper.deploy('PermissionManagerTest');
      await expect(pm.init(ownerSigner.address)).to.emit(pm, 'Granted');
    });

    it('should add ROOT_PERMISSION', async () => {
      const permission = await pm.getAuthPermission(
        pm.address,
        ownerSigner.address,
        DAO_PERMISSIONS.ROOT_PERMISSION_ID
      );
      expect(permission).to.be.equal(ALLOW_FLAG);
    });
  });

  describe('grant', () => {
    it('should add permission', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      const permission = await pm.getAuthPermission(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID
      );
      expect(permission).to.be.equal(ALLOW_FLAG);
    });

    it('reverts if both `_who == ANY_ADDR` and `_where == ANY_ADDR', async () => {
      await expect(
        pm.grant(ANY_ADDR, ANY_ADDR, DAO_PERMISSIONS.ROOT_PERMISSION_ID)
      ).to.be.revertedWithCustomError(pm, 'PermissionsForAnyAddressDisallowed');
    });

    it('reverts if permissionId is restricted and `_who == ANY_ADDR`', async () => {
      await expect(
        pm.grant(pm.address, ANY_ADDR, RESTRICTED_PERMISSIONS_FOR_ANY_ADDR[0])
      ).to.be.revertedWithCustomError(pm, 'PermissionsForAnyAddressDisallowed');
    });

    it('succeeds if permissionId is not restricted and `_who == ANY_ADDR`', async () => {
      await expect(pm.grant(pm.address, ANY_ADDR, ADMIN_PERMISSION_ID)).to.not
        .be.reverted;
    });

    it('reverts if permissionId is restricted and `_where == ANY_ADDR`', async () => {
      await expect(
        pm.grant(ANY_ADDR, pm.address, RESTRICTED_PERMISSIONS_FOR_ANY_ADDR[0])
      ).to.be.revertedWithCustomError(pm, 'PermissionsForAnyAddressDisallowed');
    });

    it('reverts if permissionId is not restricted and `_where == ANY_ADDR`', async () => {
      await expect(
        pm.grant(ANY_ADDR, pm.address, ADMIN_PERMISSION_ID)
      ).to.be.revertedWithCustomError(pm, 'PermissionsForAnyAddressDisallowed');
    });

    it('should emit Granted', async () => {
      await expect(
        pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      ).to.emit(pm, 'Granted');
    });

    it('should not emit granted event if already granted', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      ).to.not.emit(pm, 'Granted');
    });

    it('should not allow grant', async () => {
      await expect(
        pm
          .connect(otherSigner)
          .grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('should not allow for non ROOT', async () => {
      await pm.grant(pm.address, ownerSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm
          .connect(otherSigner)
          .grant(
            pm.address,
            otherSigner.address,
            DAO_PERMISSIONS.ROOT_PERMISSION_ID
          )
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });
  });

  describe('grantWithCondition', () => {
    before(async () => {
      conditionMock = await hre.wrapper.deploy('PermissionConditionMock');
    });

    it('reverts if the condition address is not a contract', async () => {
      await expect(
        pm.grantWithCondition(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          ethers.constants.AddressZero
        )
      )
        .to.be.revertedWithCustomError(pm, 'ConditionNotAContract')
        .withArgs(ethers.constants.AddressZero);
    });

    it('reverts if the condition contract does not support `IPermissionConditon`', async () => {
      const nonConditionContract = await hre.wrapper.deploy(
        'PluginUUPSUpgradeableV1Mock'
      );

      await expect(
        pm.grantWithCondition(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          nonConditionContract.address
        )
      )
        .to.be.revertedWithCustomError(pm, 'ConditionInterfaceNotSupported')
        .withArgs(nonConditionContract.address);
    });

    it('should add permission', async () => {
      await pm.grantWithCondition(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        conditionMock.address
      );
      const permission = await pm.getAuthPermission(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID
      );
      expect(permission).to.be.equal(conditionMock.address);
    });

    it('should emit Granted', async () => {
      await expect(
        pm.grantWithCondition(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          conditionMock.address
        )
      ).to.emit(pm, 'Granted');
    });

    it('should emit Granted when condition is present and `who == ANY_ADDR` or `where == ANY_ADDR`', async () => {
      await expect(
        pm.grantWithCondition(
          pm.address,
          ANY_ADDR,
          ADMIN_PERMISSION_ID,
          conditionMock.address
        )
      ).to.emit(pm, 'Granted');

      await expect(
        pm.grantWithCondition(
          ANY_ADDR,
          pm.address,
          ADMIN_PERMISSION_ID,
          conditionMock.address
        )
      ).to.emit(pm, 'Granted');
    });

    it('should not emit Granted with already granted with the same condition or ALLOW_FLAG', async () => {
      await pm.grantWithCondition(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        conditionMock.address
      );
      await expect(
        pm.grantWithCondition(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          conditionMock.address
        )
      ).to.not.emit(pm, 'Granted');
    });

    it('reverts if tries to grant the same permission, but with different condition', async () => {
      await pm.grantWithCondition(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        conditionMock.address
      );

      const newConditionMock = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );

      await expect(
        pm.grantWithCondition(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          newConditionMock.address
        )
      )
        .to.be.revertedWithCustomError(
          pm,
          'PermissionAlreadyGrantedForDifferentCondition'
        )
        .withArgs(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          conditionMock.address,
          newConditionMock.address
        );
    });

    it('should set PermissionCondition', async () => {
      await pm.grantWithCondition(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        conditionMock.address
      );
      expect(
        await pm.getAuthPermission(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID
        )
      ).to.be.equal(conditionMock.address);
    });

    it('should not allow grant', async () => {
      await expect(
        pm
          .connect(otherSigner)
          .grantWithCondition(
            pm.address,
            otherSigner.address,
            ADMIN_PERMISSION_ID,
            conditionMock.address
          )
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('reverts if the caller does not have `ROOT_PERMISSION_ID`', async () => {
      await pm.grantWithCondition(
        pm.address,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        conditionMock.address
      );
      await expect(
        pm
          .connect(otherSigner)
          .grantWithCondition(
            pm.address,
            otherSigner.address,
            DAO_PERMISSIONS.ROOT_PERMISSION_ID,
            conditionMock.address
          )
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });
  });

  describe('revoke', () => {
    it('should revoke', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await pm.revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      const permission = await pm.getAuthPermission(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID
      );
      expect(permission).to.be.equal(UNSET_FLAG);
    });

    it('should emit Revoked', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm.revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      ).to.emit(pm, 'Revoked');
    });

    it('should revert if not granted', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm
          .connect(otherSigner)
          .revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('should not emit revoked if already revoked', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await pm.revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm.revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      ).to.not.emit(pm, 'Revoked');
    });

    it('should not allow', async () => {
      await expect(
        pm
          .connect(otherSigner)
          .revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('should not allow for non ROOT', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      await expect(
        pm
          .connect(otherSigner)
          .revoke(pm.address, otherSigner.address, ADMIN_PERMISSION_ID)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });
  });

  describe('bulk on multiple target', () => {
    it('should bulk grant ADMIN_PERMISSION on different targets', async () => {
      const signers = await ethers.getSigners();
      await pm.grant(pm.address, signers[0].address, ADMIN_PERMISSION_ID);
      const bulkItems: MultiTargetPermission[] = [
        {
          operation: Operation.Grant,
          where: signers[1].address,
          who: signers[2].address,
          condition: addressZero,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Grant,
          where: signers[2].address,
          who: signers[3].address,
          condition: addressZero,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];

      await pm.applyMultiTargetPermissions(bulkItems);
      for (const item of bulkItems) {
        const permission = await pm.getAuthPermission(
          item.where,
          item.who,
          item.permissionId
        );
        expect(permission).to.be.equal(ALLOW_FLAG);
      }
    });

    it('should bulk revoke', async () => {
      const signers = await ethers.getSigners();
      await pm.grant(
        signers[1].address,
        signers[0].address,
        ADMIN_PERMISSION_ID
      );
      await pm.grant(
        signers[2].address,
        signers[0].address,
        ADMIN_PERMISSION_ID
      );
      const bulkItems: MultiTargetPermission[] = [
        {
          operation: Operation.Revoke,
          where: signers[1].address,
          who: signers[0].address,
          condition: addressZero,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Revoke,
          where: signers[2].address,
          who: signers[0].address,
          condition: addressZero,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await pm.applyMultiTargetPermissions(bulkItems);
      for (const item of bulkItems) {
        const permission = await pm.getAuthPermission(
          item.where,
          item.who,
          item.permissionId
        );
        expect(permission).to.be.equal(UNSET_FLAG);
      }
    });

    it('should revert if non-zero condition is used with `grant` operation type', async () => {
      const signers = await ethers.getSigners();

      const conditionMock = await hre.wrapper.deploy('PermissionConditionMock');

      const bulkItems: MultiTargetPermission[] = [
        {
          operation: Operation.Grant,
          where: signers[1].address,
          who: signers[0].address,
          condition: conditionMock.address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];

      await expect(
        pm.applyMultiTargetPermissions(bulkItems)
      ).to.be.revertedWithCustomError(pm, 'GrantWithConditionNotSupported');
    });

    // TODO:Claudia see why this fails here and not on develop branch.
    it('should grant with condition', async () => {
      const signers = await ethers.getSigners();

      const conditionMock2 = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );

      await pm.grant(pm.address, signers[0].address, ADMIN_PERMISSION_ID);
      const bulkItems: MultiTargetPermission[] = [
        {
          operation: Operation.GrantWithCondition,
          where: signers[1].address,
          who: signers[0].address,
          condition: conditionMock.address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.GrantWithCondition,
          where: signers[2].address,
          who: signers[0].address,
          condition: conditionMock2.address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await pm.applyMultiTargetPermissions(bulkItems);
      for (const item of bulkItems) {
        const permission = await pm.getAuthPermission(
          item.where,
          item.who,
          item.permissionId
        );
        expect(permission).to.be.equal(item.condition);
      }
    });

    it('throws Unauthorized error when caller does not have ROOT_PERMISSION_ID permission', async () => {
      const signers = await ethers.getSigners();
      const bulkItems: MultiTargetPermission[] = [
        {
          operation: Operation.Grant,
          where: signers[1].address,
          who: signers[0].address,
          condition: addressZero,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];

      await expect(
        pm.connect(signers[2]).applyMultiTargetPermissions(bulkItems)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          signers[2].address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });
  });

  describe('bulk on single target', () => {
    it('should bulk grant ADMIN_PERMISSION', async () => {
      const signers = await ethers.getSigners();
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Grant,
          who: signers[1].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Grant,
          who: signers[2].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Grant,
          who: signers[3].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await pm.applySingleTargetPermissions(pm.address, bulkItems);
      for (const item of bulkItems) {
        const permission = await pm.getAuthPermission(
          pm.address,
          item.who,
          item.permissionId
        );
        expect(permission).to.be.equal(ALLOW_FLAG);
      }
    });

    it('should bulk revoke', async () => {
      const signers = await ethers.getSigners();
      await pm.grant(pm.address, signers[1].address, ADMIN_PERMISSION_ID);
      await pm.grant(pm.address, signers[2].address, ADMIN_PERMISSION_ID);
      await pm.grant(pm.address, signers[3].address, ADMIN_PERMISSION_ID);
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Revoke,
          who: signers[1].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Revoke,
          who: signers[2].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Revoke,
          who: signers[3].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await pm.applySingleTargetPermissions(pm.address, bulkItems);
      for (const item of bulkItems) {
        const permission = await pm.getAuthPermission(
          pm.address,
          item.who,
          item.permissionId
        );
        expect(permission).to.be.equal(UNSET_FLAG);
      }
    });

    it('reverts for `Operation.GrantWithCondition` ', async () => {
      const signers = await ethers.getSigners();
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.GrantWithCondition,
          who: signers[1].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await expect(
        pm.applySingleTargetPermissions(pm.address, bulkItems)
      ).to.be.revertedWithCustomError(pm, 'GrantWithConditionNotSupported');
    });

    it('should handle bulk mixed', async () => {
      const signers = await ethers.getSigners();
      await pm.grant(pm.address, signers[1].address, ADMIN_PERMISSION_ID);
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Revoke,
          who: signers[1].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Grant,
          who: signers[2].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];

      await pm.applySingleTargetPermissions(pm.address, bulkItems);
      expect(
        await pm.getAuthPermission(
          pm.address,
          signers[1].address,
          ADMIN_PERMISSION_ID
        )
      ).to.be.equal(UNSET_FLAG);
      expect(
        await pm.getAuthPermission(
          pm.address,
          signers[2].address,
          ADMIN_PERMISSION_ID
        )
      ).to.be.equal(ALLOW_FLAG);
    });

    it('should emit correct events on bulk', async () => {
      const signers = await ethers.getSigners();
      await pm.grant(pm.address, signers[1].address, ADMIN_PERMISSION_ID);
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Revoke,
          who: signers[1].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
        {
          operation: Operation.Grant,
          who: signers[2].address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];

      await expect(pm.applySingleTargetPermissions(pm.address, bulkItems))
        .to.emit(pm, 'Revoked')
        .withArgs(
          ADMIN_PERMISSION_ID,
          ownerSigner.address,
          pm.address,
          signers[1].address
        )
        .to.emit(pm, 'Granted')
        .withArgs(
          ADMIN_PERMISSION_ID,
          ownerSigner.address,
          pm.address,
          signers[2].address,
          ALLOW_FLAG
        );
      expect(
        await pm.getAuthPermission(
          pm.address,
          signers[2].address,
          ADMIN_PERMISSION_ID
        )
      ).to.be.equal(ALLOW_FLAG);
    });

    it('should not allow', async () => {
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Grant,
          who: otherSigner.address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await expect(
        pm
          .connect(otherSigner)
          .applySingleTargetPermissions(pm.address, bulkItems)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('should not allow for non ROOT', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      const bulkItems: SingleTargetPermission[] = [
        {
          operation: Operation.Grant,
          who: otherSigner.address,
          permissionId: ADMIN_PERMISSION_ID,
        },
      ];
      await expect(
        pm
          .connect(otherSigner)
          .applySingleTargetPermissions(pm.address, bulkItems)
      )
        .to.be.revertedWithCustomError(pm, 'Unauthorized')
        .withArgs(
          pm.address,
          otherSigner.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });
  });

  describe('isGranted', () => {
    it('returns `true` if the permission is granted to the user', async () => {
      await pm.grant(pm.address, otherSigner.address, ADMIN_PERMISSION_ID);
      const isGranted = await pm.callStatic.isGranted(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        []
      );
      expect(isGranted).to.be.equal(true);
    });

    it('returns `false` if the permission is not granted to the user', async () => {
      const isGranted = await pm.callStatic.isGranted(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        []
      );
      expect(isGranted).to.be.equal(false);
    });

    it('returns `true` if a condition is set for a specific caller and target answering `true`', async () => {
      const condition = await hre.wrapper.deploy('PermissionConditionMock');

      await pm.grantWithCondition(
        pm.address,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        condition.address
      );
      await condition.setAnswer(true);

      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.true;
    });

    it('returns `true` if a condition is set for a generic caller answering `true`', async () => {
      const condition = await hre.wrapper.deploy('PermissionConditionMock');

      await pm.grantWithCondition(
        pm.address,
        ANY_ADDR,
        ADMIN_PERMISSION_ID,
        condition.address
      );
      await condition.setAnswer(true);

      // Check `ownerSigner.address` as a caller `_who`
      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.true;

      // Check `otherSigner.address` as a caller `_who`
      expect(
        await pm.isGranted(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.true;

      // Check that `false` is returned if `address(0)` is the target `_where`.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.false;
    });

    it('returns `true` if a condition is set for a generic target answering `true`', async () => {
      const condition = await hre.wrapper.deploy('PermissionConditionMock');

      await pm.grantWithCondition(
        ANY_ADDR,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        condition.address
      );
      await condition.setAnswer(true);

      // Check `pm.address` as a target `_where`
      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.true;

      // Check `address(0)` as a target `_where`
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.true;

      // Check that `false` is returned if `otherSigner is the caller `_who`.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          condition.address
        )
      ).to.be.false;
    });

    it('should be callable by anyone', async () => {
      const isGranted = await pm
        .connect(otherSigner)
        .callStatic.isGranted(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          []
        );
      expect(isGranted).to.be.equal(false);
    });

    it('does not fall back to a generic caller or target condition if a specific condition is set already answering `false`', async () => {
      const specificCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      const genericCallerCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      const genericTargetCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );

      // Grant with a specific condition that will answer false
      await pm.grantWithCondition(
        pm.address,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        specificCondition.address
      );
      await specificCondition.setAnswer(false);

      // Grant with a generic caller condition that will answer true
      await pm.grantWithCondition(
        pm.address,
        ANY_ADDR,
        ADMIN_PERMISSION_ID,
        genericCallerCondition.address
      );
      await genericCallerCondition.setAnswer(true);

      // Grant with a generic target condition that will answer true
      await pm.grantWithCondition(
        ANY_ADDR,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        genericTargetCondition.address
      );
      await genericCallerCondition.setAnswer(true);

      // Check that `isGranted` returns false for `ownerSigner` to whom the specific condition was granted.
      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.false;

      // Check that `ownerSigner` is still granted access to other contracts (e.g., `address(0)`) through the `genericTargetCondition` condition.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.true;
    });

    it('does not fall back to a generic target condition if a generic caller condition is set already answering `false`', async () => {
      const genericCallerCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      const genericTargetCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      // Grant with a generic caller condition that will answer false.
      await pm.grantWithCondition(
        pm.address,
        ANY_ADDR,
        ADMIN_PERMISSION_ID,
        genericCallerCondition.address
      );
      await genericCallerCondition.setAnswer(false);

      // Grant with a generic target condition that will answer true.
      await pm.grantWithCondition(
        ANY_ADDR,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        genericTargetCondition.address
      );
      await genericTargetCondition.setAnswer(true);

      // Check that `isGranted` returns false for `ANY_ADDR` (here, we check only two addresses, `ownerSigner` and `otherSigner`).
      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.false;
      expect(
        await pm.isGranted(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.false;

      // Check that `ownerSigner` is granted access to other contracts (e.g., `address(0)`) via the `genericTargetCondition` condition.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.true;

      // Check that `otherSigner` is not granted access to other contracts (e.g., `address(0)`) via the `genericTargetCondition` condition.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.false;
    });

    it('does not fall back to a generic caller or target condition if a specific condition is set already answering `false`', async () => {
      const specificCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      const genericCallerCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );
      const genericTargetCondition = await hre.wrapper.deploy(
        'PermissionConditionMock'
      );

      // Grant with a specific condition that will answer false
      await pm.grantWithCondition(
        pm.address,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        specificCondition.address
      );
      await specificCondition.setAnswer(false);

      // Grant with a generic caller condition that will answer true
      await pm.grantWithCondition(
        pm.address,
        ANY_ADDR,
        ADMIN_PERMISSION_ID,
        genericCallerCondition.address
      );
      await genericCallerCondition.setAnswer(true);

      // Grant with a generic target condition that will answer true
      await pm.grantWithCondition(
        ANY_ADDR,
        ownerSigner.address,
        ADMIN_PERMISSION_ID,
        genericTargetCondition.address
      );
      await genericCallerCondition.setAnswer(true);

      // Check that `isGranted` returns false for `ownerSigner` to whom the specific condition was granted.
      expect(
        await pm.isGranted(
          pm.address,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.false;

      // Check that `ownerSigner` is still granted access to other contracts (e.g., `address(0)`) through the `genericTargetCondition` condition.
      expect(
        await pm.isGranted(
          ethers.constants.AddressZero,
          ownerSigner.address,
          ADMIN_PERMISSION_ID,
          genericTargetCondition.address
        )
      ).to.be.true;
    });

    it('returns `true` if the permission is granted to `_who == ANY_ADDR`', async () => {
      await pm.grant(pm.address, ANY_ADDR, ADMIN_PERMISSION_ID);
      const isGranted = await pm.callStatic.isGranted(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        []
      );
      expect(isGranted).to.be.equal(true);
    });
  });

  describe('_hasPermission', () => {
    let permissionCondition: PermissionConditionMock;

    beforeEach(async () => {
      permissionCondition = await hre.wrapper.deploy('PermissionConditionMock');
    });

    it('should call IPermissionCondition.isGranted', async () => {
      await pm.grantWithCondition(
        pm.address,
        otherSigner.address,
        ADMIN_PERMISSION_ID,
        permissionCondition.address
      );
      expect(
        await pm.callStatic.isGranted(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          []
        )
      ).to.be.equal(true);

      await permissionCondition.setAnswer(false);
      expect(
        await pm.callStatic.isGranted(
          pm.address,
          otherSigner.address,
          ADMIN_PERMISSION_ID,
          []
        )
      ).to.be.equal(false);
    });
  });

  describe('helpers', () => {
    it('should hash PERMISSIONS', async () => {
      const packed = ethers.utils.solidityPack(
        ['string', 'address', 'address', 'address'],
        [
          'PERMISSION',
          ownerSigner.address,
          pm.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
        ]
      );
      const hash = ethers.utils.keccak256(packed);
      const contractHash = await pm.getPermissionHash(
        pm.address,
        ownerSigner.address,
        DAO_PERMISSIONS.ROOT_PERMISSION_ID
      );
      expect(hash).to.be.equal(contractHash);
    });
  });
});


### File: /home/errick/core/packages/contracts/test/core/dao/dao.ts ###
import {
  DAO,
  ERC20Mock,
  ERC20Mock__factory,
  ERC721Mock,
  ERC721Mock__factory,
  ERC1155Mock,
  ERC1155Mock__factory,
  GasConsumer__factory,
  DAO__factory,
  IDAO__factory,
  IERC165__factory,
  IERC721Receiver__factory,
  IERC1155Receiver__factory,
  IERC1271__factory,
  IEIP4824__factory,
  IProtocolVersion__factory,
  PermissionConditionMock__factory,
  PermissionConditionMock,
  IExecutor__factory,
} from '../../../typechain';
import {DAO__factory as DAO_V1_0_0__factory} from '../../../typechain/@aragon/osx-v1.0.1/core/dao/DAO.sol';
import {IDAO__factory as IDAO_V1_0_0_factory} from '../../../typechain/@aragon/osx-v1.0.1/core/dao/IDAO.sol';
import {DAO__factory as DAO_V1_3_0__factory} from '../../../typechain/@aragon/osx-v1.3.0/core/dao/DAO.sol';
import {IDAO__factory as IDAO_V3_0_0_factory} from '../../../typechain/@aragon/osx-v1.3.0/core/dao/IDAO.sol';
import {ExecutedEvent} from '../../../typechain/DAO';
import {
  getActions,
  getERC1155TransferAction,
  getERC20TransferAction,
  getERC721TransferAction,
  TOKEN_INTERFACE_IDS,
} from '../../test-utils/dao';
import {ZERO_BYTES32, daoExampleURI} from '../../test-utils/dao';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {skipTestIfNetworkIsZkSync} from '../../test-utils/skip-functions';
import {
  deployAndUpgradeFromToCheck,
  deployAndUpgradeSelfCheck,
} from '../../test-utils/uups-upgradeable';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {ANY_ADDR} from '../permission/permission-manager';
import {UNREGISTERED_INTERFACE_RETURN} from './callback-handler';
import {
  findEvent,
  flipBit,
  getInterfaceId,
  DAO_PERMISSIONS,
  getProtocolVersion,
  IMPLICIT_INITIAL_PROTOCOL_VERSION,
} from '@aragon/osx-commons-sdk';
import {smock} from '@defi-wonderland/smock';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import chai, {expect} from 'chai';
import {ContractFactory} from 'ethers';
import hre, {ethers} from 'hardhat';

chai.use(smock.matchers);

const errorSignature = '0x08c379a0'; // first 4 bytes of Error(string)

const dummyAddress1 = '0x0000000000000000000000000000000000000001';
const dummyAddress2 = '0x0000000000000000000000000000000000000002';
const dummyMetadata1 = '0x0001';
const dummyMetadata2 = '0x0002';
const MAX_ACTIONS = 256;

const OZ_INITIALIZED_SLOT_POSITION = 0;
const REENTRANCY_STATUS_SLOT_POSITION = 304;

const EMPTY_DATA = '0x';

const EVENTS = {
  MetadataSet: 'MetadataSet',
  TrustedForwarderSet: 'TrustedForwarderSet',
  DAOCreated: 'DAOCreated',
  Granted: 'Granted',
  Revoked: 'Revoked',
  Deposited: 'Deposited',
  Executed: 'Executed',
  NativeTokenDeposited: 'NativeTokenDeposited',
  StandardCallbackRegistered: 'StandardCallbackRegistered',
  CallbackReceived: 'CallbackReceived',
};

export const VALID_ERC1271_SIGNATURE = '0x1626ba7e';
export const INVALID_ERC1271_SIGNATURE = '0xffffffff';

describe('DAO', function () {
  let signers: SignerWithAddress[];
  let ownerAddress: string;
  let dao: DAO;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();
  });

  beforeEach(async function () {
    dao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {withProxy: true});

    await dao.initialize(
      dummyMetadata1,
      ownerAddress,
      dummyAddress1,
      daoExampleURI
    );

    // Grant permissions
    await dao.grant(
      dao.address,
      ownerAddress,
      DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID
    );
    await dao.grant(
      dao.address,
      ownerAddress,
      DAO_PERMISSIONS.EXECUTE_PERMISSION_ID
    );
    await dao.grant(
      dao.address,
      ownerAddress,
      DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
    );
    await dao.grant(
      dao.address,
      ownerAddress,
      DAO_PERMISSIONS.SET_TRUSTED_FORWARDER_PERMISSION_ID
    );
    await dao.grant(
      dao.address,
      ownerAddress,
      DAO_PERMISSIONS.REGISTER_STANDARD_CALLBACK_PERMISSION_ID
    );
  });

  describe('initialize', async () => {
    it('reverts if trying to re-initialize', async () => {
      await expect(
        dao.initialize(
          dummyMetadata1,
          ownerAddress,
          dummyAddress1,
          daoExampleURI
        )
      ).to.be.revertedWithCustomError(dao, 'AlreadyInitialized');
    });

    it('initializes with the correct trusted forwarder', async () => {
      expect(await dao.getTrustedForwarder()).to.be.equal(dummyAddress1);
    });

    it('initializes with the correct token interfaces', async () => {
      const callbacksReturned = await Promise.all([
        ethers.provider.call({
          to: dao.address,
          data: TOKEN_INTERFACE_IDS.erc721ReceivedId,
        }),
        ethers.provider.call({
          to: dao.address,
          data: TOKEN_INTERFACE_IDS.erc1155ReceivedId,
        }),
        ethers.provider.call({
          to: dao.address,
          data: TOKEN_INTERFACE_IDS.erc1155BatchReceivedId,
        }),
      ]);

      // confirm callbacks are registered.
      expect(callbacksReturned[0]).to.equal(
        TOKEN_INTERFACE_IDS.erc721ReceivedId + '00'.repeat(28)
      );
      expect(callbacksReturned[1]).to.equal(
        TOKEN_INTERFACE_IDS.erc1155ReceivedId + '00'.repeat(28)
      );
      expect(callbacksReturned[2]).to.equal(
        TOKEN_INTERFACE_IDS.erc1155BatchReceivedId + '00'.repeat(28)
      );
    });

    it('sets OZs `_initialized` at storage slot [0] to 3', async () => {
      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            dao.address,
            OZ_INITIALIZED_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(3);
    });

    it('sets the `_reentrancyStatus` at storage slot [304] to `_NOT_ENTERED = 1`', async () => {
      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            dao.address,
            REENTRANCY_STATUS_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(1);
    });
  });

  describe('initializeFrom', async () => {
    it('reverts if trying to upgrade from a different major release', async () => {
      const uninitializedDao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {
        withProxy: true,
      });

      await expect(uninitializedDao.initializeFrom([0, 1, 0], EMPTY_DATA))
        .to.be.revertedWithCustomError(
          dao,
          'ProtocolVersionUpgradeNotSupported'
        )
        .withArgs([0, 1, 0]);
    });

    it('increments `_initialized` to `3`', async () => {
      // Create an unitialized DAO.
      const uninitializedDao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {
        withProxy: true,
      });

      // Expect the contract to be uninitialized  with `_initialized = 0`.
      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            OZ_INITIALIZED_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(0);

      // Call `initializeFrom` with version 1.2.0.
      await expect(uninitializedDao.initializeFrom([1, 2, 0], EMPTY_DATA)).to
        .not.be.reverted;

      // Expect the contract to be initialized with `_initialized = 3`.
      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            OZ_INITIALIZED_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(3);
    });

    it('initializes `_reentrancyStatus` for versions < 1.3.0', async () => {
      // Create an uninitialized DAO.
      const uninitializedDao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {
        withProxy: true,
      });

      // Expect the contract to be uninitialized  with `_reentrancyStatus = 0`.

      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            REENTRANCY_STATUS_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(0);

      // Call `initializeFrom` with version 1.2.0.
      await expect(uninitializedDao.initializeFrom([1, 2, 0], EMPTY_DATA)).to
        .not.be.reverted;

      // Expect the contract to be initialized with `_reentrancyStatus = 1`.
      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            REENTRANCY_STATUS_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(1);
    });

    it('does not initialize `_reentrancyStatus` for versions >= 1.3.0', async () => {
      // Create an uninitialized DAO.
      const uninitializedDao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {
        withProxy: true,
      });

      // Expect the contract to be uninitialized  with `_reentrancyStatus = 0`.

      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            REENTRANCY_STATUS_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(0);

      // Call `initializeFrom` with version 1.3.0.
      await expect(uninitializedDao.initializeFrom([1, 3, 0], EMPTY_DATA)).to
        .not.be.reverted;

      // Expect `_reentrancyStatus` to remain unchanged.

      expect(
        ethers.BigNumber.from(
          await ethers.provider.getStorageAt(
            uninitializedDao.address,
            REENTRANCY_STATUS_SLOT_POSITION
          )
        ).toNumber()
      ).to.equal(0);
    });

    it('registers IExecutor interface for versions < 1.4.0', async () => {
      // Create an uninitialized DAO.
      const uninitializedDao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {
        withProxy: true,
      });

      expect(
        await uninitializedDao.supportsInterface(
          getInterfaceId(IExecutor__factory.createInterface())
        )
      ).to.be.false;

      await uninitializedDao.initializeFrom([1, 3, 0], EMPTY_DATA);

      expect(
        await uninitializedDao.supportsInterface(
          getInterfaceId(IExecutor__factory.createInterface())
        )
      ).to.be.true;
    });
  });

  describe('Upgrades', async () => {
    let legacyContractFactory: ContractFactory;
    let currentContractFactory: ContractFactory;
    let initArgs: any;

    const IExecutorInterfaceId = getInterfaceId(
      IExecutor__factory.createInterface()
    );

    before(() => {
      currentContractFactory = new DAO__factory(signers[0]);

      initArgs = {
        metadata: dummyMetadata1,
        initialOwner: signers[0].address,
        trustedForwarder: dummyAddress1,
        daoURI: daoExampleURI,
      };
    });

    it('upgrades to a new implementation', async () => {
      await deployAndUpgradeSelfCheck(
        0,
        1,
        {
          initArgs: {
            metadata: dummyMetadata1,
            initialOwner: signers[0].address,
            trustedForwarder: dummyAddress1,
            daoURI: daoExampleURI,
          },
          initializer: 'initialize',
        },
        ARTIFACT_SOURCES.DAO,
        ARTIFACT_SOURCES.DAO,
        DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
      );
    });

    it('from v1.0.0', async () => {
      legacyContractFactory = new DAO_V1_0_0__factory(signers[0]);

      const {proxy, fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.DAO_V1_0_0,
          ARTIFACT_SOURCES.DAO,
          DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
        );

      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal(
        IMPLICIT_INITIAL_PROTOCOL_VERSION
      );
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());

      await proxy.initializeFrom([1, 0, 0], EMPTY_DATA);

      // Check that it still supports old interfaceId for backwards compatibility.
      expect(
        await proxy.supportsInterface(
          getInterfaceId(IDAO_V1_0_0_factory.createInterface())
        )
      ).to.be.true;

      expect(await proxy.supportsInterface(IExecutorInterfaceId)).to.be.true;
    });

    it('from v1.3.0', async () => {
      legacyContractFactory = new DAO_V1_3_0__factory(signers[0]);

      const {proxy, fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.DAO_V1_3_0,
          ARTIFACT_SOURCES.DAO,
          DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 3, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());

      await proxy.initializeFrom([1, 3, 0], EMPTY_DATA);

      // Check that it still supports old interfaceId for backwards compatibility.
      expect(
        await proxy.supportsInterface(
          getInterfaceId(IDAO_V3_0_0_factory.createInterface())
        )
      ).to.be.true;

      expect(await proxy.supportsInterface(IExecutorInterfaceId)).to.be.true;
    });
  });

  describe('ERC-165', async () => {
    it('does not support the empty interface', async () => {
      expect(await dao.supportsInterface('0xffffffff')).to.be.false;
    });

    it('supports the `IERC165` interface', async () => {
      const iface = IERC165__factory.createInterface();
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IDAO` interface', async () => {
      const iface = IDAO__factory.createInterface();
      expect(getInterfaceId(iface)).to.equal('0x9385547e'); // the interfaceID from IDAO v1.0.0
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IExecutor` interface', async () => {
      const iface = IExecutor__factory.createInterface();
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IProtocolVersion` interface', async () => {
      const iface = IProtocolVersion__factory.createInterface();
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IERC1271` interface', async () => {
      const iface = IERC1271__factory.createInterface();
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IEIP4824` interface', async () => {
      const iface = IEIP4824__factory.createInterface();
      expect(await dao.supportsInterface(getInterfaceId(iface))).to.be.true;
    });

    it('supports the `IERC721Receiver` interface', async () => {
      expect(
        await dao.supportsInterface(TOKEN_INTERFACE_IDS.erc1155InterfaceId)
      ).to.be.true;
    });

    it('supports the `IERC1155Receiver` interface', async () => {
      expect(
        await dao.supportsInterface(TOKEN_INTERFACE_IDS.erc1155InterfaceId)
      ).to.be.true;
    });
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await dao.protocolVersion()).to.deep.equal(osxContractsVersion());
    });
  });

  describe('setTrustedForwarder:', async () => {
    it('reverts if the sender lacks the required permissionId', async () => {
      await dao.revoke(
        dao.address,
        ownerAddress,
        DAO_PERMISSIONS.SET_TRUSTED_FORWARDER_PERMISSION_ID
      );

      await expect(dao.setTrustedForwarder(dummyAddress2))
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs(
          dao.address,
          ownerAddress,
          DAO_PERMISSIONS.SET_TRUSTED_FORWARDER_PERMISSION_ID
        );
    });

    it('sets a new trusted forwarder', async () => {
      await dao.setTrustedForwarder(dummyAddress2);
      expect(await dao.getTrustedForwarder()).to.be.equal(dummyAddress2);
    });

    it('emits an event containing the address', async () => {
      await expect(dao.setTrustedForwarder(dummyAddress2))
        .to.emit(dao, EVENTS.TrustedForwarderSet)
        .withArgs(dummyAddress2);
    });
  });

  describe('setMetadata:', async () => {
    it('reverts if the sender lacks the required permissionId', async () => {
      await dao.revoke(
        dao.address,
        ownerAddress,
        DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID
      );

      await expect(dao.setMetadata(dummyMetadata1))
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs(
          dao.address,
          ownerAddress,
          DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID
        );
    });

    it('sets new metadata via an event', async () => {
      await expect(dao.setMetadata(dummyMetadata2))
        .to.emit(dao, EVENTS.MetadataSet)
        .withArgs(dummyMetadata2);
    });
  });

  describe('execute:', async () => {
    let data: any;
    before(async () => {
      data = await getActions();
    });

    it('reverts if the sender lacks the required permissionId', async () => {
      await dao.revoke(
        dao.address,
        ownerAddress,
        DAO_PERMISSIONS.EXECUTE_PERMISSION_ID
      );

      await expect(dao.execute(ZERO_BYTES32, [data.succeedAction], 0))
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs(
          dao.address,
          ownerAddress,
          DAO_PERMISSIONS.EXECUTE_PERMISSION_ID
        );
    });

    it('reverts if array of actions is too big', async () => {
      let actions = [];
      for (let i = 0; i < MAX_ACTIONS; i++) {
        actions[i] = data.succeedAction;
      }

      await expect(dao.execute(ZERO_BYTES32, actions, 0)).not.to.be.reverted;

      // add one more to make sure it fails
      actions[MAX_ACTIONS] = data.failAction;

      await expect(
        dao.execute(ZERO_BYTES32, actions, 0)
      ).to.be.revertedWithCustomError(dao, 'TooManyActions');
    });

    it("reverts if action is failable and allowFailureMap doesn't include it", async () => {
      await expect(dao.execute(ZERO_BYTES32, [data.failAction], 0))
        .to.be.revertedWithCustomError(dao, 'ActionFailed')
        .withArgs(0);
    });

    it('reverts on re-entrant actions', async () => {
      // Grant DAO execute permission on itself.
      await dao.grant(
        dao.address,
        dao.address,
        DAO_PERMISSIONS.EXECUTE_PERMISSION_ID
      );

      // Create a reentrant action calling `dao.execute` again.
      const reentrantAction = {
        to: dao.address,
        data: dao.interface.encodeFunctionData('execute', [
          ZERO_BYTES32,
          [data.succeedAction],
          0,
        ]),
        value: 0,
      };

      // Create  an action array with an normal action and an reentrant action.
      const actions = [data.succeedAction, reentrantAction];

      // Expect the execution of the reentrant action (second action) to fail.
      await expect(dao.execute(ZERO_BYTES32, actions, 0))
        .to.be.revertedWithCustomError(dao, 'ActionFailed')
        .withArgs(1);
    });

    it('succeeds if action is failable but allowFailureMap allows it', async () => {
      let num = ethers.BigNumber.from(0);
      num = flipBit(0, num);

      const tx = await dao.execute(ZERO_BYTES32, [data.failAction], num);
      const event = findEvent<ExecutedEvent>(await tx.wait(), EVENTS.Executed);

      // Check that failAction's revertMessage was correctly stored in the dao's execResults
      expect(event.args.execResults[0]).to.includes(data.failActionMessage);
      expect(event.args.execResults[0]).to.includes(errorSignature);
    });

    it('returns the correct result if action succeeds', async () => {
      const tx = await dao.execute(ZERO_BYTES32, [data.succeedAction], 0);
      const event = findEvent<ExecutedEvent>(await tx.wait(), EVENTS.Executed);
      expect(event.args.execResults[0]).to.equal(data.successActionResult);
    });

    it('succeeds and correctly constructs failureMap results ', async () => {
      let allowFailureMap = ethers.BigNumber.from(0);
      let actions = [];

      // First 3 actions will fail
      actions[0] = data.failAction;
      actions[1] = data.failAction;
      actions[2] = data.failAction;

      // The next 3 actions will succeed
      actions[3] = data.succeedAction;
      actions[4] = data.succeedAction;
      actions[5] = data.succeedAction;

      // add first 3 actions in the allowFailureMap
      // to make sure tx succeeds.
      for (let i = 0; i < 3; i++) {
        allowFailureMap = flipBit(i, allowFailureMap);
      }

      // If the below call not fails, means allowFailureMap is correct.
      let tx = await dao.execute(ZERO_BYTES32, actions, allowFailureMap);
      let event = findEvent<ExecutedEvent>(await tx.wait(), EVENTS.Executed);

      expect(event.args.actor).to.equal(ownerAddress);
      expect(event.args.callId).to.equal(ZERO_BYTES32);
      expect(event.args.allowFailureMap).to.equal(allowFailureMap);

      // construct the failureMap which only has those
      // bits set at indexes where actions failed
      let failureMap = ethers.BigNumber.from(0);
      for (let i = 0; i < 3; i++) {
        failureMap = flipBit(i, failureMap);
      }
      // Check that dao correctly generated failureMap
      expect(event.args.failureMap).to.equal(failureMap);

      // Check that execResult emitted correctly stores action results.
      for (let i = 0; i < 3; i++) {
        expect(event.args.execResults[i]).to.includes(data.failActionMessage);
        expect(event.args.execResults[i]).to.includes(errorSignature);
      }
      for (let i = 3; i < 6; i++) {
        expect(event.args.execResults[i]).to.equal(data.successActionResult);
      }

      // lets remove one of the action from allowFailureMap
      // to see tx will actually revert.
      allowFailureMap = flipBit(2, allowFailureMap);
      await expect(dao.execute(ZERO_BYTES32, actions, allowFailureMap))
        .to.be.revertedWithCustomError(dao, 'ActionFailed')
        .withArgs(2); // Since we unset the 2th action from failureMap, it should fail with that index.
    });

    it('emits an event afterwards', async () => {
      const tx = await dao.execute(ZERO_BYTES32, [data.succeedAction], 0);
      const rc = await tx.wait();

      const event = findEvent<ExecutedEvent>(rc, 'Executed');
      expect(event.args.actor).to.equal(ownerAddress);
      expect(event.args.callId).to.equal(ZERO_BYTES32);
      expect(event.args.actions.length).to.equal(1);
      expect(event.args.actions[0].to).to.equal(data.succeedAction.to);
      expect(event.args.actions[0].value).to.equal(data.succeedAction.value);
      expect(event.args.actions[0].data).to.equal(data.succeedAction.data);
      expect(event.args.execResults[0]).to.equal(data.successActionResult);
      expect(event.args.allowFailureMap).to.equal(0);
    });

    skipTestIfNetworkIsZkSync(
      'reverts if failure is allowed but not enough gas is provided (many actions)',
      async () => {
        const gasConsumer = await hre.wrapper.deploy('GasConsumer');
        const GasConsumer = new GasConsumer__factory(signers[0]);

        // Prepare an action array calling `consumeGas` twenty times.
        const gasConsumingAction = {
          to: gasConsumer.address,
          data: GasConsumer.interface.encodeFunctionData('consumeGas', [20]),
          value: 0,
        };

        let allowFailureMap = ethers.BigNumber.from(0);
        allowFailureMap = flipBit(0, allowFailureMap); // allow the action to fail

        const expectedGas = await dao.estimateGas.execute(
          ZERO_BYTES32,
          [gasConsumingAction],
          allowFailureMap
        );

        // Provide too little gas so that the last `to.call` fails, but the remaining gas is enough to finish the subsequent operations.
        await expect(
          dao.execute(ZERO_BYTES32, [gasConsumingAction], allowFailureMap, {
            gasLimit: expectedGas.sub(3000),
          })
        ).to.be.revertedWithCustomError(dao, 'InsufficientGas');

        // Provide enough gas so that the entire call passes.
        await expect(
          dao.execute(ZERO_BYTES32, [gasConsumingAction], allowFailureMap, {
            gasLimit: expectedGas,
          })
        ).to.not.be.reverted;
      }
    );

    skipTestIfNetworkIsZkSync(
      'reverts if failure is allowed but not enough gas is provided (one action)',
      async () => {
        const gasConsumer = await hre.wrapper.deploy('GasConsumer');
        const GasConsumer = new GasConsumer__factory(signers[0]);

        // Prepare an action array calling `consumeGas` one times.
        const gasConsumingAction = {
          to: gasConsumer.address,
          data: GasConsumer.interface.encodeFunctionData('consumeGas', [1]),
          value: 0,
        };

        let allowFailureMap = ethers.BigNumber.from(0);
        allowFailureMap = flipBit(0, allowFailureMap); // allow the action to fail

        const expectedGas = await dao.estimateGas.execute(
          ZERO_BYTES32,
          [gasConsumingAction],
          allowFailureMap
        );

        // Provide too little gas so that the last `to.call` fails, but the remaining gas is enough to finish the subsequent operations.
        await expect(
          dao.execute(ZERO_BYTES32, [gasConsumingAction], allowFailureMap, {
            gasLimit: expectedGas.sub(10000),
          })
        ).to.be.revertedWithCustomError(dao, 'InsufficientGas');

        // Provide enough gas so that the entire call passes.
        await expect(
          dao.execute(ZERO_BYTES32, [gasConsumingAction], allowFailureMap, {
            gasLimit: expectedGas,
          })
        ).to.not.be.reverted;
      }
    );

    describe('Transferring tokens', async () => {
      const amount = ethers.utils.parseEther('1.23');
      const options = {value: amount};

      describe('ETH Transfer', async () => {
        it('reverts if transfers more eth than dao has', async () => {
          const transferAction = {
            to: signers[1].address,
            value: amount,
            data: '0x',
          };
          await expect(dao.execute(ZERO_BYTES32, [transferAction], 0)).to.be
            .reverted;
        });

        it('transfers native token(eth) to recipient', async () => {
          // put native tokens into the DAO
          await dao.deposit(
            ethers.constants.AddressZero,
            amount,
            'ref',
            options
          );

          const recipient = signers[1].address;
          const currentBalance = await ethers.provider.getBalance(recipient);

          const transferAction = {to: recipient, value: amount, data: '0x'};
          await dao.execute(ZERO_BYTES32, [transferAction], 0);
          const newBalance = await ethers.provider.getBalance(recipient);
          expect(newBalance.sub(currentBalance)).to.equal(amount);
        });
      });

      describe('ERC20 Transfer', async () => {
        let erc20Token: ERC20Mock;

        beforeEach(async () => {
          erc20Token = await hre.wrapper.deploy('ERC20Mock', {
            args: ['name', 'symbol'],
          });
        });

        it('reverts if transfers more ERC20 than dao has', async () => {
          const transferAction = getERC20TransferAction(
            erc20Token.address,
            signers[1].address,
            amount
          );

          await expect(dao.execute(ZERO_BYTES32, [transferAction], 0)).to.be
            .reverted;
        });

        it('transfers native token(eth) to recipient', async () => {
          // put ERC20 into the DAO
          await erc20Token.setBalance(dao.address, amount);

          const recipient = signers[1].address;

          const transferAction = getERC20TransferAction(
            erc20Token.address,
            recipient,
            amount
          );

          expect(await erc20Token.balanceOf(dao.address)).to.equal(amount);
          expect(await erc20Token.balanceOf(recipient)).to.equal(0);

          await dao.execute(ZERO_BYTES32, [transferAction], 0);
          expect(await erc20Token.balanceOf(dao.address)).to.equal(0);
          expect(await erc20Token.balanceOf(recipient)).to.equal(amount);
        });
      });

      describe('ERC721 Transfer', async () => {
        let erc721Token: ERC721Mock;

        beforeEach(async () => {
          erc721Token = await hre.wrapper.deploy('ERC721Mock', {
            args: ['name', 'symbol'],
          });
        });

        it('reverts if transfers more ERC721 than dao has', async () => {
          const transferAction = getERC721TransferAction(
            erc721Token.address,
            dao.address,
            signers[1].address,
            1
          );

          await expect(dao.execute(ZERO_BYTES32, [transferAction], 0)).to.be
            .reverted;
        });

        it('transfers native ERC721(eth) to recipient', async () => {
          // put ERC721 into the DAO
          await erc721Token.mint(dao.address, 1);

          const recipient = signers[1].address;

          const transferAction = getERC721TransferAction(
            erc721Token.address,
            dao.address,
            recipient,
            1
          );

          expect(await erc721Token.balanceOf(dao.address)).to.equal(1);
          expect(await erc721Token.balanceOf(recipient)).to.equal(0);

          await dao.execute(ZERO_BYTES32, [transferAction], 0);

          expect(await erc721Token.balanceOf(dao.address)).to.equal(0);
          expect(await erc721Token.balanceOf(recipient)).to.equal(1);
        });
      });

      describe('ERC1155 Transfer', async () => {
        let erc1155Token: ERC1155Mock;

        beforeEach(async () => {
          erc1155Token = await hre.wrapper.deploy('ERC1155Mock', {
            args: ['URI'],
          });
        });

        it('reverts if transfers more ERC1155 than dao has', async () => {
          const transferAction = getERC1155TransferAction(
            erc1155Token.address,
            dao.address,
            signers[1].address,
            1,
            1
          );

          await expect(dao.execute(ZERO_BYTES32, [transferAction], 0)).to.be
            .reverted;
        });

        it('transfers ERC1155 tokens to recipient', async () => {
          await erc1155Token.mint(dao.address, 1, 1);
          await erc1155Token.mint(dao.address, 2, 50);
          const recipient = signers[1].address;

          const transferAction1 = getERC1155TransferAction(
            erc1155Token.address,
            dao.address,
            signers[1].address,
            1,
            1
          );
          const transferAction2 = getERC1155TransferAction(
            erc1155Token.address,
            dao.address,
            signers[1].address,
            2,
            50
          );

          expect(await erc1155Token.balanceOf(dao.address, 1)).to.equal(1);
          expect(await erc1155Token.balanceOf(dao.address, 2)).to.equal(50);
          expect(await erc1155Token.balanceOf(recipient, 1)).to.equal(0);
          expect(await erc1155Token.balanceOf(recipient, 2)).to.equal(0);

          await dao.execute(
            ZERO_BYTES32,
            [transferAction1, transferAction2],
            0
          );
          expect(await erc1155Token.balanceOf(dao.address, 1)).to.equal(0);
          expect(await erc1155Token.balanceOf(dao.address, 2)).to.equal(0);
          expect(await erc1155Token.balanceOf(recipient, 1)).to.equal(1);
          expect(await erc1155Token.balanceOf(recipient, 2)).to.equal(50);
        });
      });
    });
  });

  describe('Deposit through direct transfer:', async () => {
    let erc721Token: ERC721Mock;
    let erc1155Token: ERC1155Mock;

    beforeEach(async () => {
      erc1155Token = await hre.wrapper.deploy('ERC1155Mock', {
        args: ['URI'],
      });

      erc721Token = await hre.wrapper.deploy('ERC721Mock', {
        args: ['name', 'symbol'],
      });

      await erc721Token.mint(ownerAddress, 1);
      await erc1155Token.mint(ownerAddress, 1, 2);
    });

    it('reverts if erc721 callback is not registered', async () => {
      await dao.registerStandardCallback(
        TOKEN_INTERFACE_IDS.erc721ReceivedId,
        TOKEN_INTERFACE_IDS.erc721ReceivedId,
        UNREGISTERED_INTERFACE_RETURN
      );

      await expect(
        erc721Token['safeTransferFrom(address,address,uint256)'](
          ownerAddress,
          dao.address,
          1
        )
      ).to.be.reverted;
    });

    it('successfully transfers erc721 into the dao and emits the correct callback received event', async () => {
      const IERC721 = IERC721Receiver__factory.createInterface();

      const encoded = IERC721.encodeFunctionData('onERC721Received', [
        ownerAddress,
        ownerAddress,
        1,
        '0x',
      ]);

      await expect(
        erc721Token['safeTransferFrom(address,address,uint256)'](
          ownerAddress,
          dao.address,
          1
        )
      )
        .to.emit(dao, EVENTS.CallbackReceived)
        .withArgs(
          erc721Token.address,
          TOKEN_INTERFACE_IDS.erc721ReceivedId,
          encoded
        );
    });

    it('reverts if erc1155 callbacks are not registered', async () => {
      await dao.registerStandardCallback(
        TOKEN_INTERFACE_IDS.erc1155ReceivedId,
        TOKEN_INTERFACE_IDS.erc1155ReceivedId,
        UNREGISTERED_INTERFACE_RETURN
      );

      await dao.registerStandardCallback(
        TOKEN_INTERFACE_IDS.erc1155BatchReceivedId,
        TOKEN_INTERFACE_IDS.erc1155BatchReceivedId,
        UNREGISTERED_INTERFACE_RETURN
      );

      await expect(
        erc1155Token.safeTransferFrom(ownerAddress, dao.address, 1, 1, '0x')
      ).to.be.reverted;
      await expect(
        erc1155Token.safeBatchTransferFrom(
          ownerAddress,
          dao.address,
          [1],
          [1],
          '0x'
        )
      ).to.be.reverted;
    });

    it('successfully transfers erc1155 into the dao', async () => {
      const IERC1155 = IERC1155Receiver__factory.createInterface();

      // encode onERC1155Received call
      const erc1155ReceivedEncoded = IERC1155.encodeFunctionData(
        'onERC1155Received',
        [ownerAddress, ownerAddress, 1, 1, '0x']
      );

      // encode onERC1155BatchReceived call
      const erc1155BatchReceivedEncoded = IERC1155.encodeFunctionData(
        'onERC1155BatchReceived',
        [ownerAddress, ownerAddress, [1], [1], '0x']
      );

      await expect(
        erc1155Token.safeTransferFrom(ownerAddress, dao.address, 1, 1, '0x')
      )
        .to.emit(dao, EVENTS.CallbackReceived)
        .withArgs(
          erc1155Token.address,
          TOKEN_INTERFACE_IDS.erc1155ReceivedId,
          erc1155ReceivedEncoded
        );
      await expect(
        erc1155Token.safeBatchTransferFrom(
          ownerAddress,
          dao.address,
          [1],
          [1],
          '0x'
        )
      )
        .to.emit(dao, EVENTS.CallbackReceived)
        .withArgs(
          erc1155Token.address,
          TOKEN_INTERFACE_IDS.erc1155BatchReceivedId,
          erc1155BatchReceivedEncoded
        );
    });
  });

  describe('Deposit through deposit function:', async () => {
    const amount = ethers.utils.parseEther('1.23');
    let token: ERC20Mock;

    beforeEach(async () => {
      token = await hre.wrapper.deploy('ERC20Mock', {
        args: ['name', 'symbol'],
      });
    });

    it('reverts if amount is zero', async () => {
      await expect(
        dao.deposit(ethers.constants.AddressZero, 0, 'ref')
      ).to.be.revertedWithCustomError(dao, 'ZeroAmount');
    });

    it('reverts if passed amount does not match native amount value', async () => {
      const options = {value: amount};
      const passedAmount = ethers.utils.parseEther('1.22');

      await expect(
        dao.deposit(ethers.constants.AddressZero, passedAmount, 'ref', options)
      )
        .to.be.revertedWithCustomError(dao, 'NativeTokenDepositAmountMismatch')
        .withArgs(passedAmount, amount);
    });

    it('reverts if ERC20 and native tokens are deposited at the same time', async () => {
      const options = {value: amount};
      await token.setBalance(ownerAddress, amount);

      await expect(dao.deposit(token.address, amount, 'ref', options))
        .to.be.revertedWithCustomError(dao, 'NativeTokenDepositAmountMismatch')
        .withArgs(0, amount);
    });

    it('reverts when tries to deposit ERC20 token while sender does not have token amount', async () => {
      await expect(dao.deposit(token.address, amount, 'ref')).to.be.reverted;
    });

    it('reverts when tries to deposit ERC20 token while sender does not have approved token transfer', async () => {
      await token.setBalance(ownerAddress, amount);

      await expect(
        dao.deposit(token.address, amount, 'ref')
      ).to.be.revertedWith('ERC20: insufficient allowance');
    });

    it('deposits native tokens into the DAO', async () => {
      const options = {value: amount};

      // is empty at the beginning
      expect(await ethers.provider.getBalance(dao.address)).to.equal(0);

      await expect(
        dao.deposit(ethers.constants.AddressZero, amount, 'ref', options)
      )
        .to.emit(dao, EVENTS.Deposited)
        .withArgs(ownerAddress, ethers.constants.AddressZero, amount, 'ref');

      // holds amount now
      expect(await ethers.provider.getBalance(dao.address)).to.equal(amount);
    });

    it('deposits ERC20 into the DAO', async () => {
      await token.setBalance(ownerAddress, amount);
      await token.approve(dao.address, amount);

      // is empty at the beginning
      expect(await token.balanceOf(dao.address)).to.equal(0);

      await expect(dao.deposit(token.address, amount, 'ref'))
        .to.emit(dao, EVENTS.Deposited)
        .withArgs(ownerAddress, token.address, amount, 'ref');

      // holds amount now
      expect(await token.balanceOf(dao.address)).to.equal(amount);
    });
  });

  describe('registerStandardCallback:', async () => {
    it('reverts if `REGISTER_STANDARD_CALLBACK_PERMISSION` is not granted', async () => {
      await dao.revoke(
        dao.address,
        ownerAddress,
        DAO_PERMISSIONS.REGISTER_STANDARD_CALLBACK_PERMISSION_ID
      );

      await expect(
        dao.registerStandardCallback('0x00000001', '0x00000001', '0x00000001')
      )
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs(
          dao.address,
          ownerAddress,
          DAO_PERMISSIONS.REGISTER_STANDARD_CALLBACK_PERMISSION_ID
        );
    });

    it('correctly emits selector and interface id', async () => {
      await expect(
        dao.registerStandardCallback('0x00000001', '0x00000002', '0x00000001')
      )
        .to.emit(dao, EVENTS.StandardCallbackRegistered)
        .withArgs('0x00000001', '0x00000002', '0x00000001');
    });

    it('correctly sets callback selector and interface and can call later', async () => {
      const id = '0x11111111';

      // onERC721Received selector doesn't exist, so it should fail..
      await expect(
        signers[0].sendTransaction({
          to: dao.address,
          data: id,
        })
      )
        .to.be.revertedWithCustomError(dao, 'UnknownCallback')
        .withArgs(id, UNREGISTERED_INTERFACE_RETURN);

      await dao.registerStandardCallback(id, id, id);

      let onCallbackReturned = await ethers.provider.call({
        to: dao.address,
        data: id,
      });

      // TODO: ethers utils pads zero to the left. we need to pad to the right.
      expect(onCallbackReturned).to.equal(id + '00'.repeat(28));
      expect(await dao.supportsInterface(id)).to.equal(true);
    });
  });

  describe('receive:', async () => {
    const amount = ethers.utils.parseEther('1.23');

    it('receives native tokens ', async () => {
      const options = {value: amount};

      // is empty at the beginning
      expect(await ethers.provider.getBalance(dao.address)).to.equal(0);

      // Send a transaction
      await expect(signers[0].sendTransaction({to: dao.address, value: amount}))
        .to.emit(dao, EVENTS.NativeTokenDeposited)
        .withArgs(ownerAddress, amount);

      // holds amount now
      expect(await ethers.provider.getBalance(dao.address)).to.equal(amount);
    });
  });

  describe('hasPermission', async () => {
    const permission = ethers.utils.id('PERMISSION_TEST');

    it('returns `false` if the permission is not set', async () => {
      expect(
        await dao.hasPermission(dao.address, ownerAddress, permission, '0x')
      ).to.be.false;
    });

    it('returns `true` if permission is set', async () => {
      await dao.grant(dao.address, ownerAddress, permission);
      expect(
        await dao.hasPermission(dao.address, ownerAddress, permission, '0x')
      ).to.be.true;
    });
  });

  describe('ERC1271', async () => {
    let signer: SignerWithAddress;
    let caller: SignerWithAddress;
    let otherCaller: SignerWithAddress;

    let message: string;
    let hash: string;
    let signature: string;

    let mockConditionFactory: PermissionConditionMock__factory;

    beforeEach(async () => {
      caller = signers[0];
      signer = signers[1];
      otherCaller = signers[2];

      mockConditionFactory = new PermissionConditionMock__factory(caller);

      message = 'The message!';
      hash = ethers.utils.hashMessage(message);
      signature = await signer.signMessage(message);
    });

    it('treats signatures as invalid by default if no permission is set', async () => {
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(INVALID_ERC1271_SIGNATURE);
    });

    it('allows caller-specific signature validation bypassing', async () => {
      // Grant the permission to validate signatures to the caller without a condition
      await dao.grant(
        dao.address,
        caller.address,
        DAO_PERMISSIONS.VALIDATE_SIGNATURE_PERMISSION_ID
      );

      // The caller can validate signatures now.
      expect(await dao.connect(caller).isValidSignature(hash, signature)).to.not
        .be.reverted;

      // Because the caller is allowed unconditionally, the signature is always valid.
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(VALID_ERC1271_SIGNATURE);

      // Because the other caller is not allowed, the signature is always invalid.
      expect(
        await dao.connect(otherCaller).isValidSignature(hash, signature)
      ).to.equal(INVALID_ERC1271_SIGNATURE);
    });

    it('allows caller-specific signature validation conditions', async () => {
      // Try to call with caller but caller has no permission
      expect(await dao.connect(caller).isValidSignature(hash, signature))
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs();

      // Deploy a mock condition
      const mockCondition = await hre.wrapper.deploy('PermissionConditionMock');

      // Grant the permission to validate signatures to the caller
      await dao.grantWithCondition(
        dao.address,
        caller.address,
        DAO_PERMISSIONS.VALIDATE_SIGNATURE_PERMISSION_ID,
        mockCondition.address
      );

      // The caller can validate signatures now.
      expect(await dao.connect(caller).isValidSignature(hash, signature)).to.not
        .be.reverted;

      // Check that the mock condition will answer true.
      expect(await mockCondition.answer()).to.be.true;

      // Check that the signature is valid in this case.
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(VALID_ERC1271_SIGNATURE);

      // Set the mock condition to answer false.
      await mockCondition.setAnswer(false);

      // Check that the mock condition will answer false.
      expect(await mockCondition.answer()).to.be.false;

      // Check that the signature is invalid in this case.
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(INVALID_ERC1271_SIGNATURE);
    });

    it('allows generic signature validation by granting to ANY_ADDR', async () => {
      // Deploy a mock condition
      const mockCondition = await hre.wrapper.deploy('PermissionConditionMock');

      // Grant the permission to validate signatures to the ANY caller conditionally (granting it unconditionally is not possible in combination with `_who: ANY_ADDR`)
      await dao.grantWithCondition(
        dao.address,
        ANY_ADDR,
        DAO_PERMISSIONS.VALIDATE_SIGNATURE_PERMISSION_ID,
        mockCondition.address
      );

      // Check that the mock condition will answer true.
      expect(await mockCondition.answer()).to.be.true;

      // Any caller can validate signatures using this condition now.
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(VALID_ERC1271_SIGNATURE);
      expect(
        await dao.connect(otherCaller).isValidSignature(hash, signature)
      ).to.equal(VALID_ERC1271_SIGNATURE);

      // Set the mock condition to answer false.
      await mockCondition.setAnswer(false);

      // Check that the mock condition will answer false.
      expect(await mockCondition.answer()).to.be.false;

      // Check that the signature is invalid in this case for every caller.
      expect(
        await dao.connect(caller).isValidSignature(hash, signature)
      ).to.equal(INVALID_ERC1271_SIGNATURE);
      expect(
        await dao.connect(otherCaller).isValidSignature(hash, signature)
      ).to.equal(INVALID_ERC1271_SIGNATURE);
    });

    context(
      'A caller-specific and a generic condition are both set',
      async () => {
        let specificMockCondition: PermissionConditionMock;
        let genericMockCondition: PermissionConditionMock;

        beforeEach(async () => {
          // Setup the specific condition for a specific caller
          specificMockCondition = await hre.wrapper.deploy(
            'PermissionConditionMock'
          );

          await dao.grantWithCondition(
            dao.address,
            caller.address,
            DAO_PERMISSIONS.VALIDATE_SIGNATURE_PERMISSION_ID,
            specificMockCondition.address
          );

          // Setup the generic condition for ANY caller
          genericMockCondition = await hre.wrapper.deploy(
            'PermissionConditionMock'
          );

          await dao.grantWithCondition(
            dao.address,
            ANY_ADDR,
            DAO_PERMISSIONS.VALIDATE_SIGNATURE_PERMISSION_ID,
            genericMockCondition.address
          );
        });

        it('returns valid if both conditions are met', async () => {
          expect(
            await dao.connect(caller).isValidSignature(hash, signature)
          ).to.equal(VALID_ERC1271_SIGNATURE);
        });

        it('returns valid if only the specific condition is met', async () => {
          await genericMockCondition.setAnswer(false);
          expect(
            await dao.connect(caller).isValidSignature(hash, signature)
          ).to.equal(VALID_ERC1271_SIGNATURE);
        });

        it('returns invalid if the specific condition is not met although the generic condition is met (no fallback)', async () => {
          await specificMockCondition.setAnswer(false);
          expect(
            await dao.connect(caller).isValidSignature(hash, signature)
          ).to.equal(INVALID_ERC1271_SIGNATURE);
        });

        it('returns invalid if both conditions are not met', async () => {
          await specificMockCondition.setAnswer(false);
          await genericMockCondition.setAnswer(false);
          expect(
            await dao.connect(caller).isValidSignature(hash, signature)
          ).to.equal(INVALID_ERC1271_SIGNATURE);
        });
      }
    );

    it('should revert if `setSignatureValidator` is called', async () => {
      await expect(
        dao
          .connect(caller)
          .setSignatureValidator(ethers.Wallet.createRandom().address)
      ).to.be.revertedWithCustomError(dao, 'FunctionRemoved');
    });
  });

  describe('ERC4824 - daoURI', async () => {
    it('should set a new URI', async () => {
      const newURI = 'https://new.example.com';
      expect(await dao.daoURI()).not.to.be.eq(newURI);
      await dao.setDaoURI(newURI);
      expect(await dao.daoURI()).to.be.eq(newURI);
    });

    it('should emit DaoURIUpdated', async () => {
      const newURI = 'https://new.example.com';
      await expect(dao.setDaoURI(newURI))
        .to.emit(dao, 'NewURI')
        .withArgs(newURI);
    });

    it('should revert if the sender lacks the permission to update the URI', async () => {
      await dao.revoke(
        dao.address,
        ownerAddress,
        DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID
      );

      await expect(dao.setDaoURI('https://new.example.com'))
        .to.be.revertedWithCustomError(dao, 'Unauthorized')
        .withArgs(
          dao.address,
          ownerAddress,
          DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID
        );
    });

    it('should return the DAO URI', async () => {
      expect(await dao.daoURI()).to.be.eq(daoExampleURI);
    });
  });
});


### File: /home/errick/core/packages/contracts/test/core/dao/callback-handler.ts ###
import {
  CallbackHandlerMockHelper,
  CallbackHandlerMockHelper__factory,
} from '../../../typechain';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {defaultAbiCoder, hexDataSlice, id} from 'ethers/lib/utils';
import hre, {ethers} from 'hardhat';

const EVENTS = {
  STANDARD_CALLBACK_REGISTERED: 'StandardCallbackRegistered',
  CALLBACK_RECEIVED: 'CallbackReceived',
};

const callbackSelector = hexDataSlice(id('callbackFunc()'), 0, 4); // 0x1eb2075a
const magicNumber = `0x1${'0'.repeat(7)}`;
export const UNREGISTERED_INTERFACE_RETURN = `0x${'00'.repeat(4)}`;

describe('CallbackHandler', function () {
  let signers: SignerWithAddress[];
  let owner: string;
  let callbackHandlerMockHelper: CallbackHandlerMockHelper;

  beforeEach(async () => {
    signers = await ethers.getSigners();
    owner = await signers[0].getAddress();

    callbackHandlerMockHelper = await hre.wrapper.deploy(
      'CallbackHandlerMockHelper'
    );
  });

  it('reverts for an unknown callback function signature', async () => {
    await expect(
      callbackHandlerMockHelper.handleCallback(callbackSelector, '0x')
    )
      .to.be.revertedWithCustomError(
        callbackHandlerMockHelper,
        'UnknownCallback'
      )
      .withArgs(callbackSelector, UNREGISTERED_INTERFACE_RETURN);
  });

  it('returns the correct magic number from the `_handleCallback`', async () => {
    await callbackHandlerMockHelper.registerCallback(
      callbackSelector,
      magicNumber
    );

    expect(
      await callbackHandlerMockHelper.callStatic.handleCallback(
        callbackSelector,
        '0x'
      )
    ).to.equal(magicNumber);
  });

  it('correctly emits the received callback event', async () => {
    await callbackHandlerMockHelper.registerCallback(
      callbackSelector,
      magicNumber
    );

    const data = '0x1111';

    await expect(
      callbackHandlerMockHelper.handleCallback(callbackSelector, data)
    )
      .to.emit(callbackHandlerMockHelper, EVENTS.CALLBACK_RECEIVED)
      .withArgs(owner, callbackSelector, data);
  });
});


### File: /home/errick/core/packages/contracts/test/framework/plugin/plugin-repo-registry.ts ###
import {
  DAO,
  PluginRepo,
  ENSSubdomainRegistrar,
  PluginRepoRegistry,
  PluginRepoRegistry__factory,
} from '../../../typechain';
import {PluginRepoRegistry__factory as PluginRepoRegistry_V1_0_0__factory} from '../../../typechain/@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepoRegistry.sol';
import {PluginRepoRegistry__factory as PluginRepoRegistry_V1_3_0__factory} from '../../../typechain/@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepoRegistry.sol';
import {ensDomainHash} from '../../../utils/ens';
import {deployNewDAO} from '../../test-utils/dao';
import {deployENSSubdomainRegistrar} from '../../test-utils/ens';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {deployNewPluginRepo} from '../../test-utils/repo';
import {
  deployAndUpgradeFromToCheck,
  deployAndUpgradeSelfCheck,
} from '../../test-utils/uups-upgradeable';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {
  PLUGIN_REGISTRY_PERMISSIONS,
  getProtocolVersion,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {ContractFactory} from 'ethers';
import hre, {artifacts, ethers} from 'hardhat';

const EVENTS = {
  PluginRepoRegistered: 'PluginRepoRegistered',
};

describe('PluginRepoRegistry', function () {
  let signers: SignerWithAddress[];
  let ensSubdomainRegistrar: ENSSubdomainRegistrar;
  let pluginRepoRegistry: PluginRepoRegistry;
  let ownerAddress: string;
  let managingDAO: DAO;
  let pluginRepo: PluginRepo;

  const topLevelDomain = 'dao.eth';
  const pluginRepoSubdomain = 'my-plugin-repo';

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();

    // DAO
    managingDAO = await deployNewDAO(signers[0]);
  });

  beforeEach(async function () {
    // ENS subdomain Registry
    ensSubdomainRegistrar = await deployENSSubdomainRegistrar(
      signers[0],
      managingDAO,
      topLevelDomain
    );

    // deploy and initialize PluginRepoRegistry
    pluginRepoRegistry = await hre.wrapper.deploy(
      ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
      {withProxy: true}
    );

    await pluginRepoRegistry.initialize(
      managingDAO.address,
      ensSubdomainRegistrar.address
    );

    // deploy a pluginRepo and initialize
    pluginRepo = await deployNewPluginRepo(signers[0]);

    // grant REGISTER_PLUGIN_REPO_PERMISSION_ID to ownerAddress
    await managingDAO.grant(
      pluginRepoRegistry.address,
      ownerAddress,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    // grant REGISTER_ENS_SUBDOMAIN_PERMISSION_ID to pluginRepoRegistry
    await managingDAO.grant(
      ensSubdomainRegistrar.address,
      pluginRepoRegistry.address,
      PLUGIN_REGISTRY_PERMISSIONS.ENS_REGISTRAR_PERMISSIONS
        .REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );
  });

  it('successfully sets subdomainregistrar', async () => {
    expect(await pluginRepoRegistry.subdomainRegistrar()).to.equal(
      ensSubdomainRegistrar.address
    );
  });

  it('Should register a new pluginRepo successfully', async function () {
    await expect(
      await pluginRepoRegistry.registerPluginRepo(
        pluginRepoSubdomain,
        pluginRepo.address
      )
    )
      .to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered)
      .withArgs(pluginRepoSubdomain, pluginRepo.address);

    expect(await pluginRepoRegistry.entries(pluginRepo.address)).to.equal(true);
  });

  it('Should register a new pluginRepo successfully even if subdomain is empty', async function () {
    const subdomain = '';

    await expect(
      await pluginRepoRegistry.registerPluginRepo(subdomain, pluginRepo.address)
    )
      .to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered)
      .withArgs(subdomain, pluginRepo.address);

    expect(await pluginRepoRegistry.entries(pluginRepo.address)).to.equal(true);
  });

  it('Should revert if ens is not supported, but subdomain is still non empty', async function () {
    pluginRepoRegistry = await hre.wrapper.deploy(
      ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
      {withProxy: true}
    );

    await pluginRepoRegistry.initialize(
      managingDAO.address,
      ethers.constants.AddressZero
    );

    await managingDAO.grant(
      pluginRepoRegistry.address,
      ownerAddress,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    await expect(
      pluginRepoRegistry.registerPluginRepo('some', pluginRepo.address)
    ).to.be.revertedWithCustomError(pluginRepoRegistry, 'ENSNotSupported');
  });

  it('fail to register if the sender lacks the required role', async () => {
    // Register a plugin successfully
    await pluginRepoRegistry.registerPluginRepo(
      pluginRepoSubdomain,
      pluginRepo.address
    );

    // Revoke the permission
    await managingDAO.revoke(
      pluginRepoRegistry.address,
      ownerAddress,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    // deploy a pluginRepo
    const newPluginRepo = await deployNewPluginRepo(signers[0]);

    await expect(
      pluginRepoRegistry.registerPluginRepo(
        pluginRepoSubdomain,
        newPluginRepo.address
      )
    )
      .to.be.revertedWithCustomError(pluginRepoRegistry, 'DaoUnauthorized')
      .withArgs(
        managingDAO.address,
        pluginRepoRegistry.address,
        ownerAddress,
        PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
      );
  });

  it('reverts the registration if the plugin repo already exists in the registry', async function () {
    await pluginRepoRegistry.registerPluginRepo('repo-1', pluginRepo.address);

    await expect(
      pluginRepoRegistry.registerPluginRepo('repo-2', pluginRepo.address)
    )
      .to.be.revertedWithCustomError(
        pluginRepoRegistry,
        'ContractAlreadyRegistered'
      )
      .withArgs(pluginRepo.address);
  });

  it("reverts the registration if the plugin repo's ENS subdomain is already taken", async function () {
    await pluginRepoRegistry.registerPluginRepo(
      pluginRepoSubdomain,
      pluginRepo.address
    );

    const pluginRepoSubdomainDomainHash = ensDomainHash(
      pluginRepoSubdomain + '.' + topLevelDomain
    );

    await expect(
      pluginRepoRegistry.registerPluginRepo(
        pluginRepoSubdomain,
        pluginRepo.address
      )
    )
      .to.be.revertedWithCustomError(ensSubdomainRegistrar, 'AlreadyRegistered')
      .withArgs(pluginRepoSubdomainDomainHash, ensSubdomainRegistrar.address);
  });

  // without mocking we have to repeat the tests here to make sure the validation is correct
  describe('subdomain validation', () => {
    it('should validate the passed subdomain correctly (< 32 bytes long subdomain)', async () => {
      const baseSubdomain = 'this-is-my-super-valid-subdomain';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        // deploy a pluginRepo and initialize
        const newPluginRepo = await deployNewPluginRepo(signers[0]);

        // replace the 10th char in the baseSubdomain
        const subdomainName =
          baseSubdomain.substring(0, 10) +
          String.fromCharCode(i) +
          baseSubdomain.substring(10 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          await expect(
            pluginRepoRegistry.registerPluginRepo(
              subdomainName,
              newPluginRepo.address
            )
          ).to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered);
          continue;
        }

        await expect(
          pluginRepoRegistry.registerPluginRepo(
            subdomainName,
            newPluginRepo.address
          )
        )
          .to.be.revertedWithCustomError(
            pluginRepoRegistry,
            'InvalidPluginSubdomain'
          )
          .withArgs(subdomainName);
      }
    }).timeout(120000);

    it('should validate the passed subdomain correctly (> 32 bytes long subdomain)', async () => {
      const baseSubdomain =
        'this-is-my-super-looooooooooooooooooooooooooong-valid-subdomain';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        // deploy a pluginRepo and initialize
        const newPluginRepo = await deployNewPluginRepo(signers[0]);

        // replace the 40th char in the baseSubdomain
        const subdomainName =
          baseSubdomain.substring(0, 40) +
          String.fromCharCode(i) +
          baseSubdomain.substring(40 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          await expect(
            pluginRepoRegistry.registerPluginRepo(
              subdomainName,
              newPluginRepo.address
            )
          ).to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered);
          continue;
        }

        await expect(
          pluginRepoRegistry.registerPluginRepo(
            subdomainName,
            newPluginRepo.address
          )
        )
          .to.be.revertedWithCustomError(
            pluginRepoRegistry,
            'InvalidPluginSubdomain'
          )
          .withArgs(subdomainName);
      }
    }).timeout(120000);
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await pluginRepoRegistry.protocolVersion()).to.deep.equal(
        osxContractsVersion()
      );
    });
  });

  describe('Upgrades', () => {
    let legacyContractFactory: ContractFactory;
    let currentContractFactory: ContractFactory;
    let initArgs: any;

    before(() => {
      currentContractFactory = new PluginRepoRegistry__factory(signers[0]);
    });

    beforeEach(() => {
      initArgs = {
        dao: managingDAO.address,
        ensSubdomainRegistrar: ensSubdomainRegistrar.address,
      };
    });

    it('upgrades to a new implementation', async () => {
      await deployAndUpgradeSelfCheck(
        0,
        1,
        {
          initArgs: initArgs,
          initializer: 'initialize',
        },
        ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
        ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
        PLUGIN_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
        managingDAO
      );
    });

    it('upgrades from v1.0.0', async () => {
      legacyContractFactory = new PluginRepoRegistry_V1_0_0__factory(
        signers[0]
      );

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY_V1_0_0,
          ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
          PLUGIN_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          managingDAO
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });

    it('from v1.3.0', async () => {
      legacyContractFactory = new PluginRepoRegistry_V1_3_0__factory(
        signers[0]
      );

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY_V1_3_0,
          ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
          PLUGIN_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          managingDAO
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/plugin/plugin-setup-processor.ts ###
import pluginUUPSUpgradeableArtifact from '../../../artifacts/@aragon/osx-commons-contracts/src/plugin/PluginUUPSUpgradeable.sol/PluginUUPSUpgradeable.json';
import {
  PluginSetupProcessor,
  PluginUUPSUpgradeableSetupV1Mock,
  PluginUUPSUpgradeableSetupV1MockBad,
  PluginUUPSUpgradeableSetupV2Mock,
  PluginUUPSUpgradeableSetupV3Mock,
  PluginUUPSUpgradeableSetupV4Mock,
  PluginCloneableSetupV1Mock,
  PluginCloneableSetupV1MockBad,
  PluginCloneableSetupV2Mock,
  PluginRepoFactory,
  PluginRepoRegistry,
  PluginRepo,
  DAO,
  PluginRepo__factory,
  PluginRepoRegistry__factory,
  PluginUUPSUpgradeable__factory,
  PluginUUPSUpgradeableV1Mock__factory,
  PluginUUPSUpgradeableV2Mock__factory,
  PluginUUPSUpgradeableV3Mock__factory,
  PluginUUPSUpgradeableSetupV1Mock__factory,
  PluginUUPSUpgradeableSetupV1MockBad__factory,
  PluginUUPSUpgradeableSetupV2Mock__factory,
  PluginUUPSUpgradeableSetupV3Mock__factory,
  PluginUUPSUpgradeableSetupV4Mock__factory,
  PluginCloneableV1Mock__factory,
  PluginCloneableV1MockBad__factory,
  PluginCloneableV2Mock__factory,
  PluginCloneableSetupV1Mock__factory,
  PluginCloneableSetupV2Mock__factory,
  PluginCloneableSetupV1MockBad__factory,
} from '../../../typechain';
import {PluginRepoRegisteredEvent} from '../../../typechain/PluginRepoRegistry';
import {expect} from '../../chai-setup';
import {deployNewDAO, ZERO_BYTES32} from '../../test-utils/dao';
import {deployENSSubdomainRegistrar} from '../../test-utils/ens';
import {deployPluginSetupProcessor} from '../../test-utils/plugin-setup-processor';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {
  installPlugin,
  updatePlugin,
  uninstallPlugin,
} from '../../test-utils/psp/atomic-helpers';
import {
  createPrepareInstallationParams,
  createApplyInstallationParams,
  createPrepareUninstallationParams,
  createApplyUninstallationParams,
  createPrepareUpdateParams,
  createApplyUpdateParams,
} from '../../test-utils/psp/create-params';
import {
  getAppliedSetupId,
  getPluginInstallationId,
  getPreparedSetupId,
} from '../../test-utils/psp/hash-helpers';
import {
  mockPermissionsOperations,
  mockHelpers,
} from '../../test-utils/psp/mock-helpers';
import {
  PluginRepoPointer,
  PreparationType,
  VersionTag,
} from '../../test-utils/psp/types';
import {PermissionOperation} from '../../test-utils/psp/types';
import {
  prepareInstallation,
  prepareUpdate,
  prepareUninstallation,
  applyInstallation,
  applyUpdate,
  applyUninstallation,
} from '../../test-utils/psp/wrappers';
import {
  deployPluginRepoFactory,
  deployPluginRepoRegistry,
} from '../../test-utils/repo';
import {findEventTopicLog} from '@aragon/osx-commons-sdk';
import {Operation} from '@aragon/osx-commons-sdk';
import {
  DAO_PERMISSIONS,
  ENS_REGISTRAR_PERMISSIONS,
  PLUGIN_REGISTRY_PERMISSIONS,
  PLUGIN_SETUP_PROCESSOR_PERMISSIONS,
  PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS,
} from '@aragon/osx-commons-sdk';
import {MockContract} from '@defi-wonderland/smock';
import {anyValue} from '@nomicfoundation/hardhat-chai-matchers/withArgs';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {BytesLike} from 'ethers';
import hre, {ethers} from 'hardhat';

const EVENTS = {
  InstallationPrepared: 'InstallationPrepared',
  InstallationApplied: 'InstallationApplied',
  UpdatePrepared: 'UpdatePrepared',
  UpdateApplied: 'UpdateApplied',
  Upgraded: 'Upgraded',
  UninstallationPrepared: 'UninstallationPrepared',
  UninstallationApplied: 'UninstallationApplied',
  PluginRepoRegistered: 'PluginRepoRegistered',
  Granted: 'Granted',
  Revoked: 'Revoked',
};

const EMPTY_DATA = '0x';

const ADDRESS_TWO = `0x${'00'.repeat(19)}02`;

describe('PluginSetupProcessor', function () {
  let signers: SignerWithAddress[];
  let psp: PluginSetupProcessor;
  let repoU: PluginRepo;
  let PluginUV1: PluginUUPSUpgradeableV1Mock__factory;
  let PluginUV2: PluginUUPSUpgradeableV2Mock__factory;
  let PluginUV3: PluginUUPSUpgradeableV3Mock__factory;
  let setupUV1: PluginUUPSUpgradeableSetupV1Mock;
  let setupUV2: PluginUUPSUpgradeableSetupV2Mock;
  let setupUV3: PluginUUPSUpgradeableSetupV3Mock;
  let setupUV4: PluginUUPSUpgradeableSetupV4Mock;
  let setupUV1Bad: PluginUUPSUpgradeableSetupV1MockBad;
  let repoC: PluginRepo;
  let setupCV1: PluginCloneableSetupV1Mock;
  let setupCV1Bad: PluginCloneableSetupV1MockBad;
  let setupCV2: PluginCloneableSetupV2Mock;
  let ownerAddress: string;
  let targetDao: DAO;
  let managingDao: DAO;
  let pluginRepoFactory: PluginRepoFactory;
  let pluginRepoRegistry: PluginRepoRegistry;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();

    PluginUV1 = new PluginUUPSUpgradeableV1Mock__factory(signers[0]);
    PluginUV2 = new PluginUUPSUpgradeableV2Mock__factory(signers[0]);
    PluginUV3 = new PluginUUPSUpgradeableV3Mock__factory(signers[0]);

    const implUV1 = await hre.wrapper.deploy('PluginUUPSUpgradeableV1Mock');
    const implUV2 = await hre.wrapper.deploy('PluginUUPSUpgradeableV2Mock');
    const implUV3 = await hre.wrapper.deploy('PluginUUPSUpgradeableV3Mock');

    // Deploy PluginUUPSUpgradeableSetupMock

    setupUV1 = await hre.wrapper.deploy('PluginUUPSUpgradeableSetupV1Mock', {
      args: [implUV1.address],
    });
    setupUV1Bad = await hre.wrapper.deploy(
      'PluginUUPSUpgradeableSetupV1MockBad',
      {args: [implUV1.address]}
    );
    setupUV2 = await hre.wrapper.deploy('PluginUUPSUpgradeableSetupV2Mock', {
      args: [implUV2.address],
    });
    setupUV3 = await hre.wrapper.deploy('PluginUUPSUpgradeableSetupV3Mock', {
      args: [implUV3.address],
    });
    setupUV4 = await hre.wrapper.deploy('PluginUUPSUpgradeableSetupV4Mock', {
      args: [implUV3.address],
    });

    // Deploy PluginCloneableSetupMock
    const implCV1 = await hre.wrapper.deploy('PluginCloneableV1Mock');
    setupCV1 = await hre.wrapper.deploy('PluginCloneableSetupV1Mock', {
      args: [implCV1.address],
    });

    const implCV1Bad = await hre.wrapper.deploy('PluginCloneableV1MockBad');
    setupCV1Bad = await hre.wrapper.deploy('PluginCloneableSetupV1MockBad', {
      args: [implCV1Bad.address],
    });

    const implCV2 = await hre.wrapper.deploy('PluginCloneableV2Mock');
    setupCV2 = await hre.wrapper.deploy('PluginCloneableSetupV2Mock', {
      args: [implCV2.address],
    });

    // Deploy yhe managing DAO having permission to manage `PluginSetupProcessor`
    managingDao = await deployNewDAO(signers[0]);

    // Deploy ENS subdomain Registry
    const ensSubdomainRegistrar = await deployENSSubdomainRegistrar(
      signers[0],
      managingDao,
      'dao.eth'
    );

    // Deploy Plugin Repo Registry
    pluginRepoRegistry = await deployPluginRepoRegistry(
      managingDao,
      ensSubdomainRegistrar,
      signers[0]
    );

    // Deploy Plugin Repo Factory
    pluginRepoFactory = await deployPluginRepoFactory(
      signers,
      pluginRepoRegistry
    );

    // Grant `PLUGIN_REGISTER_PERMISSION` to `PluginRepoFactory`.
    await managingDao.grant(
      pluginRepoRegistry.address,
      pluginRepoFactory.address,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    // Grant `REGISTER_ENS_SUBDOMAIN_PERMISSION` to `PluginRepoFactory`.
    await managingDao.grant(
      ensSubdomainRegistrar.address,
      pluginRepoRegistry.address,
      ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );

    const releaseMetadata = '0x11';
    const buildMetadata = '0x11';

    // Plugin Setup Processor
    psp = await deployPluginSetupProcessor(pluginRepoRegistry);

    // Create and register a plugin on the PluginRepoRegistry
    let tx = await pluginRepoFactory.createPluginRepoWithFirstVersion(
      `plugin-uups-upgradeable-mock`,
      setupUV1.address, // build 1
      ownerAddress,
      releaseMetadata,
      buildMetadata
    );

    const PluginRepoRegisteredEvent1 =
      findEventTopicLog<PluginRepoRegisteredEvent>(
        await tx.wait(),
        PluginRepoRegistry__factory.createInterface(),
        EVENTS.PluginRepoRegistered
      );
    const PluginRepo = new PluginRepo__factory(signers[0]);
    repoU = PluginRepo.attach(PluginRepoRegisteredEvent1.args.pluginRepo);

    // Add setups
    await repoU.createVersion(1, setupUV2.address, EMPTY_DATA, EMPTY_DATA); // build 2
    await repoU.createVersion(1, setupUV3.address, EMPTY_DATA, EMPTY_DATA); // build 3
    await repoU.createVersion(1, setupUV1Bad.address, EMPTY_DATA, EMPTY_DATA); // build 4
    await repoU.createVersion(1, setupUV4.address, EMPTY_DATA, EMPTY_DATA); // build 5
    await repoU.createVersion(1, setupUV4.address, EMPTY_DATA, EMPTY_DATA); // buidl 6.

    tx = await pluginRepoFactory.createPluginRepoWithFirstVersion(
      `plugin-clonable-mock`,
      setupCV1.address,
      ownerAddress,
      releaseMetadata,
      buildMetadata
    );

    const PluginRepoRegisteredEvent2 =
      findEventTopicLog<PluginRepoRegisteredEvent>(
        await tx.wait(),
        PluginRepoRegistry__factory.createInterface(),
        EVENTS.PluginRepoRegistered
      );
    repoC = PluginRepo.attach(PluginRepoRegisteredEvent2.args.pluginRepo);
    await repoC.createVersion(1, setupCV1Bad.address, EMPTY_DATA, EMPTY_DATA);
    await repoC.createVersion(1, setupCV2.address, EMPTY_DATA, EMPTY_DATA);
  });

  beforeEach(async function () {
    // Target DAO to be used as an example DAO
    targetDao = await deployNewDAO(signers[0]);

    // Grant
    await targetDao.grant(
      targetDao.address,
      psp.address,
      DAO_PERMISSIONS.ROOT_PERMISSION_ID
    );
  });

  // They end up in the same pluginRepo with
  // the same release - 1, but different builds - 1,2,3.
  describe('PluginUUPSUpgradeableSetupMock', function () {
    it('points to the V1 implementation', async () => {
      await checkImplementation(setupUV1, PluginUV1, 1);
    });

    it('points to the V2 implementation', async () => {
      await checkImplementation(setupUV2, PluginUV2, 2);
    });

    it('points to the V3 implementation', async () => {
      await checkImplementation(setupUV3, PluginUV3, 3);
    });

    async function checkImplementation(
      setup: any,
      pluginFactory: any,
      build: number
    ) {
      const {plugin} = await prepareInstallation(
        psp,
        targetDao.address,
        [repoU.address, 1, build],
        EMPTY_DATA
      );

      const proxy = await pluginFactory
        .attach(plugin)
        .callStatic.implementation();

      expect(proxy).to.equal(await setup.callStatic.implementation());
    }
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await psp.protocolVersion()).to.deep.equal(osxContractsVersion());
    });
  });

  describe('Installation', function () {
    beforeEach(async () => {
      // Grant necessary permission to `ownerAddress` so it can install plugins on behalf of the DAO.
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
      );
    });

    describe('prepareInstallation', function () {
      it('reverts if `PluginSetupRepo` does not exist on `PluginRepoRegistry`', async () => {
        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams([ADDRESS_TWO, 1, 1], '0x')
          )
        ).to.be.revertedWithCustomError(psp, 'PluginRepoNonexistent');
      });

      it('reverts if the plugin version does not exist on `PluginRepoRegistry`', async () => {
        // non-existent build which should cause error.
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 15];

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, '0x')
          )
        ).to.be.revertedWithCustomError(repoU, 'VersionHashDoesNotExist');
      });

      it('reverts if plugin with the same setupId is already prepared.', async () => {
        // uses plugin setup that returns the same plugin address and dependencies
        // each time you call it. Useful to generate the same setup id
        // which should revert.
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 4];

        const {preparedSetupId} = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          '0x'
        );

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, '0x')
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupAlreadyPrepared')
          .withArgs(preparedSetupId);
      });

      it('reverts if plugin with the same address is already installed.', async () => {
        // uses plugin setup that returns the same plugin address and dependencies
        // each time you call it. Useful to generate the same plugin address
        // which should revert.
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 4];

        await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, '0x')
          )
        ).to.be.revertedWithCustomError(psp, 'PluginAlreadyInstalled');
      });

      // 1. prepareInstall for pluginId1 => setupId1
      // 2. applyInstall for pluginId1 => setupId1
      // 3. uninstall the plugin with applyUninstall.
      // 4. prepareInstall for pluginId1 => setupId1 which succeeds.
      it('EDGE-CASE: allows to prepare plugin installation with the same address and setupId if it was installed and then uninstalled', async () => {
        // uses plugin setup that returns the same plugin address and dependencies.
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 4];

        // Needed so applyUninstallation succeeds
        await targetDao.grant(
          psp.address,
          ownerAddress,
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UNINSTALLATION_PERMISSION_ID
        );

        const {plugin, helpers} = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await uninstallPlugin(
          psp,
          targetDao.address,
          plugin,
          helpers,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, '0x')
          )
        ).not.to.be.reverted;
      });

      it("successfully calls plugin setup's prepareInstallation with correct arguments", async () => {
        // Uses setupUV1
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 1];

        const data = '0x11';

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, data)
          )
        )
          .to.emit(setupUV1, 'InstallationPrepared')
          .withArgs(targetDao.address, data);
      });

      it('successfully prepares a plugin installation with the correct event arguments', async () => {
        const data = '0x11';
        const expectedPermissions = mockPermissionsOperations(
          0,
          2,
          Operation.Grant
        );
        const expectedHelpers = mockHelpers(2);
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 1];

        const preparedSetupId = getPreparedSetupId(
          pluginRepoPointer,
          expectedHelpers,
          // @ts-ignore
          expectedPermissions,
          '0x',
          PreparationType.Installation
        );

        await expect(
          psp.prepareInstallation(
            targetDao.address,
            createPrepareInstallationParams(pluginRepoPointer, data)
          )
        )
          .to.emit(psp, 'InstallationPrepared')
          .withArgs(
            ownerAddress,
            targetDao.address,
            preparedSetupId,
            pluginRepoPointer[0],
            (val: any) => expect(val).to.deep.equal([1, 1]),
            data,
            anyValue,
            (val: any) =>
              expect(val).to.deep.equal([expectedHelpers, expectedPermissions])
          );
      });
    });

    describe('applyInstallation', function () {
      it('reverts if caller does not have `APPLY_INSTALLATION_PERMISSION`', async () => {
        // revoke `APPLY_INSTALLATION_PERMISSION_ID` on dao for plugin installer
        // to see that it can't set permissions without it.
        await targetDao.revoke(
          psp.address,
          ownerAddress,
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
        );

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              ethers.constants.AddressZero,
              [ethers.constants.AddressZero, 1, 1],
              [],
              []
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupApplicationUnauthorized')
          .withArgs(
            targetDao.address,
            ownerAddress,
            PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
          );
      });

      it("reverts if PluginSetupProcessor does not have DAO's `ROOT_PERMISSION`", async () => {
        await targetDao.revoke(
          targetDao.address,
          psp.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );

        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 1];

        const {
          plugin,
          preparedSetupData: {permissions, helpers},
        } = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              permissions,
              helpers
            )
          )
        )
          .to.be.revertedWithCustomError(targetDao, 'Unauthorized')
          .withArgs(
            targetDao.address,
            psp.address,
            DAO_PERMISSIONS.ROOT_PERMISSION_ID
          );
      });

      it("reverts if setupId wasn't prepared by `prepareInstallation` first", async () => {
        const permissions = mockPermissionsOperations(0, 1, Operation.Grant);
        const helpers = mockHelpers(1);

        // really don't matter what we choose here for the plugin address.
        const pluginAddress = ownerAddress;

        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 1];

        // The PSP contract should generate the same setupId and revert with it below.
        const preparedSetupId = getPreparedSetupId(
          pluginRepoPointer,
          helpers,
          // @ts-ignore
          permissions,
          '0x',
          PreparationType.Installation
        );

        // directly tries to apply installation even if `prepareInstallation` wasn't called first.
        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              pluginAddress,
              pluginRepoPointer,
              // @ts-ignore
              permissions,
              helpers
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupNotApplicable')
          .withArgs(preparedSetupId);
      });

      it('reverts if the plugin with the same address is already installed', async () => {
        // uses plugin setup that returns the same plugin address and dependencies
        // each time you call it. Useful to generate the same plugin address
        // which should revert.
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 4];

        const {plugin, permissions, helpers} = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              permissions,
              helpers
            )
          )
        ).to.be.revertedWithCustomError(psp, 'PluginAlreadyInstalled');
      });

      it('successfully applies installation if setupId was prepared first by `prepareInstallation`', async () => {
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 1];

        const {
          plugin,
          preparedSetupData: {permissions, helpers},
          preparedSetupId,
        } = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        const appliedSetupId = getAppliedSetupId(pluginRepoPointer, helpers);

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              permissions,
              helpers
            )
          )
        )
          .to.emit(psp, 'InstallationApplied')
          .withArgs(targetDao.address, plugin, preparedSetupId, appliedSetupId);
      });

      // 1. call prepareinstall 2 times for the same plugin version
      // to get 2 preparations with same plugin address, but different setup ids.
      // 2. call applyInstall for one of them and see that 2nd one
      // would no longer be valid for the installation even though it was valid before.
      it('EDGE-CASE: reverts for all preparation if one of them was already applied for the install', async () => {
        const pluginRepoPointer: PluginRepoPointer = [repoU.address, 1, 4];

        const {
          plugin,
          preparedSetupData: {
            permissions: firstPreparedPermissions,
            helpers: firstPreparedHelpers,
          },
          preparedSetupId: firstPreparedSetupId,
        } = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await setupUV1Bad.mockPermissionIndexes(0, 2);

        const {
          preparedSetupData: {
            permissions: secondPreparedPermissions,
            helpers: secondPreparedHelpers,
          },
          preparedSetupId: secondPreparedSetupId,
        } = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        const pluginInstallationId = getPluginInstallationId(
          targetDao.address,
          plugin
        );
        // Check that both setupId are valid at this moment as none of them have been applied yet.
        await expect(
          psp.validatePreparedSetupId(
            pluginInstallationId,
            firstPreparedSetupId
          )
        ).not.to.be.reverted;
        await expect(
          psp.validatePreparedSetupId(
            pluginInstallationId,
            secondPreparedSetupId
          )
        ).not.to.be.reverted;
        await expect(
          psp.callStatic.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              firstPreparedPermissions,
              firstPreparedHelpers
            )
          )
        ).not.to.be.reverted;
        await expect(
          psp.callStatic.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              secondPreparedPermissions,
              secondPreparedHelpers
            )
          )
        ).not.to.be.reverted;

        // Lets install one of them.
        await applyInstallation(
          psp,
          targetDao.address,
          plugin,
          pluginRepoPointer,
          firstPreparedPermissions,
          firstPreparedHelpers
        );

        await expect(
          psp.validatePreparedSetupId(
            pluginInstallationId,
            firstPreparedSetupId
          )
        ).to.be.reverted;
        await expect(
          psp.validatePreparedSetupId(
            pluginInstallationId,
            secondPreparedSetupId
          )
        ).to.be.reverted;

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              firstPreparedPermissions,
              firstPreparedHelpers
            )
          )
        ).to.be.revertedWithCustomError(psp, 'PluginAlreadyInstalled');

        await expect(
          psp.applyInstallation(
            targetDao.address,
            createApplyInstallationParams(
              plugin,
              pluginRepoPointer,
              secondPreparedPermissions,
              secondPreparedHelpers
            )
          )
        ).to.be.revertedWithCustomError(psp, 'PluginAlreadyInstalled');

        // Clean up
        await setupUV1Bad.reset();
      });
    });
  });

  describe('Uninstallation', function () {
    let proxy: string;
    let helpersUV1: string[];
    let permissionsUV1: PermissionOperation[];
    let pluginRepoPointer: PluginRepoPointer;
    let currentAppliedSetupId: string;

    beforeEach(async () => {
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
      );
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UNINSTALLATION_PERMISSION_ID
      );

      pluginRepoPointer = [repoU.address, 1, 1];

      ({
        plugin: proxy,
        helpers: helpersUV1,
        permissions: permissionsUV1,
        appliedSetupId: currentAppliedSetupId,
      } = await installPlugin(psp, targetDao.address, pluginRepoPointer));
    });

    describe('prepareUninstallation', function () {
      it('reverts if plugin is not installed yet', async () => {
        // For extra safety, let's still call prepareInstall,
        // but it should still revert, as it's not installed yet.
        const {
          plugin,
          preparedSetupData: {helpers},
        } = await prepareInstallation(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        const appliedSetupId = getAppliedSetupId(pluginRepoPointer, helpers);

        await expect(
          psp.prepareUninstallation(
            targetDao.address,
            createPrepareUninstallationParams(
              plugin,
              pluginRepoPointer,
              helpers,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
          .withArgs(ZERO_BYTES32, appliedSetupId);
      });

      it('reverts if prepare uninstallation params do not match the current `appliedSetupId`', async () => {
        {
          // helpersUV1 contains two helper addresses. Let's remove one
          // to make sure modified helpers will cause test to fail.
          const modifiedHelpers = [...helpersUV1].slice(0, -1);

          const appliedSetupId = getAppliedSetupId(
            pluginRepoPointer,
            modifiedHelpers
          );

          await expect(
            prepareUninstallation(
              psp,
              targetDao.address,
              proxy,
              pluginRepoPointer,
              modifiedHelpers,
              EMPTY_DATA
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(currentAppliedSetupId, appliedSetupId);
        }

        {
          // Reverse order/sequence which still should cause to revert.
          const modifiedHelpers = [...helpersUV1].reverse();

          const appliedSetupId = getAppliedSetupId(
            pluginRepoPointer,
            modifiedHelpers
          );

          await expect(
            prepareUninstallation(
              psp,
              targetDao.address,
              proxy,
              pluginRepoPointer,
              modifiedHelpers,
              EMPTY_DATA
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(currentAppliedSetupId, appliedSetupId);
        }

        {
          const modifiedPluginRepoPointer = [
            pluginRepoPointer[0],
            pluginRepoPointer[1],
            2, // change the build to trigger generating different setup id.
          ];

          const appliedSetupId = getAppliedSetupId(
            // @ts-ignore
            modifiedPluginRepoPointer,
            helpersUV1
          );

          await expect(
            prepareUninstallation(
              psp,
              targetDao.address,
              proxy,
              // @ts-ignore
              modifiedPluginRepoPointer,
              helpersUV1,
              EMPTY_DATA
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(currentAppliedSetupId, appliedSetupId);
        }
      });

      it('reverts if plugin uninstallation with the same setup is already prepared', async () => {
        const {preparedSetupId} = await prepareUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          helpersUV1,
          EMPTY_DATA
        );

        await expect(
          prepareUninstallation(
            psp,
            targetDao.address,
            proxy,
            pluginRepoPointer,
            helpersUV1,
            EMPTY_DATA
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupAlreadyPrepared')
          .withArgs(preparedSetupId);
      });

      it('reverts if the plugin was uninstalled and tries to prepare uninstallation for it', async () => {
        // make sure that prepare uninstall doesn't revert before applying uninstall.
        await expect(
          psp.callStatic.prepareUninstallation(
            targetDao.address,
            createPrepareUninstallationParams(
              proxy,
              pluginRepoPointer,
              helpersUV1,
              EMPTY_DATA
            )
          )
        ).not.to.be.reverted;

        await uninstallPlugin(
          psp,
          targetDao.address,
          proxy,
          helpersUV1,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.prepareUninstallation(
            targetDao.address,
            createPrepareUninstallationParams(
              proxy,
              pluginRepoPointer,
              helpersUV1,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
          .withArgs(
            ZERO_BYTES32,
            getAppliedSetupId(pluginRepoPointer, helpersUV1)
          );
      });

      it('allows to prepare multiple uninstallation as long as setup is different', async () => {
        await prepareUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          helpersUV1,
          EMPTY_DATA
        );

        // Mock the contract call so it returns different
        // permissions than the above `prepareUninstallation` by default.
        // Needed to generate different setup.
        await setupUV1.mockPermissionIndexes(0, 2);

        await prepareUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          helpersUV1,
          EMPTY_DATA
        );

        // Clean up
        await setupUV1.reset();
      });

      it("successfully calls plugin setup's prepareUninstallation with correct arguments", async () => {
        const data = '0x11';

        await expect(
          psp.prepareUninstallation(
            targetDao.address,
            createPrepareUninstallationParams(
              proxy,
              pluginRepoPointer,
              helpersUV1,
              data
            )
          )
        )
          .to.emit(setupUV1, 'UninstallationPrepared')
          .withArgs(targetDao.address, (val: any) =>
            expect(val).to.deep.equal([proxy, helpersUV1, data])
          );
      });

      it('successfully prepares a plugin uninstallation with the correct event arguments', async () => {
        const data = '0x11';
        const uninstallPermissions = mockPermissionsOperations(
          0,
          1,
          Operation.Revoke
        );

        const preparedSetupId = getPreparedSetupId(
          pluginRepoPointer,
          null,
          // @ts-ignore
          uninstallPermissions,
          EMPTY_DATA,
          PreparationType.Uninstallation
        );

        await expect(
          psp.prepareUninstallation(
            targetDao.address,
            createPrepareUninstallationParams(
              proxy,
              pluginRepoPointer,
              helpersUV1,
              data
            )
          )
        )
          .to.emit(psp, 'UninstallationPrepared')
          .withArgs(
            ownerAddress,
            targetDao.address,
            preparedSetupId,
            pluginRepoPointer[0],
            (val: any) => expect(val).to.deep.equal([1, 1]),
            (val: any) => expect(val).to.deep.equal([proxy, helpersUV1, data]),
            (val: any) => expect(val).to.deep.equal(uninstallPermissions)
          );
      });
    });

    describe('applyUninstallation', function () {
      it('reverts if caller does not have `APPLY_UNINSTALLATION_PERMISSION`', async () => {
        // revoke `APPLY_INSTALLATION_PERMISSION_ID` on dao for plugin installer
        // to see that it can't set permissions without it.
        await targetDao.revoke(
          psp.address,
          ownerAddress,
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UNINSTALLATION_PERMISSION_ID
        );

        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              permissionsUV1
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupApplicationUnauthorized')
          .withArgs(
            targetDao.address,
            ownerAddress,
            PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UNINSTALLATION_PERMISSION_ID
          );
      });

      it("reverts if PluginSetupProcessor does not have DAO's `ROOT_PERMISSION`", async () => {
        await targetDao.revoke(
          targetDao.address,
          psp.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );

        const {permissions} = await prepareUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          helpersUV1,
          EMPTY_DATA
        );

        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              permissions
            )
          )
        )
          .to.be.revertedWithCustomError(targetDao, 'Unauthorized')
          .withArgs(
            targetDao.address,
            psp.address,
            DAO_PERMISSIONS.ROOT_PERMISSION_ID
          );
      });

      it('reverts if uninstallation is not prepared first', async () => {
        const preparedSetupId = getPreparedSetupId(
          pluginRepoPointer,
          null,
          permissionsUV1,
          EMPTY_DATA,
          PreparationType.Uninstallation
        );
        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              permissionsUV1
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupNotApplicable')
          .withArgs(preparedSetupId);
      });

      it('EDGE-CASE: reverts for all uninstall preparations once one of them is applied', async () => {
        // First Preparation
        const {permissions: firstPreparePermissions} =
          await prepareUninstallation(
            psp,
            targetDao.address,
            proxy,
            pluginRepoPointer,
            helpersUV1,
            EMPTY_DATA
          );

        // Confirm that first preparation can be applied.
        await expect(
          psp.callStatic.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              firstPreparePermissions
            )
          )
        ).not.to.be.reverted;

        // mock the function so it returns different permissions
        // Needed to make sure second preparation results in different setup id and not reverts.
        await setupUV1.mockPermissionIndexes(0, 2);

        // Second Preparation
        const {permissions: secondPreparePermissions} =
          await prepareUninstallation(
            psp,
            targetDao.address,
            proxy,
            pluginRepoPointer,
            helpersUV1,
            EMPTY_DATA
          );

        // Check that second preparation can be applied.
        await expect(
          psp.callStatic.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              secondPreparePermissions
            )
          )
        ).not.to.be.reverted;

        // apply uninstall for first preparation
        await applyUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          firstPreparePermissions
        );

        // Confirm that the none of the preparations can be applied anymore.
        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              firstPreparePermissions
            )
          )
        ).to.be.revertedWithCustomError(psp, 'SetupNotApplicable');

        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              secondPreparePermissions
            )
          )
        ).to.be.revertedWithCustomError(psp, 'SetupNotApplicable');

        await setupUV1.reset();
      });

      it('successfully uninstalls the plugin and emits the correct event', async () => {
        const {permissions, preparedSetupId} = await prepareUninstallation(
          psp,
          targetDao.address,
          proxy,
          pluginRepoPointer,
          helpersUV1,
          EMPTY_DATA
        );

        await expect(
          psp.applyUninstallation(
            targetDao.address,
            createApplyUninstallationParams(
              proxy,
              pluginRepoPointer,
              permissions
            )
          )
        )
          .to.emit(psp, 'UninstallationApplied')
          .withArgs(targetDao.address, proxy, preparedSetupId);
      });
    });
  });

  describe('Update', function () {
    beforeEach(async () => {
      // Grant necessary permission to `ownerAddress` so it can install and update plugins on behalf of the DAO.
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
      );
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UPDATE_PERMISSION_ID
      );
    });

    describe('prepareUpdate', function () {
      let proxy: string;
      let helpersUV1: string[];
      let permissionsUV1: PermissionOperation[];
      let pluginRepoPointer: PluginRepoPointer;
      let currentAppliedSetupId: string;
      const currentVersion: VersionTag = [1, 1]; // Installs with this in beforeEach below.
      const newVersion: VersionTag = [1, 2];

      beforeEach(async () => {
        pluginRepoPointer = [repoU.address, ...currentVersion];

        ({
          plugin: proxy,
          helpers: helpersUV1,
          permissions: permissionsUV1,
          appliedSetupId: currentAppliedSetupId,
        } = await installPlugin(psp, targetDao.address, pluginRepoPointer));
      });

      it('reverts if plugin does not support `IPlugin` interface', async () => {
        const currentVersion: VersionTag = [1, 2];
        const newVersion: VersionTag = [1, 3];

        // Uses build 2 that doesn't support IPlugin which is an invalid state.
        const pluginRepoPointer: PluginRepoPointer = [
          repoC.address,
          ...currentVersion,
        ];

        const {plugin, helpers} = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        );

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              plugin,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpers,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'IPluginNotSupported')
          .withArgs(plugin);
      });

      it('reverts if plugin supports the `IPlugin` interface, but is non-upgradable', async () => {
        let pluginRepoPointer: PluginRepoPointer = [
          repoC.address,
          ...currentVersion,
        ];

        const {plugin: pluginCloneable, helpers: helpersUV1} =
          await installPlugin(
            psp,
            targetDao.address,
            pluginRepoPointer,
            EMPTY_DATA
          );

        const newVersion: VersionTag = [1, 2];

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              pluginCloneable,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpersUV1,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'PluginNonupgradeable')
          .withArgs(pluginCloneable);
      });

      it('reverts if release numbers differ or new build is less than or equal to current build', async () => {
        const revert = async (
          currentVersionTag: [number, number],
          newVersionTag: [number, number]
        ) => {
          await expect(
            psp.prepareUpdate(
              targetDao.address,
              createPrepareUpdateParams(
                ownerAddress,
                currentVersionTag,
                newVersionTag,
                ownerAddress,
                helpersUV1,
                EMPTY_DATA
              )
            )
          ).to.be.revertedWithCustomError(psp, 'InvalidUpdateVersion');
        };

        await revert([1, 1], [2, 2]);
        await revert([1, 1], [2, 1]);
        await revert([1, 1], [1, 1]);
      });

      it('reverts if plugin is not installed', async () => {
        const pluginRepoPointer: PluginRepoPointer = [
          repoU.address,
          ...currentVersion,
        ];

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              ownerAddress,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpersUV1,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
          .withArgs(
            ZERO_BYTES32,
            getAppliedSetupId(pluginRepoPointer, helpersUV1)
          );
      });

      it('reverts if prepare update params do not match the current `appliedSetupId`', async () => {
        {
          // Run the prepare update with modified helpers.
          const modifiedHelpers = [...helpersUV1].slice(0, -1);
          await expect(
            psp.prepareUpdate(
              targetDao.address,
              createPrepareUpdateParams(
                proxy,
                currentVersion, // current installed version
                newVersion, // new version
                pluginRepoPointer[0],
                modifiedHelpers,
                EMPTY_DATA
              )
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(
              currentAppliedSetupId,
              getAppliedSetupId(pluginRepoPointer, modifiedHelpers)
            );
        }
        {
          // Change helpers's sequence which still should still cause revert.
          const modifiedHelpers = [...helpersUV1].reverse();
          await expect(
            psp.prepareUpdate(
              targetDao.address,
              createPrepareUpdateParams(
                proxy,
                currentVersion, // current installed version
                newVersion, // new version
                pluginRepoPointer[0],
                modifiedHelpers,
                EMPTY_DATA
              )
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(
              currentAppliedSetupId,
              getAppliedSetupId(pluginRepoPointer, modifiedHelpers)
            );
        }

        {
          // Modify it so it believes the current version is newVersion
          // which should cause revert.
          const modifiedPluginRepoPointer: PluginRepoPointer = [
            pluginRepoPointer[0],
            ...newVersion,
          ];

          await expect(
            psp.prepareUpdate(
              targetDao.address,
              createPrepareUpdateParams(
                proxy,
                newVersion,
                [newVersion[0], newVersion[1] + 1], // increase version so it doesn't fail with invalid version update.
                pluginRepoPointer[0],
                helpersUV1,
                EMPTY_DATA
              )
            )
          )
            .to.be.revertedWithCustomError(psp, 'InvalidAppliedSetupId')
            .withArgs(
              currentAppliedSetupId,
              getAppliedSetupId(modifiedPluginRepoPointer, helpersUV1)
            );
        }
      });

      it('reverts if same setup is already prepared', async () => {
        const {preparedSetupId} = await prepareUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          newVersion,
          pluginRepoPointer[0],
          helpersUV1,
          EMPTY_DATA
        );

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              proxy,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpersUV1,
              EMPTY_DATA
            )
          )
        )
          .to.be.revertedWithCustomError(psp, 'SetupAlreadyPrepared')
          .withArgs(preparedSetupId);
      });

      it('allows to prepare multiple update as long as setup is different', async () => {
        await prepareUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          newVersion,
          pluginRepoPointer[0],
          helpersUV1,
          EMPTY_DATA
        );

        // change prepare update of plugin setup so it returns different struct
        // to make sure different setup id is generated.
        await setupUV2.mockHelperCount(1);

        await prepareUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          newVersion,
          pluginRepoPointer[0],
          helpersUV1,
          EMPTY_DATA
        );

        // clean up
        await setupUV2.reset();
      });

      it('correctly prepares updates when plugin setups are same, but UI different', async () => {
        // plugin setup addresses are the same, so it treats it as UIs are different.
        const currentVersion: VersionTag = [1, 5];
        const newVersion: VersionTag = [1, 6];

        const currentPluginRepoPointer: PluginRepoPointer = [
          repoU.address,
          ...currentVersion,
        ];
        const newPluginRepoPointer: PluginRepoPointer = [
          repoU.address,
          ...newVersion,
        ];

        const {plugin: proxy, helpers} = await installPlugin(
          psp,
          targetDao.address,
          currentPluginRepoPointer
        );

        const preparedSetupId = getPreparedSetupId(
          newPluginRepoPointer,
          helpers,
          [],
          EMPTY_DATA,
          PreparationType.Update
        );

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              proxy,
              currentVersion,
              newVersion,
              currentPluginRepoPointer[0],
              helpers,
              EMPTY_DATA
            )
          )
        )
          .to.emit(psp, 'UpdatePrepared')
          .withArgs(
            anyValue,
            anyValue,
            preparedSetupId,
            anyValue,
            anyValue,
            anyValue,
            anyValue,
            anyValue
          )
          .to.not.emit(setupUV4, 'UpdatePrepared');
      });

      it("successfully calls plugin setup's prepareUpdate with correct arguments", async () => {
        const data = '0x11';

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              proxy,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpersUV1,
              data
            )
          )
        )
          .to.emit(setupUV2, 'UpdatePrepared')
          .withArgs(targetDao.address, 1, (val: any) =>
            expect(val).to.deep.equal([proxy, helpersUV1, data])
          );
      });

      it('successfully prepares update and emits the correct arguments', async () => {
        // Helpers,permissions and initData are
        // what `newVersion`'s prepareUpdate is supposed to return.
        const expectedHelpers = mockHelpers(2);
        const expectedPermissions = mockPermissionsOperations(
          1,
          2,
          Operation.Grant
        );
        const initData = '0xe27e9a4e';

        const preparedSetupId = getPreparedSetupId(
          [pluginRepoPointer[0], ...newVersion],
          expectedHelpers,
          // @ts-ignore
          expectedPermissions,
          initData,
          PreparationType.Update
        );

        await expect(
          psp.prepareUpdate(
            targetDao.address,
            createPrepareUpdateParams(
              proxy,
              currentVersion,
              newVersion,
              pluginRepoPointer[0],
              helpersUV1,
              EMPTY_DATA
            )
          )
        )
          .to.emit(psp, 'UpdatePrepared')
          .withArgs(
            ownerAddress,
            targetDao.address,
            preparedSetupId,
            pluginRepoPointer[0],
            (val: any) => expect(val).to.deep.equal(newVersion),
            (val: any) =>
              expect(val).to.deep.equal([proxy, helpersUV1, EMPTY_DATA]),
            (val: any) =>
              expect(val).to.deep.equal([expectedHelpers, expectedPermissions]),
            initData
          );
      });
    });
  });

  describe('applyUpdate', function () {
    let proxy: string;
    let helpersUV1: string[];
    let permissionsUV1: PermissionOperation[];

    let currentPluginRepoPointer: PluginRepoPointer;
    let newPluginRepoPointer: PluginRepoPointer;
    let currentVersion: VersionTag = [1, 1]; // plugin's version it initially installs.
    let newVersion: VersionTag = [1, 2];

    let currentAppliedSetupId: string;

    beforeEach(async () => {
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
      );
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UPDATE_PERMISSION_ID
      );

      currentPluginRepoPointer = [repoU.address, ...currentVersion];
      newPluginRepoPointer = [repoU.address, ...newVersion];

      ({
        plugin: proxy,
        helpers: helpersUV1,
        permissions: permissionsUV1,
        appliedSetupId: currentAppliedSetupId,
      } = await installPlugin(
        psp,
        targetDao.address,
        currentPluginRepoPointer,
        EMPTY_DATA
      ));

      await targetDao.grant(
        proxy,
        psp.address,
        PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS.UPGRADE_PLUGIN_PERMISSION_ID
      );
    });

    it('reverts if caller does not have `APPLY_UPDATE_PERMISSION` permission', async () => {
      await targetDao.revoke(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UPDATE_PERMISSION_ID
      );

      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            currentPluginRepoPointer,
            EMPTY_DATA,
            permissionsUV1,
            helpersUV1
          )
        )
      )
        .to.be.revertedWithCustomError(psp, 'SetupApplicationUnauthorized')
        .withArgs(
          targetDao.address,
          ownerAddress,
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UPDATE_PERMISSION_ID
        );
    });

    it("reverts if PluginSetupProcessor does not have DAO's `ROOT_PERMISSION`", async () => {
      await targetDao.revoke(
        targetDao.address,
        psp.address,
        DAO_PERMISSIONS.ROOT_PERMISSION_ID
      );

      const {
        preparedSetupData: {permissions, helpers},
        initData,
      } = await prepareUpdate(
        psp,
        targetDao.address,
        proxy,
        currentVersion,
        newVersion,
        currentPluginRepoPointer[0],
        helpersUV1,
        EMPTY_DATA
      );

      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            newPluginRepoPointer,
            initData,
            permissions,
            helpers
          )
        )
      )
        .to.be.revertedWithCustomError(targetDao, 'Unauthorized')
        .withArgs(
          targetDao.address,
          psp.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID
        );
    });

    it('reverts if the plugin setup processor does not have the `UPGRADE_PLUGIN_PERMISSION_ID` permission', async () => {
      await targetDao.revoke(
        proxy,
        psp.address,
        PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS.UPGRADE_PLUGIN_PERMISSION_ID
      );

      const {
        preparedSetupData: {permissions, helpers},
        initData,
      } = await prepareUpdate(
        psp,
        targetDao.address,
        proxy,
        currentVersion,
        newVersion,
        currentPluginRepoPointer[0],
        helpersUV1,
        EMPTY_DATA
      );

      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            newPluginRepoPointer,
            initData,
            permissions,
            helpers
          )
        )
      )
        .to.be.revertedWithCustomError(psp, 'PluginProxyUpgradeFailed')
        .withArgs(proxy, await setupUV2.callStatic.implementation(), initData);
    });

    it('reverts if preparation has not happened yet for update', async () => {
      const preparedSetupId = getPreparedSetupId(
        currentPluginRepoPointer,
        helpersUV1,
        permissionsUV1,
        EMPTY_DATA,
        PreparationType.Update
      );
      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            currentPluginRepoPointer,
            EMPTY_DATA,
            permissionsUV1,
            helpersUV1
          )
        )
      )
        .to.be.revertedWithCustomError(psp, 'SetupNotApplicable')
        .withArgs(preparedSetupId);
    });

    it('EDGE-CASE: reverts for both preparations once one of them gets applied', async () => {
      // Prepare first which updates to `newVersion`
      const firstPreparationNewVersion = newVersion;
      const {
        preparedSetupData: {
          permissions: firstPreparationPermissions,
          helpers: firstPreparationHelpers,
        },
        initData: firstPreparationInitData,
      } = await prepareUpdate(
        psp,
        targetDao.address,
        proxy,
        currentVersion,
        firstPreparationNewVersion,
        currentPluginRepoPointer[0],
        helpersUV1,
        EMPTY_DATA
      );

      // Prepare second which updates to +1 build number than `newVersion`.
      const secondPreparationNewVersion: VersionTag = [
        newVersion[0],
        newVersion[1] + 1,
      ];
      const {
        preparedSetupData: {
          permissions: secondPreparationPermissions,
          helpers: secondPreparationHelpers,
        },
        initData: secondPreparationInitData,
        preparedSetupId,
      } = await prepareUpdate(
        psp,
        targetDao.address,
        proxy,
        currentVersion,
        secondPreparationNewVersion,
        currentPluginRepoPointer[0],
        helpersUV1,
        EMPTY_DATA
      );

      await expect(
        psp.callStatic.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            newPluginRepoPointer,
            firstPreparationInitData,
            firstPreparationPermissions,
            firstPreparationHelpers
          )
        )
      ).not.to.be.reverted;

      await expect(
        psp.callStatic.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            [
              newPluginRepoPointer[0],
              secondPreparationNewVersion[0],
              secondPreparationNewVersion[1],
            ],
            secondPreparationInitData,
            secondPreparationPermissions,
            secondPreparationHelpers
          )
        )
      ).not.to.be.reverted;

      // Apply one of the preparation
      await applyUpdate(
        psp,
        targetDao.address,
        proxy,
        [
          newPluginRepoPointer[0],
          secondPreparationNewVersion[0],
          secondPreparationNewVersion[1],
        ],
        secondPreparationInitData,
        secondPreparationPermissions,
        secondPreparationHelpers
      );

      // confirm that now preparations can't be applied anymore
      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            newPluginRepoPointer,
            firstPreparationInitData,
            firstPreparationPermissions,
            firstPreparationHelpers
          )
        )
      ).to.be.reverted;
      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            [
              newPluginRepoPointer[0],
              secondPreparationNewVersion[0],
              secondPreparationNewVersion[1],
            ],
            secondPreparationInitData,
            secondPreparationPermissions,
            secondPreparationHelpers
          )
        )
      ).to.be.reverted;
    });

    describe('Whether upgrade functions of proxy get called the right way', async () => {
      it('correctly applies updates when plugin setups are same, but UI different', async () => {
        // plugin setup addresses are the same, so it treats it as UIs are different.
        const currentV: VersionTag = [1, 5];
        const newV: VersionTag = [1, 6];
        const currentPluginRepoPointer: PluginRepoPointer = [
          repoU.address,
          1,
          5,
        ];

        const {plugin, helpers} = await installPlugin(
          psp,
          targetDao.address,
          currentPluginRepoPointer
        );

        const {
          initData,
          preparedSetupData: {permissions, helpers: helpersUpdate},
        } = await prepareUpdate(
          psp,
          targetDao.address,
          plugin,
          currentV,
          newV,
          repoU.address,
          helpers,
          EMPTY_DATA
        );

        const pluginInstance = PluginUUPSUpgradeable__factory.connect(
          plugin,
          signers[0]
        );

        await expect(
          psp.applyUpdate(
            targetDao.address,
            createApplyUpdateParams(
              plugin,
              [repoU.address, ...newV],
              initData,
              permissions,
              helpersUpdate
            )
          )
        ).to.not.emit(pluginInstance, 'Upgraded');
      });

      it('successfully calls `upgradeToAndCall` on plugin if initData was provided by pluginSetup', async () => {
        const {
          initData,
          preparedSetupData: {permissions, helpers: helpersUpdate},
        } = await prepareUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          newVersion,
          repoU.address,
          helpersUV1,
          EMPTY_DATA
        );

        const pluginInstance = PluginUUPSUpgradeable__factory.connect(
          proxy,
          signers[0]
        );
        const newImpl = await setupUV2.implementation();

        await expect(
          psp.applyUpdate(
            targetDao.address,
            createApplyUpdateParams(
              proxy,
              [repoU.address, ...newVersion],
              initData,
              permissions,
              helpersUpdate
            )
          )
        )
          .to.emit(pluginInstance, 'Upgraded')
          .withArgs(newImpl);
      });
    });

    it('successfuly updates and emits the correct event arguments', async () => {
      const {
        preparedSetupId,
        initData,
        preparedSetupData: {permissions, helpers},
      } = await prepareUpdate(
        psp,
        targetDao.address,
        proxy,
        currentVersion,
        newVersion,
        currentPluginRepoPointer[0],
        helpersUV1,
        EMPTY_DATA
      );

      const appliedSetupId = getAppliedSetupId(newPluginRepoPointer, helpers);

      await expect(
        psp.applyUpdate(
          targetDao.address,
          createApplyUpdateParams(
            proxy,
            newPluginRepoPointer,
            initData,
            permissions,
            helpers
          )
        )
      )
        .to.emit(psp, 'UpdateApplied')
        .withArgs(targetDao.address, proxy, preparedSetupId, appliedSetupId);
    });
  });

  describe('Update scenarios', function () {
    beforeEach(async () => {
      // Grant necessary permission to `ownerAddress` so it can install and upadate plugins on behalf of the DAO.
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID
      );
      await targetDao.grant(
        psp.address,
        ownerAddress,
        PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_UPDATE_PERMISSION_ID
      );
    });

    context(`V1 was installed`, function () {
      let proxy: string;
      let helpersUV1: string[];
      let permissionsUV1: PermissionOperation[];

      let currentVersion: VersionTag = [1, 1];
      let pluginRepoPointer: PluginRepoPointer;

      beforeEach(async () => {
        pluginRepoPointer = [repoU.address, 1, 1];

        ({
          plugin: proxy,
          helpers: helpersUV1,
          permissions: permissionsUV1,
        } = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        ));

        await targetDao.grant(
          proxy,
          psp.address,
          PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS.UPGRADE_PLUGIN_PERMISSION_ID
        );
      });

      it('points to the V1 implementation', async () => {
        expect(
          await PluginUV1.attach(proxy).callStatic.implementation()
        ).to.equal(await setupUV1.callStatic.implementation());
      });

      it('initializes the members', async () => {
        expect(await PluginUV1.attach(proxy).state1()).to.equal(1);
      });

      it('sets the V1 helpers', async () => {
        expect(helpersUV1).to.deep.equal(mockHelpers(2));
      });

      it('sets the V1 permissions', async () => {
        expect(permissionsUV1).to.deep.equal(
          mockPermissionsOperations(0, 2, Operation.Grant)
        );
      });

      it('updates to V2: Contract was actually updated', async () => {
        await updateAndValidatePluginUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          [1, 2],
          pluginRepoPointer[0],
          helpersUV1,
          EMPTY_DATA
        );
      });

      it('updates to V3', async () => {
        await updateAndValidatePluginUpdate(
          psp,
          targetDao.address,
          proxy,
          currentVersion,
          [1, 3],
          pluginRepoPointer[0],
          helpersUV1,
          EMPTY_DATA
        );
      });

      context(`and updated to V2`, function () {
        let helpersV2: string[];
        let permissionsUV1V2: PermissionOperation[];
        let initDataV1V2: BytesLike;
        let currentVersion: VersionTag = [1, 2];

        beforeEach(async () => {
          ({
            updatedHelpers: helpersV2,
            permissions: permissionsUV1V2,
            initData: initDataV1V2,
          } = await updatePlugin(
            psp,
            targetDao.address,
            proxy,
            [1, 1],
            [1, 2],
            pluginRepoPointer[0],
            helpersUV1,
            EMPTY_DATA
          ));
        });

        it('points to the V2 implementation', async () => {
          expect(
            await PluginUV2.attach(proxy).callStatic.implementation()
          ).to.equal(await setupUV2.callStatic.implementation());
        });

        it('initializes the members', async () => {
          expect(await PluginUV2.attach(proxy).state1()).to.equal(1);
          expect(await PluginUV2.attach(proxy).state2()).to.equal(2);
        });

        it('sets the V2 helpers', async () => {
          expect(helpersV2).to.deep.equal(mockHelpers(2));
        });

        it('sets the V1 to V2 permissions', async () => {
          expect(permissionsUV1V2).to.deep.equal(
            mockPermissionsOperations(1, 2, Operation.Grant).map(perm =>
              Object.values(perm)
            )
          );
        });

        it('updates to V3', async () => {
          await updateAndValidatePluginUpdate(
            psp,
            targetDao.address,
            proxy,
            currentVersion,
            [1, 3],
            pluginRepoPointer[0],
            helpersV2,
            EMPTY_DATA
          );
        });

        context(`and updated to V3`, function () {
          let helpersV3: string[];
          let permissionsV2V3: PermissionOperation[];
          let initDataV2V3: BytesLike;

          beforeEach(async () => {
            ({
              updatedHelpers: helpersV3,
              permissions: permissionsV2V3,
              initData: initDataV2V3,
            } = await updatePlugin(
              psp,
              targetDao.address,
              proxy,
              [1, 2],
              [1, 3],
              pluginRepoPointer[0],
              helpersV2,
              EMPTY_DATA
            ));
          });

          it('points to the V3 implementation', async () => {
            expect(
              await PluginUV3.attach(proxy).callStatic.implementation()
            ).to.equal(await setupUV3.callStatic.implementation());
          });

          it('initializes the members', async () => {
            expect(await PluginUV3.attach(proxy).state1()).to.equal(1);
            expect(await PluginUV3.attach(proxy).state2()).to.equal(2);
            expect(await PluginUV3.attach(proxy).state3()).to.equal(3);
          });

          it('sets the V3 helpers', async () => {
            expect(helpersV3).to.deep.equal(mockHelpers(3));
          });

          it('sets the V2 to V3 permissions', async () => {
            expect(permissionsV2V3).to.deep.equal(
              mockPermissionsOperations(2, 3, Operation.Grant).map(perm =>
                Object.values(perm)
              )
            );
          });
        });
      });
      context(`and updated to V3`, function () {
        let helpersV3: string[];
        let permissionsUV1V3: PermissionOperation[];
        let initDataV1V3: BytesLike;

        beforeEach(async () => {
          ({
            updatedHelpers: helpersV3,
            permissions: permissionsUV1V3,
            initData: initDataV1V3,
          } = await updatePlugin(
            psp,
            targetDao.address,
            proxy,
            [1, 1],
            [1, 3],
            pluginRepoPointer[0],
            helpersUV1,
            EMPTY_DATA
          ));
        });

        it('points to the V3 implementation', async () => {
          expect(
            await PluginUV3.attach(proxy).callStatic.implementation()
          ).to.equal(await setupUV3.callStatic.implementation());
        });

        it('initializes the members', async () => {
          expect(await PluginUV3.attach(proxy).state1()).to.equal(1);
          expect(await PluginUV3.attach(proxy).state2()).to.equal(2);
          expect(await PluginUV3.attach(proxy).state3()).to.equal(3);
        });

        it('sets the V3 helpers', async () => {
          expect(helpersV3).to.deep.equal(mockHelpers(3));
        });

        it('sets the V1 to V3 permissions', async () => {
          expect(permissionsUV1V3).to.deep.equal(
            mockPermissionsOperations(1, 3, Operation.Grant).map(perm =>
              Object.values(perm)
            )
          );
        });
      });
    });

    context(`V2 was installed`, function () {
      let proxy: string;
      let helpersV2: string[];
      let permissionsV2: PermissionOperation[];
      let pluginRepoPointer: PluginRepoPointer;
      beforeEach(async () => {
        pluginRepoPointer = [repoU.address, 1, 2];
        ({
          plugin: proxy,
          helpers: helpersV2,
          permissions: permissionsV2,
        } = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        ));

        await targetDao.grant(
          proxy,
          psp.address,
          PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS.UPGRADE_PLUGIN_PERMISSION_ID
        );
      });

      it('points to the V2 implementation', async () => {
        expect(
          await PluginUV2.attach(proxy).callStatic.implementation()
        ).to.equal(await setupUV2.callStatic.implementation());
      });

      it('initializes the members', async () => {
        expect(await PluginUV2.attach(proxy).state1()).to.equal(1);
        expect(await PluginUV2.attach(proxy).state2()).to.equal(2);
      });

      it('sets the V2 helpers', async () => {
        expect(helpersV2).to.deep.equal(mockHelpers(2));
      });

      it('sets the V2 permissions', async () => {
        expect(permissionsV2).to.deep.equal(
          mockPermissionsOperations(0, 2, Operation.Grant).map(perm =>
            Object.values(perm)
          )
        );
      });

      it('updates to V3', async () => {
        await updateAndValidatePluginUpdate(
          psp,
          targetDao.address,
          proxy,
          [1, 2],
          [1, 3],
          pluginRepoPointer[0],
          helpersV2,
          EMPTY_DATA
        );
      });

      context(`and updated to V3`, function () {
        let helpersV3: string[];
        let permissionsV2V3: PermissionOperation[];
        let initDataV2V3: BytesLike;

        beforeEach(async () => {
          ({
            updatedHelpers: helpersV3,
            permissions: permissionsV2V3,
            initData: initDataV2V3,
          } = await updatePlugin(
            psp,
            targetDao.address,
            proxy,
            [1, 2],
            [1, 3],
            pluginRepoPointer[0],
            helpersV2,
            EMPTY_DATA
          ));
        });

        it('points to the V3 implementation', async () => {
          expect(
            await PluginUV3.attach(proxy).callStatic.implementation()
          ).to.equal(await setupUV3.callStatic.implementation());
        });

        it('initializes the members', async () => {
          expect(await PluginUV3.attach(proxy).state1()).to.equal(1);
          expect(await PluginUV3.attach(proxy).state2()).to.equal(2);
          expect(await PluginUV3.attach(proxy).state3()).to.equal(3);
        });

        it('sets the V3 helpers', async () => {
          expect(helpersV3).to.deep.equal(mockHelpers(3));
        });

        it('sets the V2 to V3 permissions', async () => {
          expect(permissionsV2V3).to.deep.equal(
            mockPermissionsOperations(2, 3, Operation.Grant).map(perm =>
              Object.values(perm)
            )
          );
        });
      });
    });

    context(`V3 was installed`, function () {
      let proxy: string;
      let helpersV3: string[];
      let permissionsV3: PermissionOperation[];
      let pluginRepoPointer: PluginRepoPointer;
      beforeEach(async () => {
        pluginRepoPointer = [repoU.address, 1, 3];

        ({
          plugin: proxy,
          helpers: helpersV3,
          permissions: permissionsV3,
        } = await installPlugin(
          psp,
          targetDao.address,
          pluginRepoPointer,
          EMPTY_DATA
        ));

        await targetDao.grant(
          proxy,
          psp.address,
          PLUGIN_UUPS_UPGRADEABLE_PERMISSIONS.UPGRADE_PLUGIN_PERMISSION_ID
        );
      });

      it('points to the V3 implementation', async () => {
        expect(
          await PluginUV3.attach(proxy).callStatic.implementation()
        ).to.equal(await setupUV3.callStatic.implementation());
      });

      it('initializes the members', async () => {
        expect(await PluginUV3.attach(proxy).state1()).to.equal(1);
        expect(await PluginUV3.attach(proxy).state2()).to.equal(2);
        expect(await PluginUV3.attach(proxy).state3()).to.equal(3);
      });

      it('sets the V3 helpers', async () => {
        expect(helpersV3).to.deep.equal(mockHelpers(3));
      });

      it('sets the V3 permissions', async () => {
        expect(permissionsV3).to.deep.equal(
          mockPermissionsOperations(0, 3, Operation.Grant).map(perm =>
            Object.values(perm)
          )
        );
      });

      // Special case where implementations from old and new setups don't change.
      it('updates to v5', async () => {
        await updateAndValidatePluginUpdate(
          psp,
          targetDao.address,
          proxy,
          [1, 3],
          [1, 5],
          pluginRepoPointer[0],
          helpersV3,
          EMPTY_DATA
        );
      });
    });
  });
});

async function updateAndValidatePluginUpdate(
  psp: PluginSetupProcessor,
  targetDao: string,
  proxy: string,
  currentVersionTag: VersionTag,
  newVersionTag: VersionTag,
  pluginRepo: string,
  currentHelpers: string[],
  data: BytesLike = EMPTY_DATA
) {
  await updatePlugin(
    psp,
    targetDao,
    proxy,
    currentVersionTag,
    newVersionTag,
    pluginRepo,
    currentHelpers,
    data
  );

  const signers = await ethers.getSigners();

  const PluginRepoFactory = new PluginRepo__factory(signers[0]);
  const repo = PluginRepoFactory.attach(pluginRepo);

  const currentVersion = await repo['getVersion((uint8,uint16))']({
    release: currentVersionTag[0],
    build: currentVersionTag[1],
  });
  const newVersion = await repo['getVersion((uint8,uint16))']({
    release: newVersionTag[0],
    build: newVersionTag[1],
  });

  const PluginSetupFactory = new PluginUUPSUpgradeableSetupV1Mock__factory(
    signers[0]
  );

  const currentPluginSetup = PluginSetupFactory.attach(
    currentVersion.pluginSetup
  );
  const newPluginSetup = PluginSetupFactory.attach(newVersion.pluginSetup);

  // If the base contracts don't change from current and new plugin setups,
  // PluginSetupProcessor shouldn't call `upgradeTo` or `upgradeToAndCall`
  // on the plugin. The below check for this still is not 100% ensuring,
  // As function `upgradeTo` might be called but event `Upgraded`
  // not thrown(OZ changed the logic or name) which will trick the test to pass..
  const currentImpl = await currentPluginSetup.implementation();
  const newImpl = await newPluginSetup.implementation();

  if (currentImpl != newImpl) {
    const proxyContract = PluginUUPSUpgradeable__factory.connect(
      proxy,
      signers[0]
    );

    expect(await proxyContract.implementation()).to.equal(newImpl);
  }
}


### File: /home/errick/core/packages/contracts/test/framework/plugin/plugin-setup.ts ###
import {
  IERC165__factory,
  IPluginSetup__factory,
  IProtocolVersion__factory,
  PluginCloneableV1Mock__factory,
  PluginCloneableSetupV1Mock,
  PluginCloneableSetupV1Mock__factory,
} from '../../../typechain';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {getInterfaceId} from '@aragon/osx-commons-sdk';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

describe('PluginSetup', function () {
  let setupMock: PluginCloneableSetupV1Mock;

  before(async () => {
    const pluginImplementation = await hre.wrapper.deploy(
      'PluginCloneableV1Mock'
    );
    setupMock = await hre.wrapper.deploy('PluginCloneableSetupV1Mock', {
      args: [pluginImplementation.address],
    });
  });

  describe('ERC-165', async () => {
    it('does not support the empty interface', async () => {
      expect(await setupMock.supportsInterface('0xffffffff')).to.be.false;
    });

    it('supports the `IERC165` interface', async () => {
      const iface = IERC165__factory.createInterface();
      expect(await setupMock.supportsInterface(getInterfaceId(iface))).to.be
        .true;
    });

    it('supports the `IPluginSetup` interface', async () => {
      const iface = IPluginSetup__factory.createInterface();
      expect(await setupMock.supportsInterface(getInterfaceId(iface))).to.be
        .true;
    });

    it('supports the `IProtocolVersion` interface', async () => {
      const iface = IProtocolVersion__factory.createInterface();
      expect(await setupMock.supportsInterface(getInterfaceId(iface))).to.be
        .true;
    });
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await setupMock.protocolVersion()).to.deep.equal(
        osxContractsVersion()
      );
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/plugin/plugin-repo-factory.ts ###
import {
  PluginRepoRegistry,
  DAO,
  PluginRepoFactory,
  PluginRepoFactory__factory,
  PluginRepo__factory,
  IProtocolVersion__factory,
  IERC165__factory,
} from '../../../typechain';
import {deployNewDAO} from '../../test-utils/dao';
import {deployENSSubdomainRegistrar} from '../../test-utils/ens';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {
  deployMockPluginSetup,
  deployPluginRepoRegistry,
} from '../../test-utils/repo';
import {
  PLUGIN_REGISTRY_PERMISSIONS,
  getInterfaceId,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

const EVENTS = {
  PluginRepoRegistered: 'PluginRepoRegistered',
  VersionCreated: 'VersionCreated',
  ReleaseMetadataUpdated: 'ReleaseMetadataUpdated',
};

async function getExpectedRepoAddress(from: string) {
  const nonce = await hre.wrapper.getNonce(from, 'Deployment');
  const expectedAddress = hre.wrapper.getCreateAddress(from, nonce);

  return expectedAddress;
}

describe('PluginRepoFactory: ', function () {
  let signers: SignerWithAddress[];
  let pluginRepoRegistry: PluginRepoRegistry;
  let ownerAddress: string;
  let managingDao: DAO;
  let pluginRepoFactory: PluginRepoFactory;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();
  });

  beforeEach(async function () {
    // DAO
    managingDao = await deployNewDAO(signers[0]);

    // ENS subdomain Registry
    const ensSubdomainRegistrar = await deployENSSubdomainRegistrar(
      signers[0],
      managingDao,
      'dao.eth'
    );

    // deploy and initialize PluginRepoRegistry
    pluginRepoRegistry = await deployPluginRepoRegistry(
      managingDao,
      ensSubdomainRegistrar,
      signers[0]
    );

    // deploy PluginRepoFactory
    pluginRepoFactory = await hre.wrapper.deploy('PluginRepoFactory', {
      args: [pluginRepoRegistry.address],
    });

    // grant REGISTER_PERMISSION_ID to pluginRepoFactory
    await managingDao.grant(
      pluginRepoRegistry.address,
      pluginRepoFactory.address,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    // grant REGISTER_PERMISSION_ID to pluginRepoFactory
    await managingDao.grant(
      ensSubdomainRegistrar.address,
      pluginRepoRegistry.address,
      PLUGIN_REGISTRY_PERMISSIONS.ENS_REGISTRAR_PERMISSIONS
        .REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );
  });

  describe('ERC-165', async () => {
    it('does not support the empty interface', async () => {
      expect(await pluginRepoFactory.supportsInterface('0xffffffff')).to.be
        .false;
    });

    it('supports the `IERC165` interface', async () => {
      const iface = IERC165__factory.createInterface();
      expect(await pluginRepoFactory.supportsInterface(getInterfaceId(iface)))
        .to.be.true;
    });

    it('supports the `IProtocolVersion` interface', async () => {
      const iface = IProtocolVersion__factory.createInterface();
      expect(await pluginRepoFactory.supportsInterface(getInterfaceId(iface)))
        .to.be.true;
    });
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await pluginRepoFactory.protocolVersion()).to.deep.equal(
        osxContractsVersion()
      );
    });
  });

  describe('CreatePluginRepo', async () => {
    it('fail to create new pluginRepo with no PLUGIN_REGISTER_PERMISSION', async () => {
      await managingDao.revoke(
        pluginRepoRegistry.address,
        pluginRepoFactory.address,
        PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
      );

      await expect(
        pluginRepoFactory.createPluginRepo('my-pluginRepo', ownerAddress)
      )
        .to.be.revertedWithCustomError(pluginRepoRegistry, 'DaoUnauthorized')
        .withArgs(
          managingDao.address,
          pluginRepoRegistry.address,
          pluginRepoFactory.address,
          PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
        );
    });

    it('creates new pluginRepo and sets up correct permissions', async () => {
      const pluginRepoSubdomain = 'my-plugin-repo';
      const expectedRepoAddress = await getExpectedRepoAddress(
        pluginRepoFactory.address
      );
      const PluginRepo = new PluginRepo__factory(signers[0]);
      const pluginRepo = PluginRepo.attach(expectedRepoAddress);

      let tx = await pluginRepoFactory.createPluginRepo(
        pluginRepoSubdomain,
        ownerAddress
      );

      await expect(tx)
        .to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered)
        .withArgs(pluginRepoSubdomain, expectedRepoAddress)
        .to.not.emit(pluginRepo, EVENTS.VersionCreated)
        .to.not.emit(pluginRepo, EVENTS.ReleaseMetadataUpdated);

      const permissions = [
        ethers.utils.id('MAINTAINER_PERMISSION'),
        ethers.utils.id('UPGRADE_REPO_PERMISSION'),
        ethers.utils.id('ROOT_PERMISSION'),
      ];

      for (let i = 0; i < permissions.length; i++) {
        expect(
          await pluginRepo.isGranted(
            pluginRepo.address,
            ownerAddress,
            permissions[i],
            '0x'
          )
        ).to.be.true;

        expect(
          await pluginRepo.isGranted(
            pluginRepo.address,
            pluginRepoFactory.address,
            permissions[i],
            '0x'
          )
        ).to.be.false;
      }
    });
  });

  describe('CreatePluginRepoWithFirstVersion', async () => {
    it('fail to create new pluginRepo with no PLUGIN_REGISTER_PERMISSION', async () => {
      await managingDao.revoke(
        pluginRepoRegistry.address,
        pluginRepoFactory.address,
        PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
      );

      await expect(
        pluginRepoFactory.createPluginRepoWithFirstVersion(
          'my-pluginRepo',
          ownerAddress,
          ownerAddress,
          '0x',
          '0x'
        )
      )
        .to.be.revertedWithCustomError(pluginRepoRegistry, 'DaoUnauthorized')
        .withArgs(
          managingDao.address,
          pluginRepoRegistry.address,
          pluginRepoFactory.address,
          PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
        );
    });

    it('creates new pluginRepo with correct permissions', async () => {
      const pluginRepoSubdomain = 'my-plugin-repo';
      const pluginSetupMock = await deployMockPluginSetup(signers[0]);
      const expectedRepoAddress = await getExpectedRepoAddress(
        pluginRepoFactory.address
      );
      const PluginRepo = new PluginRepo__factory(signers[0]);
      const pluginRepo = PluginRepo.attach(expectedRepoAddress);

      let tx = await pluginRepoFactory.createPluginRepoWithFirstVersion(
        pluginRepoSubdomain,
        pluginSetupMock.address,
        ownerAddress,
        '0x11',
        '0x11'
      );

      await expect(tx)
        .to.emit(pluginRepoRegistry, EVENTS.PluginRepoRegistered)
        .withArgs(pluginRepoSubdomain, expectedRepoAddress)
        .to.emit(pluginRepo, EVENTS.VersionCreated)
        .withArgs(1, 1, pluginSetupMock.address, '0x11')
        .to.emit(pluginRepo, EVENTS.ReleaseMetadataUpdated)
        .withArgs(1, '0x11');

      const permissions = [
        ethers.utils.id('MAINTAINER_PERMISSION'),
        ethers.utils.id('UPGRADE_REPO_PERMISSION'),
        ethers.utils.id('ROOT_PERMISSION'),
      ];

      for (let i = 0; i < permissions.length; i++) {
        expect(
          await pluginRepo.isGranted(
            pluginRepo.address,
            ownerAddress,
            permissions[i],
            '0x'
          )
        ).to.be.true;

        expect(
          await pluginRepo.isGranted(
            pluginRepo.address,
            pluginRepoFactory.address,
            permissions[i],
            '0x'
          )
        ).to.be.false;
      }
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/plugin/plugin-repo.ts ###
// This is an extension (adaptation) of the work at:
// https://github.com/aragon/apm/blob/next/test/contracts/apm/apm_repo.js
import {
  PluginRepo,
  PluginRepo__factory,
  PluginUUPSUpgradeableSetupV1Mock,
  PlaceholderSetup__factory,
  IERC165__factory,
  IPluginRepo__factory,
  IProtocolVersion__factory,
  PluginUUPSUpgradeableV1Mock__factory,
} from '../../../typechain';
import {PluginRepo__factory as PluginRepo_V1_0_0__factory} from '../../../typechain/@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepo.sol';
import {PluginRepo__factory as PluginRepo_V1_3_0__factory} from '../../../typechain/@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepo.sol';
import {OZ_INITIALIZED_SLOT_POSITION} from '../../../utils/storage';
import {ZERO_BYTES32} from '../../test-utils/dao';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {tagHash} from '../../test-utils/psp/hash-helpers';
import {
  deployMockPluginSetup,
  deployNewPluginRepo,
} from '../../test-utils/repo';
import {
  deployAndUpgradeFromToCheck,
  deployAndUpgradeSelfCheck,
} from '../../test-utils/uups-upgradeable';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {
  PLUGIN_REPO_PERMISSIONS,
  getInterfaceId,
  getProtocolVersion,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {ContractFactory} from 'ethers';
import hre, {ethers} from 'hardhat';

const emptyBytes = '0x00';
const BUILD_METADATA = '0x11';
const RELEASE_METADATA = '0x1111';
const MAINTAINER_PERMISSION_ID = ethers.utils.id('MAINTAINER_PERMISSION');

describe('PluginRepo', function () {
  let ownerAddress: string;
  let pluginRepo: PluginRepo;
  let signers: SignerWithAddress[];
  let pluginSetupMock: PluginUUPSUpgradeableSetupV1Mock;
  let initArgs: any;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();
  });

  beforeEach(async function () {
    // deploy a pluginRepo and initialize
    pluginRepo = await deployNewPluginRepo(signers[0]);

    // deploy pluging factory mock
    pluginSetupMock = await deployMockPluginSetup(signers[0]);
  });

  describe('Initialize', () => {
    it('initializes correctly', async () => {
      const permissions = [
        ethers.utils.id('MAINTAINER_PERMISSION'),
        ethers.utils.id('UPGRADE_REPO_PERMISSION'),
        ethers.utils.id('ROOT_PERMISSION'),
      ];

      for (let i = 0; i < permissions.length; i++) {
        expect(
          await pluginRepo.isGranted(
            pluginRepo.address,
            ownerAddress,
            permissions[i],
            '0x'
          )
        ).to.be.true;
      }
    });

    describe('Upgrades', () => {
      let legacyContractFactory: ContractFactory;
      let currentContractFactory: ContractFactory;

      before(() => {
        currentContractFactory = new PluginRepo__factory(signers[0]);

        initArgs = {
          initialOwner: ownerAddress,
        };
      });

      it('upgrades to a new implementation', async () => {
        await deployAndUpgradeSelfCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.PLUGIN_REPO,
          ARTIFACT_SOURCES.PLUGIN_REPO,
          PLUGIN_REPO_PERMISSIONS.UPGRADE_REPO_PERMISSION_ID
        );
      });

      it('upgrades from v1.0.0', async () => {
        legacyContractFactory = new PluginRepo_V1_0_0__factory(signers[0]);

        const {fromImplementation, toImplementation} =
          await deployAndUpgradeFromToCheck(
            0,
            1,
            {
              initArgs: initArgs,
              initializer: 'initialize',
            },
            ARTIFACT_SOURCES.PLUGIN_REPO_V1_0_0,
            ARTIFACT_SOURCES.PLUGIN_REPO,
            PLUGIN_REPO_PERMISSIONS.UPGRADE_REPO_PERMISSION_ID
          );
        expect(toImplementation).to.not.equal(fromImplementation);

        const fromProtocolVersion = await getProtocolVersion(
          legacyContractFactory.attach(fromImplementation)
        );
        const toProtocolVersion = await getProtocolVersion(
          currentContractFactory.attach(toImplementation)
        );

        expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
        expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
        expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
      });

      it('from v1.3.0', async () => {
        legacyContractFactory = new PluginRepo_V1_3_0__factory(signers[0]);

        const {fromImplementation, toImplementation} =
          await deployAndUpgradeFromToCheck(
            0,
            1,
            {
              initArgs: initArgs,
              initializer: 'initialize',
            },
            ARTIFACT_SOURCES.PLUGIN_REPO_V1_3_0,
            ARTIFACT_SOURCES.PLUGIN_REPO,
            PLUGIN_REPO_PERMISSIONS.UPGRADE_REPO_PERMISSION_ID
          );
        expect(toImplementation).to.not.equal(fromImplementation);

        const fromProtocolVersion = await getProtocolVersion(
          legacyContractFactory.attach(fromImplementation)
        );
        const toProtocolVersion = await getProtocolVersion(
          currentContractFactory.attach(toImplementation)
        );

        expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
        expect(fromProtocolVersion).to.deep.equal([1, 3, 0]);
        expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
      });
    });
    describe('InitializeFrom', () => {
      it('reverts because the function is a placeholder', async () => {
        // Call `initializeFrom` with version 1.3.0. and revert
        await expect(pluginRepo.initializeFrom([1, 3, 0], emptyBytes)).to.be
          .reverted;
      });
    });

    describe('ERC-165', async () => {
      it('does not support the empty interface', async () => {
        expect(await pluginRepo.supportsInterface('0xffffffff')).to.be.false;
      });

      it('supports the `IERC165` interface', async () => {
        const iface = IERC165__factory.createInterface();
        expect(await pluginRepo.supportsInterface(getInterfaceId(iface))).to.be
          .true;
      });

      it('supports the `IPluginRepo` interface', async () => {
        const iface = IPluginRepo__factory.createInterface();
        expect(getInterfaceId(iface)).to.equal('0xd4321b40'); // the interfaceID from IPluginRepo v1.0.0
        expect(await pluginRepo.supportsInterface(getInterfaceId(iface))).to.be
          .true;
      });

      it('supports the `IProtocolVersion` interface', async () => {
        const iface = IProtocolVersion__factory.createInterface();
        expect(await pluginRepo.supportsInterface(getInterfaceId(iface))).to.be
          .true;
      });
    });

    describe('Protocol version', async () => {
      it('returns the current protocol version', async () => {
        expect(await pluginRepo.protocolVersion()).to.deep.equal(
          osxContractsVersion()
        );
      });
    });

    describe('CreateVersion: ', async () => {
      it('reverts if the caller does not have permission', async () => {
        await expect(
          pluginRepo
            .connect(signers[2])
            .createVersion(1, pluginSetupMock.address, emptyBytes, emptyBytes)
        )
          .to.be.revertedWithCustomError(pluginRepo, 'Unauthorized')
          .withArgs(
            pluginRepo.address,
            signers[2].address,
            MAINTAINER_PERMISSION_ID
          );
      });

      it('fails if the plugin setup does not support the `IPluginSetup` interface', async function () {
        // If EOA Address is passed
        await expect(
          pluginRepo.createVersion(1, ownerAddress, emptyBytes, emptyBytes)
        ).to.be.revertedWithCustomError(
          pluginRepo,
          'InvalidPluginSetupInterface'
        );

        // If a contract is passed, but doesn't support `IPluginSetup`.
        await expect(
          pluginRepo.createVersion(
            1,
            pluginRepo.address,
            emptyBytes,
            emptyBytes
          )
        ).to.be.revertedWithCustomError(
          pluginRepo,
          'InvalidPluginSetupInterface'
        );

        // If a contract is passed, but doesn't have `supportsInterface` signature described in the contract.
        const randomContract = await hre.wrapper.deploy(
          'PluginUUPSUpgradeableV1Mock'
        );
        await expect(
          pluginRepo.createVersion(
            1,
            randomContract.address,
            emptyBytes,
            emptyBytes
          )
        ).to.be.revertedWithCustomError(
          pluginRepo,
          'InvalidPluginSetupInterface'
        );
      });

      it('fails if the release number is 0', async () => {
        await expect(
          pluginRepo.createVersion(
            0,
            pluginSetupMock.address,
            emptyBytes,
            emptyBytes
          )
        ).to.be.revertedWithCustomError(pluginRepo, 'ReleaseZeroNotAllowed');
      });

      it('fails if the release is incremented by more than 1', async () => {
        await pluginRepo.createVersion(
          1,
          pluginSetupMock.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );

        await expect(
          pluginRepo.createVersion(
            3,
            pluginSetupMock.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        ).to.be.revertedWithCustomError(pluginRepo, 'InvalidReleaseIncrement');
      });

      it('fails for the first release, if `releaseMetadata` is empty', async () => {
        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            '0x'
          )
        ).to.be.revertedWithCustomError(pluginRepo, 'EmptyReleaseMetadata');
      });

      it('fails if the same plugin setup exists in another release', async () => {
        const pluginSetup_1 = await deployMockPluginSetup(signers[0]);
        const pluginSetup_2 = await deployMockPluginSetup(signers[0]);

        // create release 1
        await pluginRepo.createVersion(
          1,
          pluginSetup_1.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );

        // create release 2
        await pluginRepo.createVersion(
          2,
          pluginSetup_2.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );

        // release 3 should fail as it's using the same plugin of first release
        await expect(
          pluginRepo.createVersion(
            3,
            pluginSetup_1.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.be.revertedWithCustomError(
            pluginRepo,
            'PluginSetupAlreadyInPreviousRelease'
          )
          .withArgs(1, 1, pluginSetup_1.address);

        // release 3 should fail as it's using the same plugin of second release
        await expect(
          pluginRepo.createVersion(
            3,
            pluginSetup_2.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.be.revertedWithCustomError(
            pluginRepo,
            'PluginSetupAlreadyInPreviousRelease'
          )
          .withArgs(2, 1, pluginSetup_2.address);
      });

      it('successfully creates a version and emits the correct events', async () => {
        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 1, pluginSetupMock.address, BUILD_METADATA)
          .to.emit(pluginRepo, 'ReleaseMetadataUpdated')
          .withArgs(1, RELEASE_METADATA);
      });

      it('correctly increases and emits the build number', async () => {
        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 1, pluginSetupMock.address, BUILD_METADATA);

        expect(await pluginRepo.buildCount(1)).to.equal(1);

        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 2, pluginSetupMock.address, BUILD_METADATA);

        expect(await pluginRepo.buildCount(1)).to.equal(2);
      });

      it('correctly increases and emits release number', async () => {
        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 1, pluginSetupMock.address, BUILD_METADATA);

        expect(await pluginRepo.latestRelease()).to.equal(1);

        // don't repeat the same plugin setup in the 2nd release
        // otherwise it will revert.
        const pluginSetupMock_2 = await deployMockPluginSetup(signers[0]);

        await expect(
          pluginRepo.createVersion(
            2,
            pluginSetupMock_2.address,
            BUILD_METADATA,
            RELEASE_METADATA
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(2, 1, pluginSetupMock_2.address, BUILD_METADATA);

        expect(await pluginRepo.latestRelease()).to.equal(2);
      });

      it('succeeds if release already exists and release metadata is empty', async () => {
        await pluginRepo.createVersion(
          1,
          pluginSetupMock.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );

        await expect(
          pluginRepo.createVersion(
            1,
            pluginSetupMock.address,
            BUILD_METADATA,
            '0x'
          )
        ).to.not.emit(pluginRepo, 'ReleaseMetadataUpdated');
      });

      it('allows to create placeholder builds for the same release', async () => {
        const placeholder1 = await hre.wrapper.deploy('PlaceholderSetup');
        const placeholder2 = await hre.wrapper.deploy('PlaceholderSetup');

        // Release 1
        await expect(
          pluginRepo.createVersion(
            1,
            placeholder1.address,
            ZERO_BYTES32,
            ZERO_BYTES32
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 1, placeholder1.address, ZERO_BYTES32);

        await expect(
          pluginRepo.createVersion(
            1,
            placeholder1.address,
            ZERO_BYTES32,
            ZERO_BYTES32
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(1, 2, placeholder1.address, ZERO_BYTES32);

        // Release 2
        await expect(
          pluginRepo.createVersion(
            2,
            placeholder2.address,
            ZERO_BYTES32,
            ZERO_BYTES32
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(2, 1, placeholder2.address, ZERO_BYTES32);

        await expect(
          pluginRepo.createVersion(
            2,
            placeholder2.address,
            ZERO_BYTES32,
            ZERO_BYTES32
          )
        )
          .to.emit(pluginRepo, 'VersionCreated')
          .withArgs(2, 2, placeholder2.address, ZERO_BYTES32);
      });
    });

    describe('updateReleaseMetadata', async () => {
      it('reverts if caller does not have permission', async () => {
        await expect(
          pluginRepo
            .connect(signers[2])
            .updateReleaseMetadata(1, RELEASE_METADATA)
        )
          .to.be.revertedWithCustomError(pluginRepo, 'Unauthorized')
          .withArgs(
            pluginRepo.address,
            signers[2].address,
            MAINTAINER_PERMISSION_ID
          );
      });
      it('reverts if release is 0', async () => {
        await expect(
          pluginRepo.updateReleaseMetadata(0, emptyBytes)
        ).to.be.revertedWithCustomError(pluginRepo, 'ReleaseZeroNotAllowed');
      });

      it('reverts if release does not exist', async () => {
        await expect(
          pluginRepo.updateReleaseMetadata(1, emptyBytes)
        ).to.be.revertedWithCustomError(pluginRepo, 'ReleaseDoesNotExist');
      });

      it('reverts if metadata length is 0', async () => {
        await pluginRepo.createVersion(
          1,
          pluginSetupMock.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );
        await expect(
          pluginRepo.updateReleaseMetadata(1, '0x')
        ).to.be.revertedWithCustomError(pluginRepo, 'EmptyReleaseMetadata');
      });

      it('updates metadata for the release that already exists and emits the "ReleaseMetadataUpdated" event', async () => {
        await pluginRepo.createVersion(
          1,
          pluginSetupMock.address,
          BUILD_METADATA,
          RELEASE_METADATA
        );
        await expect(pluginRepo.updateReleaseMetadata(1, '0x11'))
          .to.emit(pluginRepo, 'ReleaseMetadataUpdated')
          .withArgs(1, '0x11');
      });
    });

    describe('Different types of getVersions:', async () => {
      // R - release, B - build
      let pluginSetup_R1_B1: PluginUUPSUpgradeableSetupV1Mock;
      let pluginSetup_R1_B2: PluginUUPSUpgradeableSetupV1Mock;
      let pluginSetup_R2_B1: PluginUUPSUpgradeableSetupV1Mock;
      let BUILD_METADATA_R1_B1 = BUILD_METADATA;
      let BUILD_METADATA_R1_B2 = `${BUILD_METADATA}11`;
      let BUILD_METADATA_R2_B1 = `${BUILD_METADATA}1111`;

      beforeEach(async () => {
        pluginSetup_R1_B1 = pluginSetupMock;
        pluginSetup_R1_B2 = await deployMockPluginSetup(signers[0]);
        pluginSetup_R2_B1 = await deployMockPluginSetup(signers[0]);

        await pluginRepo.createVersion(
          1,
          pluginSetup_R1_B1.address,
          BUILD_METADATA_R1_B1,
          RELEASE_METADATA
        );

        await pluginRepo.createVersion(
          1,
          pluginSetup_R1_B2.address,
          BUILD_METADATA_R1_B2,
          RELEASE_METADATA
        );

        await pluginRepo.createVersion(
          2,
          pluginSetup_R2_B1.address,
          BUILD_METADATA_R2_B1,
          RELEASE_METADATA
        );
      });

      describe('getLatestVersion', async () => {
        it('reverts if release does not exist', async () => {
          await expect(pluginRepo['getLatestVersion(uint8)'](3))
            .to.be.revertedWithCustomError(
              pluginRepo,
              'VersionHashDoesNotExist'
            )
            .withArgs(tagHash(3, 0));
        });

        it('correctly returns the Version per release', async () => {
          const func = pluginRepo['getLatestVersion(uint8)'];

          expect(await func(1)).to.deep.equal([
            [1, 2],
            pluginSetup_R1_B2.address,
            BUILD_METADATA_R1_B2,
          ]);

          expect(await func(2)).to.deep.equal([
            [2, 1],
            pluginSetup_R2_B1.address,
            BUILD_METADATA_R2_B1,
          ]);
        });

        it('reverts if plugin setup does not exist', async () => {
          await expect(pluginRepo['getLatestVersion(address)'](ownerAddress))
            .to.be.revertedWithCustomError(
              pluginRepo,
              'VersionHashDoesNotExist'
            )
            .withArgs(
              '0x0000000000000000000000000000000000000000000000000000000000000000'
            );
        });

        it('correctly returns the Version per plugin setup', async () => {
          const func = pluginRepo['getLatestVersion(address)'];

          expect(await func(pluginSetup_R1_B1.address)).to.deep.equal([
            [1, 1],
            pluginSetup_R1_B1.address,
            BUILD_METADATA_R1_B1,
          ]);

          expect(await func(pluginSetup_R1_B2.address)).to.deep.equal([
            [1, 2],
            pluginSetup_R1_B2.address,
            BUILD_METADATA_R1_B2,
          ]);

          expect(await func(pluginSetup_R2_B1.address)).to.deep.equal([
            [2, 1],
            pluginSetup_R2_B1.address,
            BUILD_METADATA_R2_B1,
          ]);
        });
      });

      describe('getVersion', async () => {
        it('reverts if `Tag` does not exist', async () => {
          await expect(
            pluginRepo['getVersion((uint8,uint16))']({release: 1, build: 3})
          )
            .to.be.revertedWithCustomError(
              pluginRepo,
              'VersionHashDoesNotExist'
            )
            .withArgs(tagHash(1, 3));
        });

        it('correctly returns the version per `Tag`', async () => {
          const func = pluginRepo['getVersion((uint8,uint16))'];

          expect(await func({release: 1, build: 1})).to.deep.equal([
            [1, 1],
            pluginSetup_R1_B1.address,
            BUILD_METADATA_R1_B1,
          ]);

          expect(await func({release: 1, build: 2})).to.deep.equal([
            [1, 2],
            pluginSetup_R1_B2.address,
            BUILD_METADATA_R1_B2,
          ]);

          expect(await func({release: 2, build: 1})).to.deep.equal([
            [2, 1],
            pluginSetup_R2_B1.address,
            BUILD_METADATA_R2_B1,
          ]);
        });

        it('correctly returns the version per Tag hash', async () => {
          const func = pluginRepo['getVersion(bytes32)'];

          expect(await func(tagHash(1, 1))).to.deep.equal([
            [1, 1],
            pluginSetup_R1_B1.address,
            BUILD_METADATA_R1_B1,
          ]);

          expect(await func(tagHash(1, 2))).to.deep.equal([
            [1, 2],
            pluginSetup_R1_B2.address,
            BUILD_METADATA_R1_B2,
          ]);

          expect(await func(tagHash(2, 1))).to.deep.equal([
            [2, 1],
            pluginSetup_R2_B1.address,
            BUILD_METADATA_R2_B1,
          ]);
        });
      });
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/utils/registry-utils.ts ###
import {RegistryUtils, RegistryUtils__factory} from '../../../typechain';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

describe('RegistryUtils', () => {
  let registryUtilsContract: RegistryUtils;
  let signers: SignerWithAddress[];

  before(async () => {
    signers = await ethers.getSigners();
  });

  beforeEach(async () => {
    registryUtilsContract = await hre.wrapper.deploy('RegistryUtils');
  });

  describe('isSubdomainValid', () => {
    it('should validate the passed name correctly (< 32 bytes long name)', async () => {
      const baseName = 'this-is-my-super-valid-name';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        // replace the 10th char in the baseName
        const subdomainName =
          baseName.substring(0, 10) +
          String.fromCharCode(i) +
          baseName.substring(10 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          expect(await registryUtilsContract.isSubdomainValid(subdomainName)).to
            .be.true;
          continue;
        }

        expect(await registryUtilsContract.isSubdomainValid(subdomainName)).to
          .be.false;
      }
    });

    it('should validate the passed name correctly (> 32 bytes long name)', async () => {
      const baseName =
        'this-is-my-super-looooooooooooooooooooooooooong-valid-name';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        // replace the 40th char in the baseName
        const subdomainName =
          baseName.substring(0, 40) +
          String.fromCharCode(i) +
          baseName.substring(40 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          expect(await registryUtilsContract.isSubdomainValid(subdomainName)).to
            .be.true;
          continue;
        }

        expect(await registryUtilsContract.isSubdomainValid(subdomainName)).to
          .be.false;
      }
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/utils/interface-based-registry.ts ###
import {
  DAO,
  IDAO__factory,
  InterfaceBasedRegistryMock,
  InterfaceBasedRegistryMock__factory,
  PluginRepo__factory,
} from '../../../typechain';
import {deployNewDAO} from '../../test-utils/dao';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {getInterfaceId} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

const REGISTER_PERMISSION_ID = ethers.utils.id('REGISTER_PERMISSION');

const EVENTS = {
  Registered: 'Registered',
};

describe('InterfaceBasedRegistry', function () {
  let signers: SignerWithAddress[];
  let interfaceBasedRegistryMock: InterfaceBasedRegistryMock;
  let dao: DAO;
  let ownerAddress: string;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();

    // DAO
    dao = await deployNewDAO(signers[0]);
  });

  beforeEach(async () => {
    interfaceBasedRegistryMock = await hre.wrapper.deploy(
      'InterfaceBasedRegistryMock',
      {withProxy: true}
    );

    // Let the interface registry register `DAO` contracts for testing purposes
    await interfaceBasedRegistryMock.initialize(
      dao.address,
      getInterfaceId(IDAO__factory.createInterface())
    );

    // grant REGISTER_PERMISSION_ID to registrer
    await dao.grant(
      interfaceBasedRegistryMock.address,
      ownerAddress,
      REGISTER_PERMISSION_ID
    );
  });

  describe('Register', async () => {
    it('fail if registrant address is not a contract', async function () {
      const randomAddress = await signers[8].getAddress();

      await expect(interfaceBasedRegistryMock.register(randomAddress))
        .to.be.revertedWithCustomError(
          interfaceBasedRegistryMock,
          'ContractInterfaceInvalid'
        )
        .withArgs(randomAddress);
    });

    it('fail to register if the interface is not supported', async () => {
      // Use the `PluginRepo` contract for testing purposes here, because the interface differs from the `DAO` interface
      let contractNotBeingADao = await hre.wrapper.deploy(
        ARTIFACT_SOURCES.PLUGIN_REPO
      );

      await expect(
        interfaceBasedRegistryMock.register(contractNotBeingADao.address)
      )
        .to.be.revertedWithCustomError(
          interfaceBasedRegistryMock,
          'ContractInterfaceInvalid'
        )
        .withArgs(contractNotBeingADao.address);
    });

    it('fail to register if the sender lacks the required permissionId', async () => {
      await dao.revoke(
        interfaceBasedRegistryMock.address,
        ownerAddress,
        REGISTER_PERMISSION_ID
      );

      await expect(interfaceBasedRegistryMock.register(dao.address))
        .to.be.revertedWithCustomError(
          interfaceBasedRegistryMock,
          'DaoUnauthorized'
        )
        .withArgs(
          dao.address,
          interfaceBasedRegistryMock.address,
          ownerAddress,
          REGISTER_PERMISSION_ID
        );
    });

    it('fail to register if the contract is already registered', async () => {
      // contract is now registered
      await interfaceBasedRegistryMock.register(dao.address);

      // try to register the same contract again
      await expect(interfaceBasedRegistryMock.register(dao.address))
        .to.be.revertedWithCustomError(
          interfaceBasedRegistryMock,
          'ContractAlreadyRegistered'
        )
        .withArgs(dao.address);
    });

    it('register a contract with known interface', async () => {
      // make sure the address is not already registered
      expect(await interfaceBasedRegistryMock.entries(dao.address)).to.equal(
        false
      );

      await expect(interfaceBasedRegistryMock.register(dao.address))
        .to.emit(interfaceBasedRegistryMock, EVENTS.Registered)
        .withArgs(dao.address);

      expect(await interfaceBasedRegistryMock.entries(dao.address)).to.equal(
        true
      );
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/utils/ens/ens-subdomain-registry.ts ###
import {
  ENSSubdomainRegistrar,
  DAO,
  PublicResolver,
  ENSRegistry,
  ENSRegistry__factory,
  PublicResolver__factory,
  ENSSubdomainRegistrar__factory,
} from '../../../../typechain';
import {ENSSubdomainRegistrar__factory as ENSSubdomainRegistrar_V1_0_0__factory} from '../../../../typechain/@aragon/osx-v1.0.1/framework/utils/ens/ENSSubdomainRegistrar.sol';
import {ENSSubdomainRegistrar__factory as ENSSubdomainRegistrar_V1_3_0__factory} from '../../../../typechain/@aragon/osx-v1.3.0/framework/utils/ens/ENSSubdomainRegistrar.sol';
import {ensDomainHash, ensLabelHash} from '../../../../utils/ens';
import {deployNewDAO} from '../../../test-utils/dao';
import {setupResolver} from '../../../test-utils/ens';
import {osxContractsVersion} from '../../../test-utils/protocol-version';
import {
  deployAndUpgradeFromToCheck,
  deployAndUpgradeSelfCheck,
} from '../../../test-utils/uups-upgradeable';
import {ARTIFACT_SOURCES} from '../../../test-utils/wrapper';
import {
  ENS_REGISTRAR_PERMISSIONS,
  getProtocolVersion,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {ContractFactory} from 'ethers';
import hre, {ethers} from 'hardhat';

// Setup ENS with signers[0] owning the ENS root node (''), the resolver node ('resolver'), the managing DAO, and the subdomain registrar
async function setupENS(
  owner: SignerWithAddress
): Promise<[ENSRegistry, PublicResolver, DAO, ENSSubdomainRegistrar]> {
  // Deploy the ENSRegistry
  const ens = await hre.wrapper.deploy('ENSRegistry');

  // Deploy the Resolver
  const resolver = await hre.wrapper.deploy('PublicResolver', {
    args: [ens.address, ethers.constants.AddressZero],
  });

  await setupResolver(ens, resolver, owner);

  // Deploy the managing DAO
  const dao = await deployNewDAO(owner);

  // Deploy the registrar
  const registrar = await hre.wrapper.deploy(
    ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
    {
      withProxy: true,
    }
  );

  return [ens, resolver, dao, registrar];
}

describe('ENSSubdomainRegistrar', function () {
  let signers: SignerWithAddress[];
  let managingDao: DAO;
  let ens: ENSRegistry;
  let resolver: PublicResolver;
  let registrar: ENSSubdomainRegistrar;

  // A Helper function to register a subdomain under parent domain
  async function registerSubdomainHelper(
    subdomain: string,
    domain: string,
    domainOwner: SignerWithAddress,
    subdomainOwnerAddress: string
  ) {
    let fullDomain: string;
    if (domain === '') {
      fullDomain = subdomain;
    } else {
      fullDomain = subdomain + '.' + domain;
    }

    let tx = await ens
      .connect(domainOwner)
      .setSubnodeRecord(
        ensDomainHash(domain),
        ensLabelHash(subdomain),
        subdomainOwnerAddress,
        resolver.address,
        0
      );
    await tx.wait();

    // Verify that the subdomain is owned by the correct address
    expect(await ens.owner(ensDomainHash(fullDomain))).to.equal(
      subdomainOwnerAddress
    );
    // Verify that that the subdomain's resolver address is set correctly
    expect(await ens.resolver(ensDomainHash(fullDomain))).to.equal(
      resolver.address
    );
  }

  before(async function () {
    signers = await ethers.getSigners();
  });

  beforeEach(async function () {
    [ens, resolver, managingDao, registrar] = await setupENS(signers[0]);
  });

  describe('Check the initial ENS state', async () => {
    it('unregistered domains are owned by the zero address on ENS', async () => {
      expect(await ens.owner(ensDomainHash('test'))).to.equal(
        ethers.constants.AddressZero
      );
    });

    it('unregistered domains resolve to the zero address on ENS', async () => {
      expect(await resolver['addr(bytes32)'](ensDomainHash('test'))).to.equal(
        ethers.constants.AddressZero
      );
    });
  });

  describe('Registrar is the domain owner but not approved', () => {
    beforeEach(async () => {
      // Register the parent domain 'test' through signers[0] who owns the ENS root node ('') and make the subdomain registrar the owner
      await registerSubdomainHelper('test', '', signers[0], registrar.address);
    });

    it('initializes correctly', async () => {
      expect(
        await registrar
          .connect(signers[0])
          .initialize(managingDao.address, ens.address, ensDomainHash('test'))
      ).to.not.be.revertedWithCustomError(registrar, 'InvalidResolver');
    });

    postInitializationTests();

    it('reverts if the registrar do not have the ownership of the domain node', async () => {
      // Register the parent domain 'test2' through signers[0] who owns the ENS root node ('') and make the subdomain registrar the owner
      await registerSubdomainHelper(
        'test2',
        '',
        signers[0],
        signers[0].address
      );

      // Initialize the registrar with the 'test' domain
      await registrar.initialize(
        managingDao.address,
        ens.address,
        ensDomainHash('test2')
      );

      // Grant signers[1] the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission
      await managingDao.grant(
        registrar.address,
        await signers[1].getAddress(),
        ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
      );

      // signers[0] can't register subdomains
      await expect(
        registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my1'), await signers[1].getAddress())
      ).to.be.reverted;
    });

    it('reverts if the ownership of the domain node is removed from the registrar', async () => {
      // Initialize the registrar with the 'test' domain
      await registrar.initialize(
        managingDao.address,
        ens.address,
        ensDomainHash('test')
      );

      // Grant signers[1] the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission
      await managingDao.grant(
        registrar.address,
        await signers[1].getAddress(),
        ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
      );

      // signers[1] can register subdomain
      expect(
        await registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my1'), await signers[1].getAddress())
      );

      // Remove ownership of 'test' from the registrar contract address through the parent domain node owner
      await ens
        .connect(signers[0])
        .setSubnodeOwner(
          ensDomainHash(''),
          ensLabelHash('test'),
          await signers[0].getAddress()
        );

      // signers[1] can't register subdomains anymore
      await expect(
        registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my2'), await signers[1].getAddress())
      ).to.be.reverted;
    });
  });

  describe('Registrar is not the domain owner but it is approved', () => {
    beforeEach(async () => {
      // Register the parent domain 'test' through signers[0] who owns the ENS root node ('') and make the signers[0] the owner
      await registerSubdomainHelper('test', '', signers[0], signers[0].address);

      // Approve the subdomain registrar contract address to operate for signers[0] (who owns 'test')
      await ens.connect(signers[0]).setApprovalForAll(registrar.address, true);
    });

    it('initializes correctly', async () => {
      expect(
        await registrar
          .connect(signers[0])
          .initialize(managingDao.address, ens.address, ensDomainHash('test'))
      );

      // the default resolver is the resolver of the parent domain node
      expect(await registrar.resolver()).to.equal(resolver.address);
    });

    postInitializationTests();

    it('reverts if the approval of the registrar is removed', async () => {
      // Initialize the registrar with the 'test' domain
      await registrar.initialize(
        managingDao.address,
        ens.address,
        ensDomainHash('test')
      );

      // Grant signers[1] the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission
      await managingDao.grant(
        registrar.address,
        await signers[1].getAddress(),
        ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
      );

      // signers[1] can register subdomain
      expect(
        await registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my1'), await signers[1].getAddress())
      );

      // Remove approval of the registrar to manage  all domains owned by signers[0] including 'test'
      await ens.connect(signers[0]).setApprovalForAll(registrar.address, false);

      // signers[1] can't register subdomains anymore
      await expect(
        registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my2'), await signers[1].getAddress())
      ).to.be.reverted;
    });
  });

  describe('Registrar is not the domain owner and is not approved but has permission', () => {
    beforeEach(async () => {
      // Grant signers[1] the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission
      await managingDao.grant(
        registrar.address,
        await signers[1].getAddress(),
        ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
      );
    });

    expectedReverts();
  });

  describe('Random signer with no permissions at all', () => {
    expectedReverts();
  });

  describe('Upgrades', () => {
    let legacyContractFactory: ContractFactory;
    let currentContractFactory: ContractFactory;
    let initArgs: any;

    before(() => {
      currentContractFactory = new ENSSubdomainRegistrar__factory(signers[0]);
    });

    beforeEach(async () => {
      await registerSubdomainHelper('test', '', signers[0], registrar.address);

      initArgs = {
        managingDao: managingDao.address,
        ens: ens.address,
        parentDomain: ensDomainHash('test'),
      };
    });

    it('upgrades to a new implementation', async () => {
      await deployAndUpgradeSelfCheck(
        0,
        1,
        {
          initArgs: initArgs,
          initializer: 'initialize',
        },
        ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
        ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
        ENS_REGISTRAR_PERMISSIONS.UPGRADE_REGISTRAR_PERMISSION_ID,
        managingDao
      );
    });

    it('upgrades from v1.0.0', async () => {
      legacyContractFactory = new ENSSubdomainRegistrar_V1_0_0__factory(
        signers[0]
      );

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR_V1_0_0,
          ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
          ENS_REGISTRAR_PERMISSIONS.UPGRADE_REGISTRAR_PERMISSION_ID,
          managingDao
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });

    it('from v1.3.0', async () => {
      legacyContractFactory = new ENSSubdomainRegistrar_V1_3_0__factory(
        signers[0]
      );

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR_V1_3_0,
          ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
          ENS_REGISTRAR_PERMISSIONS.UPGRADE_REGISTRAR_PERMISSION_ID,
          managingDao
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });
  });

  function expectedReverts() {
    it('reverts during initialization if node does not have a valid resolver', async () => {
      await expect(
        registrar
          .connect(signers[1])
          .initialize(managingDao.address, ens.address, ensDomainHash('test2'))
      )
        .to.be.revertedWithCustomError(registrar, 'InvalidResolver')
        .withArgs(ensDomainHash('test2'), ethers.constants.AddressZero);
    });

    it('reverts on attempted subnode registration', async () => {
      // signers[1] can register subdomain
      await expect(
        registrar
          .connect(signers[1])
          .registerSubnode(ensLabelHash('my'), await signers[1].getAddress())
      ).to.be.reverted;
    });

    it('reverts on attempted default resolver setting', async () => {
      const newResolverAddr = ethers.constants.AddressZero;

      // signers[1] can register subdomain
      await expect(
        registrar.connect(signers[1]).setDefaultResolver(newResolverAddr)
      ).to.be.reverted;
    });
  }

  function postInitializationTests() {
    describe('After registrar initialization', () => {
      beforeEach(async () => {
        // Initialize the registrar with the 'test' domain
        await registrar.initialize(
          managingDao.address,
          ens.address,
          ensDomainHash('test')
        );
      });

      it('reverts if initialized a second time', async () => {
        await expect(
          registrar.initialize(
            managingDao.address,
            ens.address,
            ensDomainHash('foo')
          )
        ).to.be.revertedWith('Initializable: contract is already initialized');
      });

      it('reverts subnode registration if the calling address lacks permission of the managing DAO', async () => {
        const targetAddress = managingDao.address;

        // Register the subdomain 'my.test' as signers[1] who does not have the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` granted
        await expect(
          registrar
            .connect(signers[1])
            .registerSubnode(ensLabelHash('my'), targetAddress)
        )
          .to.be.revertedWithCustomError(registrar, 'DaoUnauthorized')
          .withArgs(
            managingDao.address,
            registrar.address,
            signers[1].address,
            ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
          );
      });

      it('reverts setting the resolver if the calling address lacks permission of the managing DAO', async () => {
        // Set a new resolver as signers[1] who does not have the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` granted
        await expect(
          registrar
            .connect(signers[1])
            .setDefaultResolver(ethers.constants.AddressZero)
        )
          .to.be.revertedWithCustomError(registrar, 'DaoUnauthorized')
          .withArgs(
            managingDao.address,
            registrar.address,
            signers[1].address,
            ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
          );
      });

      describe('After granting permission to the calling address via the managing DAO', () => {
        beforeEach(async () => {
          // Grant signers[1] and signers[2] the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission
          await managingDao.grant(
            registrar.address,
            await signers[1].getAddress(),
            ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
          );
          await managingDao.grant(
            registrar.address,
            await signers[2].getAddress(),
            ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
          );
        });

        it('registers the subdomain and resolves to the target address', async () => {
          // register 'my.test' as signers[1] and set it to resovle to the target address
          const targetAddress = managingDao.address;
          let tx = await registrar
            .connect(signers[1])
            .registerSubnode(ensLabelHash('my'), targetAddress);
          await tx.wait();

          // Check that the subdomain is still owned by the subdomain registrar
          expect(await ens.owner(ensDomainHash('my.test'))).to.equal(
            registrar.address
          );

          // Check that the subdomain resolves to the target address
          expect(
            await resolver['addr(bytes32)'](ensDomainHash('my.test'))
          ).to.equal(targetAddress);
        });

        it('reverts subnode registration if the subdomain was already registered before', async () => {
          // register 'my.test' as signers[1] and set it to resovle to the target address
          const targetAddress = managingDao.address;
          let tx = await registrar
            .connect(signers[1])
            .registerSubnode(ensLabelHash('my'), targetAddress);
          await tx.wait();

          // try to register the same subnode again as signers[2]
          await expect(
            registrar
              .connect(signers[2])
              .registerSubnode(
                ensLabelHash('my'),
                await signers[2].getAddress()
              )
          )
            .to.be.revertedWithCustomError(registrar, 'AlreadyRegistered')
            .withArgs(ensDomainHash('my.test'), registrar.address);
        });

        it('reverts subnode registration if the subdomain was already registered before, also for the same caller', async () => {
          // register 'my.test' as signers[1] and set it to resovle to the target address
          const targetAddress = managingDao.address;
          let tx = await registrar
            .connect(signers[1])
            .registerSubnode(ensLabelHash('my'), targetAddress);
          await tx.wait();

          // try to register the same subnode again as signers[1]
          await expect(
            registrar
              .connect(signers[1])
              .registerSubnode(
                ensLabelHash('my'),
                await signers[1].getAddress()
              )
          )
            .to.be.revertedWithCustomError(registrar, 'AlreadyRegistered')
            .withArgs(ensDomainHash('my.test'), registrar.address);
        });

        it('revert if invalid resolver is set', async () => {
          const newResolverAddr = ethers.constants.AddressZero;

          await expect(
            registrar.connect(signers[1]).setDefaultResolver(newResolverAddr)
          )
            .to.be.revertedWithCustomError(registrar, 'InvalidResolver')
            .withArgs(ensDomainHash('test'), newResolverAddr);
        });

        it('sets the resolver correctly', async () => {
          const newResolverAddr = await signers[8].getAddress();
          let tx = await registrar
            .connect(signers[1])
            .setDefaultResolver(newResolverAddr);
          await tx.wait();

          expect(await registrar.resolver()).to.equal(newResolverAddr);
        });
      });
    });
  }
});


### File: /home/errick/core/packages/contracts/test/framework/dao/dao-registry.ts ###
import {
  DAO,
  DAORegistry,
  DAORegistry__factory,
  ENSSubdomainRegistrar,
} from '../../../typechain';
import {DAORegistry__factory as DAORegistry_V1_0_0__factory} from '../../../typechain/@aragon/osx-v1.0.1/framework/dao/DAORegistry.sol';
import {DAORegistry__factory as DAORegistry_V1_3_0__factory} from '../../../typechain/@aragon/osx-v1.3.0/framework/dao/DAORegistry.sol';
import {ensDomainHash, ensLabelHash} from '../../../utils/ens';
import {deployNewDAO} from '../../test-utils/dao';
import {deployENSSubdomainRegistrar} from '../../test-utils/ens';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {
  deployAndUpgradeFromToCheck,
  deployAndUpgradeSelfCheck,
} from '../../test-utils/uups-upgradeable';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {
  DAO_REGISTRY_PERMISSIONS,
  ENS_REGISTRAR_PERMISSIONS,
  getProtocolVersion,
} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {ContractFactory} from 'ethers';
import hre, {artifacts, ethers} from 'hardhat';

const EVENTS = {
  DAORegistered: 'DAORegistered',
};

describe('DAORegistry', function () {
  let signers: SignerWithAddress[];
  let daoRegistry: DAORegistry;
  let managingDao: DAO;
  let ownerAddress: string;
  let targetDao: DAO;
  let ensSubdomainRegistrar: ENSSubdomainRegistrar;

  const topLevelDomain = 'dao.eth';
  const daoSubdomain = 'my-cool-org';
  const daoSubdomainEnsLabelhash = ensLabelHash(daoSubdomain);
  const daoDomainHash = ensDomainHash(daoSubdomain + '.' + topLevelDomain);

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();
  });

  beforeEach(async function () {
    // Managing DAO
    managingDao = await deployNewDAO(signers[0]);

    // ENS
    ensSubdomainRegistrar = await deployENSSubdomainRegistrar(
      signers[0],
      managingDao,
      topLevelDomain
    );

    // Target DAO to be used as an example DAO to be registered
    targetDao = await deployNewDAO(signers[0]);

    // DAO Registry
    daoRegistry = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO_REGISTRY, {
      withProxy: true,
    });

    await daoRegistry.initialize(
      managingDao.address,
      ensSubdomainRegistrar.address
    );

    // Grant the `REGISTER_DAO_PERMISSION_ID` permission in the DAO registry to `signers[0]`
    await managingDao.grant(
      daoRegistry.address,
      ownerAddress,
      DAO_REGISTRY_PERMISSIONS.REGISTER_DAO_PERMISSION_ID
    );

    // Grant the `REGISTER_ENS_SUBDOMAIN_PERMISSION_ID` permission on the ENS subdomain registrar to the DAO registry contract
    await managingDao.grant(
      ensSubdomainRegistrar.address,
      daoRegistry.address,
      ENS_REGISTRAR_PERMISSIONS.REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );
  });

  it('succeeds even if the dao subdomain is empty', async function () {
    await expect(daoRegistry.register(targetDao.address, ownerAddress, '')).to
      .not.be.reverted;
  });

  it('successfully sets subdomainregistrar', async () => {
    expect(await daoRegistry.subdomainRegistrar()).to.equal(
      ensSubdomainRegistrar.address
    );
  });

  it('Should register a new DAO successfully', async function () {
    await expect(
      daoRegistry.register(targetDao.address, ownerAddress, daoSubdomain)
    )
      .to.emit(daoRegistry, EVENTS.DAORegistered)
      .withArgs(targetDao.address, ownerAddress, daoSubdomain);

    expect(await daoRegistry.entries(targetDao.address)).to.equal(true);
  });

  it('fails to register if the sender lacks the required role', async () => {
    // Register a DAO successfully
    await daoRegistry.register(targetDao.address, ownerAddress, daoSubdomain);

    // Revoke the permission
    await managingDao.revoke(
      daoRegistry.address,
      ownerAddress,
      DAO_REGISTRY_PERMISSIONS.REGISTER_DAO_PERMISSION_ID
    );

    const newTargetDao = await deployNewDAO(signers[0]);

    await expect(
      daoRegistry.register(newTargetDao.address, ownerAddress, daoSubdomain)
    )
      .to.be.revertedWithCustomError(daoRegistry, 'DaoUnauthorized')
      .withArgs(
        managingDao.address,
        daoRegistry.address,
        ownerAddress,
        DAO_REGISTRY_PERMISSIONS.REGISTER_DAO_PERMISSION_ID
      );
  });

  it('fails to register if DAO already exists', async function () {
    await daoRegistry.register(
      targetDao.address,
      ownerAddress,
      daoSubdomainEnsLabelhash
    );

    await expect(
      daoRegistry.register(targetDao.address, ownerAddress, daoSubdomain)
    )
      .to.be.revertedWithCustomError(daoRegistry, 'ContractAlreadyRegistered')
      .withArgs(targetDao.address);
  });

  it('fails to register a DAO with the same name twice', async function () {
    // Register the DAO name under the top level domain
    await daoRegistry.register(targetDao.address, ownerAddress, daoSubdomain);

    const newTargetDao = await deployNewDAO(signers[0]);
    const otherOwnerAddress = await (await ethers.getSigners())[1].getAddress();

    // Try to register the DAO name under the top level domain a second time
    await expect(
      daoRegistry.register(
        newTargetDao.address,
        otherOwnerAddress,
        daoSubdomain
      )
    )
      .to.be.revertedWithCustomError(ensSubdomainRegistrar, 'AlreadyRegistered')
      .withArgs(daoDomainHash, ensSubdomainRegistrar.address);
  });

  it('Should revert if ens is not supported, but subdomain is still non empty', async function () {
    const daoRegistry = await hre.wrapper.deploy(
      ARTIFACT_SOURCES.DAO_REGISTRY,
      {
        withProxy: true,
      }
    );

    await daoRegistry.initialize(
      managingDao.address,
      ethers.constants.AddressZero
    );

    await managingDao.grant(
      daoRegistry.address,
      ownerAddress,
      DAO_REGISTRY_PERMISSIONS.REGISTER_DAO_PERMISSION_ID
    );

    await expect(
      daoRegistry.register(targetDao.address, ownerAddress, 'some')
    ).to.be.revertedWithCustomError(daoRegistry, 'ENSNotSupported');
  });

  // without mocking we have to repeat the tests here to make sure the validation is correct
  describe('subdomain validation', () => {
    it('should validate the passed subdomain correctly (< 32 bytes long subdomain)', async () => {
      const baseSubdomain = 'this-is-my-super-valid-subdomain';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        const newTargetDao = await deployNewDAO(signers[0]);

        // replace the 10th char in the baseSubdomain
        const subdomainName =
          baseSubdomain.substring(0, 10) +
          String.fromCharCode(i) +
          baseSubdomain.substring(10 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          await expect(
            daoRegistry.register(
              newTargetDao.address,
              ownerAddress,
              subdomainName
            )
          )
            .to.emit(daoRegistry, EVENTS.DAORegistered)
            .withArgs(newTargetDao.address, ownerAddress, subdomainName);
          continue;
        }

        await expect(
          daoRegistry.register(
            newTargetDao.address,
            ownerAddress,
            subdomainName
          )
        )
          .to.be.revertedWithCustomError(daoRegistry, 'InvalidDaoSubdomain')
          .withArgs(subdomainName);
      }
    }).timeout(120000);

    it('should validate the passed subdomain correctly (> 32 bytes long subdomain)', async () => {
      const baseSubdomain =
        'this-is-my-super-looooooooooooooooooooooooooong-valid-subdomain';

      // loop through the ascii table
      for (let i = 0; i < 127; i++) {
        const newTargetDao = await deployNewDAO(signers[0]);

        // replace the 40th char in the baseSubdomain
        const subdomainName =
          baseSubdomain.substring(0, 40) +
          String.fromCharCode(i) +
          baseSubdomain.substring(40 + 1);

        // test success if it is a valid char [0-9a-z\-]
        if ((i > 47 && i < 58) || (i > 96 && i < 123) || i === 45) {
          await expect(
            daoRegistry.register(
              newTargetDao.address,
              ownerAddress,
              subdomainName
            )
          )
            .to.emit(daoRegistry, EVENTS.DAORegistered)
            .withArgs(newTargetDao.address, ownerAddress, subdomainName);
          continue;
        }

        await expect(
          daoRegistry.register(
            newTargetDao.address,
            ownerAddress,
            subdomainName
          )
        )
          .to.be.revertedWithCustomError(daoRegistry, 'InvalidDaoSubdomain')
          .withArgs(subdomainName);
      }
    }).timeout(120000);
  });

  describe('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await daoRegistry.protocolVersion()).to.deep.equal(
        osxContractsVersion()
      );
    });
  });

  describe('Upgrades', () => {
    let legacyContractFactory: ContractFactory;
    let currentContractFactory: ContractFactory;
    let initArgs: any;

    before(() => {
      currentContractFactory = new DAORegistry__factory(signers[0]);
    });

    beforeEach(() => {
      initArgs = {
        dao: managingDao.address,
        ensSubdomainRegistrar: ensSubdomainRegistrar.address,
      };
    });

    it('upgrades to a new implementation', async () => {
      await deployAndUpgradeSelfCheck(
        0,
        1,
        {
          initArgs: initArgs,
          initializer: 'initialize',
        },
        ARTIFACT_SOURCES.DAO_REGISTRY,
        ARTIFACT_SOURCES.DAO_REGISTRY,
        DAO_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
        managingDao
      );
    });

    it('upgrades from v1.0.0', async () => {
      legacyContractFactory = new DAORegistry_V1_0_0__factory(signers[0]);

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.DAO_REGISTRY_V1_0_0,
          ARTIFACT_SOURCES.DAO_REGISTRY,
          DAO_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          managingDao
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });

    it('from v1.3.0', async () => {
      legacyContractFactory = new DAORegistry_V1_3_0__factory(signers[0]);

      const {fromImplementation, toImplementation} =
        await deployAndUpgradeFromToCheck(
          0,
          1,
          {
            initArgs: initArgs,
            initializer: 'initialize',
          },
          ARTIFACT_SOURCES.DAO_REGISTRY_V1_3_0,
          ARTIFACT_SOURCES.DAO_REGISTRY,
          DAO_REGISTRY_PERMISSIONS.UPGRADE_REGISTRY_PERMISSION_ID,
          managingDao
        );
      expect(toImplementation).to.not.equal(fromImplementation);

      const fromProtocolVersion = await getProtocolVersion(
        legacyContractFactory.attach(fromImplementation)
      );
      const toProtocolVersion = await getProtocolVersion(
        currentContractFactory.attach(toImplementation)
      );

      expect(fromProtocolVersion).to.not.deep.equal(toProtocolVersion);
      expect(fromProtocolVersion).to.deep.equal([1, 0, 0]);
      expect(toProtocolVersion).to.deep.equal(osxContractsVersion());
    });
  });
});


### File: /home/errick/core/packages/contracts/test/framework/dao/dao-factory.ts ###
import {
  DAORegistry,
  PluginSetupProcessor,
  PluginUUPSUpgradeableSetupV1Mock,
  PluginRepoRegistry,
  DAOFactory,
  DAOFactory__factory,
  PluginRepoFactory,
  PluginSetupProcessor__factory,
  DAO__factory,
  PluginRepo,
  PluginUUPSUpgradeableV1Mock__factory,
  PluginUUPSUpgradeableSetupV2Mock__factory,
  PluginUUPSUpgradeableSetupV1Mock__factory,
  DAORegistry__factory,
  PluginRepo__factory,
  IProtocolVersion__factory,
  IERC165__factory,
  PluginRepoRegistry__factory,
} from '../../../typechain';
import {DAORegisteredEvent} from '../../../typechain/DAORegistry';
import {PluginRepoRegisteredEvent} from '../../../typechain/PluginRepoRegistry';
import {InstallationPreparedEvent} from '../../../typechain/PluginSetupProcessor';
import {daoExampleURI, deployNewDAO} from '../../test-utils/dao';
import {deployENSSubdomainRegistrar} from '../../test-utils/ens';
import {deployPluginSetupProcessor} from '../../test-utils/plugin-setup-processor';
import {osxContractsVersion} from '../../test-utils/protocol-version';
import {createPrepareInstallationParams} from '../../test-utils/psp/create-params';
import {getAppliedSetupId} from '../../test-utils/psp/hash-helpers';
import {PluginRepoPointer} from '../../test-utils/psp/types';
import {
  deployPluginRepoFactory,
  deployPluginRepoRegistry,
} from '../../test-utils/repo';
import {ARTIFACT_SOURCES} from '../../test-utils/wrapper';
import {
  findEventTopicLog,
  DAO_PERMISSIONS,
  DAO_REGISTRY_PERMISSIONS,
  PLUGIN_REGISTRY_PERMISSIONS,
  PLUGIN_SETUP_PROCESSOR_PERMISSIONS,
  getInterfaceId,
} from '@aragon/osx-commons-sdk';
import {PluginUUPSUpgradeableV2Mock__factory} from '@aragon/osx-ethers-v1.2.0';
import {anyValue} from '@nomicfoundation/hardhat-chai-matchers/withArgs';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

const EVENTS = {
  PluginRepoRegistered: 'PluginRepoRegistered',
  DAORegistered: 'DAORegistered',
  InstallationPrepared: 'InstallationPrepared',
  InstallationApplied: 'InstallationApplied',
  UpdateApplied: 'UpdateApplied',
  UninstallationApplied: 'UninstallationApplied',
  MetadataSet: 'MetadataSet',
  TrustedForwarderSet: 'TrustedForwarderSet',
  NewURI: 'NewURI',
  Revoked: 'Revoked',
  Granted: 'Granted',
};

const ALLOW_FLAG = '0x0000000000000000000000000000000000000002';
const daoDummySubdomain = 'dao1';
const registrarManagedDomain = 'dao.eth';
const daoDummyMetadata = '0x0000';
const EMPTY_DATA = '0x';
const AddressZero = ethers.constants.AddressZero;

async function extractInfoFromCreateDaoTx(tx: any): Promise<{
  dao: any;
  creator: any;
  subdomain: any;
  plugin: any;
  helpers: any;
  permissions: any;
}> {
  const daoRegisteredEvent = findEventTopicLog<DAORegisteredEvent>(
    await tx.wait(),
    DAORegistry__factory.createInterface(),
    EVENTS.DAORegistered
  );

  const installationPreparedEvent =
    findEventTopicLog<InstallationPreparedEvent>(
      await tx.wait(),
      PluginSetupProcessor__factory.createInterface(),
      EVENTS.InstallationPrepared
    );

  return {
    dao: daoRegisteredEvent.args.dao,
    creator: daoRegisteredEvent.args.creator,
    subdomain: daoRegisteredEvent.args.subdomain,
    plugin: installationPreparedEvent.args.plugin,
    helpers: installationPreparedEvent.args.preparedSetupData.helpers,
    permissions: installationPreparedEvent.args.preparedSetupData.permissions,
  };
}

export async function getAnticipatedAddress(from: string, offset: number = 0) {
  const nonce = await hre.wrapper.getNonce(from);
  const anticipatedAddress = hre.wrapper.getCreateAddress(from, nonce + offset);

  return anticipatedAddress;
}

async function validateSetDaoPermissions(
  dao: string,
  daoFactory: DAOFactory,
  signer: SignerWithAddress,
  tx: any
): Promise<void> {
  const factory = new DAO__factory(signer);
  const daoContract = factory.attach(dao);

  await expect(tx)
    .to.emit(daoContract, EVENTS.Granted)
    .withArgs(
      DAO_PERMISSIONS.ROOT_PERMISSION_ID,
      daoFactory.address,
      dao,
      dao,
      ALLOW_FLAG
    )
    .to.emit(daoContract, EVENTS.Granted)
    .withArgs(
      DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID,
      daoFactory.address,
      dao,
      dao,
      ALLOW_FLAG
    )
    .to.emit(daoContract, EVENTS.Granted)
    .withArgs(
      DAO_PERMISSIONS.SET_TRUSTED_FORWARDER_PERMISSION_ID,
      daoFactory.address,
      dao,
      dao,
      ALLOW_FLAG
    )
    .to.emit(daoContract, EVENTS.Granted)
    .withArgs(
      DAO_PERMISSIONS.SET_METADATA_PERMISSION_ID,
      daoFactory.address,
      dao,
      dao,
      ALLOW_FLAG
    )
    .to.emit(daoContract, EVENTS.Granted)
    .withArgs(
      DAO_PERMISSIONS.REGISTER_STANDARD_CALLBACK_PERMISSION_ID,
      daoFactory.address,
      dao,
      dao,
      ALLOW_FLAG
    );
}

describe('DAOFactory: ', function () {
  let daoFactory: DAOFactory;
  let managingDao: any;

  let psp: PluginSetupProcessor;
  let pluginRepoRegistry: PluginRepoRegistry;

  let pluginSetupV1Mock: PluginUUPSUpgradeableSetupV1Mock;
  let pluginRepoMock: PluginRepo;
  let pluginSetupMockRepoAddress: any;

  let pluginRepoFactory: PluginRepoFactory;
  let daoRegistry: DAORegistry;
  let daoSettings: any;
  let pluginInstallationData: any;

  let signers: SignerWithAddress[];
  let ownerAddress: string;

  before(async () => {
    signers = await ethers.getSigners();
    ownerAddress = await signers[0].getAddress();
  });

  beforeEach(async function () {
    // Managing DAO
    managingDao = await deployNewDAO(signers[0]);

    // ENS subdomain Registry
    const ensSubdomainRegistrar = await deployENSSubdomainRegistrar(
      signers[0],
      managingDao,
      registrarManagedDomain
    );

    // DAO Registry
    // DAO Registry
    daoRegistry = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO_REGISTRY, {
      withProxy: true,
    });

    await daoRegistry.initialize(
      managingDao.address,
      ensSubdomainRegistrar.address
    );

    // Plugin Repo Registry
    pluginRepoRegistry = await deployPluginRepoRegistry(
      managingDao,
      ensSubdomainRegistrar,
      signers[0]
    );

    // Plugin Setup Processor
    psp = await deployPluginSetupProcessor(pluginRepoRegistry);

    // Plugin Repo Factory
    pluginRepoFactory = await deployPluginRepoFactory(
      signers,
      pluginRepoRegistry
    );

    // Deploy DAO Factory
    daoFactory = await hre.wrapper.deploy('DAOFactory', {
      args: [daoRegistry.address, psp.address],
    });

    // Grant the `REGISTER_DAO_PERMISSION` permission to the `daoFactory`
    await managingDao.grant(
      daoRegistry.address,
      daoFactory.address,
      DAO_REGISTRY_PERMISSIONS.REGISTER_DAO_PERMISSION_ID
    );

    // Grant the `REGISTER_ENS_SUBDOMAIN_PERMISSION` permission on the ENS subdomain registrar to the DAO registry contract
    await managingDao.grant(
      ensSubdomainRegistrar.address,
      daoRegistry.address,
      DAO_REGISTRY_PERMISSIONS.ENS_REGISTRAR_PERMISSIONS
        .REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );

    // Grant `PLUGIN_REGISTER_PERMISSION` to `pluginRepoFactory`.
    await managingDao.grant(
      pluginRepoRegistry.address,
      pluginRepoFactory.address,
      PLUGIN_REGISTRY_PERMISSIONS.REGISTER_PLUGIN_REPO_PERMISSION_ID
    );

    // Grant `REGISTER_ENS_SUBDOMAIN_PERMISSION` to `PluginRepoFactory`.
    await managingDao.grant(
      ensSubdomainRegistrar.address,
      pluginRepoRegistry.address,
      PLUGIN_REGISTRY_PERMISSIONS.ENS_REGISTRAR_PERMISSIONS
        .REGISTER_ENS_SUBDOMAIN_PERMISSION_ID
    );

    // Create and register a plugin on the `PluginRepoRegistry`.
    // PluginSetupV1

    const implV1 = await hre.wrapper.deploy('PluginUUPSUpgradeableV1Mock');
    pluginSetupV1Mock = await hre.wrapper.deploy(
      'PluginUUPSUpgradeableSetupV1Mock',
      {args: [implV1.address]}
    );

    const tx = await pluginRepoFactory.createPluginRepoWithFirstVersion(
      'plugin-uupsupgradeable-setup-v1-mock',
      pluginSetupV1Mock.address,
      ownerAddress,
      '0x00',
      '0x00'
    );
    const event = findEventTopicLog<PluginRepoRegisteredEvent>(
      await tx.wait(),
      PluginRepoRegistry__factory.createInterface(),
      EVENTS.PluginRepoRegistered
    );
    pluginSetupMockRepoAddress = event.args.pluginRepo;

    pluginRepoMock = PluginRepo__factory.connect(
      pluginSetupMockRepoAddress,
      signers[0]
    );

    // default params
    daoSettings = {
      trustedForwarder: AddressZero,
      subdomain: daoDummySubdomain,
      metadata: daoDummyMetadata,
      daoURI: daoExampleURI,
    };

    const pluginRepoPointer: PluginRepoPointer = [
      pluginSetupMockRepoAddress,
      1,
      1,
    ];
    pluginInstallationData = createPrepareInstallationParams(
      pluginRepoPointer,
      EMPTY_DATA
    );
  });

  context('ERC-165', async () => {
    it('does not support the empty interface', async () => {
      expect(await daoFactory.supportsInterface('0xffffffff')).to.be.false;
    });

    it('supports the `IERC165` interface', async () => {
      const iface = IERC165__factory.createInterface();
      expect(await daoFactory.supportsInterface(getInterfaceId(iface))).to.be
        .true;
    });

    it('supports the `IProtocolVersion` interface', async () => {
      const iface = IProtocolVersion__factory.createInterface();
      expect(await daoFactory.supportsInterface(getInterfaceId(iface))).to.be
        .true;
    });
  });

  context('Protocol version', async () => {
    it('returns the current protocol version', async () => {
      expect(await daoFactory.protocolVersion()).to.deep.equal(
        osxContractsVersion()
      );
    });
  });

  context('createDao with plugins', async () => {
    it('creates a dao and initializes with correct args', async () => {
      const dao = await getAnticipatedAddress(daoFactory.address);

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(dao);

      expect(await daoFactory.createDao(daoSettings, [pluginInstallationData]))
        .to.emit(daoContract, EVENTS.MetadataSet)
        .withArgs(daoSettings.metadata)
        .to.emit(daoContract, EVENTS.TrustedForwarderSet)
        .withArgs(daoSettings.trustedForwarder)
        .to.emit(daoContract, EVENTS.NewURI)
        .withArgs(daoSettings.daoURI);
    });

    it('creates a dao with a plugin and emits correct events', async () => {
      const expectedDao = await getAnticipatedAddress(daoFactory.address);
      const expectedPlugin = await getAnticipatedAddress(
        pluginSetupV1Mock.address
      );

      const tx = await daoFactory.createDao(daoSettings, [
        pluginInstallationData,
      ]);

      const {dao, plugin, helpers, permissions} =
        await extractInfoFromCreateDaoTx(tx);

      const pluginRepoPointer: PluginRepoPointer = [
        pluginSetupMockRepoAddress,
        1,
        1,
      ];

      expect(dao).to.equal(expectedDao);
      expect(plugin).to.equal(expectedPlugin);

      await expect(tx)
        .to.emit(daoRegistry, EVENTS.DAORegistered)
        .withArgs(dao, ownerAddress, daoSettings.subdomain)
        .to.emit(psp, EVENTS.InstallationPrepared)
        .withArgs(
          daoFactory.address,
          dao,
          anyValue,
          pluginSetupMockRepoAddress,
          (val: any) => expect(val).to.deep.equal([1, 1]),
          EMPTY_DATA,
          expectedPlugin,
          (val: any) => expect(val).to.deep.equal([helpers, permissions])
        )
        .to.emit(psp, EVENTS.InstallationApplied)
        .withArgs(
          dao,
          expectedPlugin,
          anyValue,
          getAppliedSetupId(pluginRepoPointer, helpers)
        );
    });

    it('creates a dao with a plugin and sets plugin permissions on dao correctly', async () => {
      const tx = await daoFactory.createDao(daoSettings, [
        pluginInstallationData,
      ]);
      const {dao, permissions} = await extractInfoFromCreateDaoTx(tx);

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(dao);

      for (let i = 0; i < permissions.length; i++) {
        const permission = permissions[i];
        expect(
          await daoContract.hasPermission(
            permission.where,
            permission.who,
            permission.permissionId,
            EMPTY_DATA
          )
        ).to.equal(true);
      }
    });

    it('creates a dao and sets its own permissions correctly on itself', async () => {
      const tx = await daoFactory.createDao(daoSettings, [
        pluginInstallationData,
      ]);
      const {dao} = await extractInfoFromCreateDaoTx(tx);

      await validateSetDaoPermissions(dao, daoFactory, signers[0], tx);
    });

    it('revokes all temporarly granted permissions', async () => {
      const tx = await daoFactory.createDao(daoSettings, [
        pluginInstallationData,
      ]);
      const {dao} = await extractInfoFromCreateDaoTx(tx);

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(dao);

      // Check that events were emitted.
      await expect(tx)
        .to.emit(daoContract, EVENTS.Revoked)
        .withArgs(
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          daoFactory.address,
          dao,
          psp.address
        );

      await expect(tx)
        .to.emit(daoContract, EVENTS.Revoked)
        .withArgs(
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID,
          daoFactory.address,
          psp.address,
          daoFactory.address
        );

      await expect(tx)
        .to.emit(daoContract, EVENTS.Revoked)
        .withArgs(
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          daoFactory.address,
          dao,
          daoFactory.address
        );

      // Direct check to ensure since these permissions are extra dangerous to stay on.
      expect(
        await daoContract.hasPermission(
          dao,
          daoFactory.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          '0x'
        )
      ).to.be.false;
      expect(
        await daoContract.hasPermission(
          dao,
          psp.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          '0x'
        )
      ).to.be.false;

      expect(
        await daoContract.hasPermission(
          psp.address,
          daoFactory.address,
          PLUGIN_SETUP_PROCESSOR_PERMISSIONS.APPLY_INSTALLATION_PERMISSION_ID,
          '0x'
        )
      ).to.be.false;
    });

    it('creates a dao with multiple plugins installed', async () => {
      // add new plugin setup to the repo ! it will become build 2.
      await pluginRepoMock.createVersion(
        1,
        // We can use the same plugin setup as each time,
        // it returns the different plugin address, hence
        // wil generate unique/different plugin installation id.
        pluginSetupV1Mock.address,
        '0x11',
        '0x11'
      );

      const plugin1 = {...pluginInstallationData};

      const plugin2 = {...pluginInstallationData};
      plugin2.pluginSetupRef.versionTag = {
        release: 1,
        build: 2,
      };

      const plugins = [plugin1, plugin2];
      const tx = await daoFactory.createDao(daoSettings, plugins);

      // Count how often the event was emitted by inspecting the logs
      const receipt = await tx.wait();
      const topic =
        PluginSetupProcessor__factory.createInterface().getEventTopic(
          EVENTS.InstallationApplied
        );

      let installationAppliedEventCount = 0;
      receipt.logs.forEach(log => {
        if (log.topics[0] === topic) installationAppliedEventCount++;
      });

      expect(installationAppliedEventCount).to.equal(2);
    });

    it('correctly returns created DAO and installed plugins', async () => {
      // Add a new plugin setup to the repository, resulting in build 2.
      await pluginRepoMock.createVersion(
        1,
        pluginSetupV1Mock.address,
        '0x11',
        '0x11'
      );

      const expectedDao = await getAnticipatedAddress(daoFactory.address);
      const expectedPlugins = [
        await getAnticipatedAddress(pluginSetupV1Mock.address),
        await getAnticipatedAddress(pluginSetupV1Mock.address, 1),
      ];

      // Setup plugins for installation
      const plugin1 = {...pluginInstallationData};
      const plugin2 = {...pluginInstallationData};
      plugin2.pluginSetupRef.versionTag = {
        release: 1,
        build: 2,
      };
      const plugins = [plugin1, plugin2];

      // Execute the function
      const [createdDao, installedPlugins] =
        await daoFactory.callStatic.createDao(daoSettings, plugins);

      // Validate the DAO creation
      expect(createdDao).to.equal(expectedDao);

      // Validate the plugins installation
      expect(installedPlugins.length).to.equal(2);
      installedPlugins.forEach((installedPlugin, index) => {
        expect(installedPlugin.plugin).to.equal(expectedPlugins[index]);
        expect(installedPlugin.preparedSetupData.length).to.equal(2);
      });
    });
  });

  context('createDao without plugins', async () => {
    it('creates a dao and initializes with correct args', async function () {
      const tx = await daoFactory.createDao(daoSettings, []);

      const dao = findEventTopicLog<DAORegisteredEvent>(
        await tx.wait(),
        DAORegistry__factory.createInterface(),
        EVENTS.DAORegistered
      ).args.dao;

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(dao);

      expect(tx)
        .to.emit(daoContract, EVENTS.MetadataSet)
        .withArgs(daoSettings.metadata)
        .to.emit(daoContract, EVENTS.TrustedForwarderSet)
        .withArgs(daoSettings.trustedForwarder)
        .to.emit(daoContract, EVENTS.NewURI)
        .withArgs(daoSettings.daoURI);
    });

    it('creates a dao and sets its own permissions correctly on itself', async () => {
      const tx = await daoFactory.createDao(daoSettings, []);
      const dao = findEventTopicLog<DAORegisteredEvent>(
        await tx.wait(),
        DAORegistry__factory.createInterface(),
        EVENTS.DAORegistered
      ).args.dao;

      await validateSetDaoPermissions(dao, daoFactory, signers[0], tx);
    });

    it('revokes ROOT_PERMISSION that is granted with DAO initialization', async () => {
      const tx = await daoFactory.createDao(daoSettings, []);
      const dao = findEventTopicLog<DAORegisteredEvent>(
        await tx.wait(),
        DAORegistry__factory.createInterface(),
        EVENTS.DAORegistered
      ).args.dao;

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(dao);

      // Check that events were emitted.
      await expect(tx)
        .to.emit(daoContract, EVENTS.Revoked)
        .withArgs(
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          daoFactory.address,
          dao,
          daoFactory.address
        );

      // Direct check to ensure since these permissions are extra dangerous to stay on.
      expect(
        await daoContract.hasPermission(
          dao,
          daoFactory.address,
          DAO_PERMISSIONS.ROOT_PERMISSION_ID,
          '0x'
        )
      ).to.be.false;
    });

    it('should grant EXECUTE_PERMISSION to the DAO creator', async function () {
      const tx = await daoFactory.createDao(daoSettings, []);

      const createdDao = findEventTopicLog<DAORegisteredEvent>(
        await tx.wait(),
        DAORegistry__factory.createInterface(),
        EVENTS.DAORegistered
      ).args.dao;

      const factory = new DAO__factory(signers[0]);
      const daoContract = factory.attach(createdDao);

      expect(
        await daoContract.hasPermission(
          createdDao,
          ownerAddress,
          DAO_PERMISSIONS.EXECUTE_PERMISSION_ID,
          '0x'
        )
      ).to.equal(true);
    });

    it('correctly returns created DAO and empty installed plugins', async () => {
      const expectedDao = await getAnticipatedAddress(daoFactory.address);

      // Execute the function
      const [createdDao, installedPlugins] =
        await daoFactory.callStatic.createDao(daoSettings, []);

      // Validate the DAO creation
      expect(createdDao).to.equal(expectedDao);

      // Validate the plugins installation
      expect(installedPlugins.length).to.equal(0);
    });
  });
});


### File: /home/errick/core/packages/contracts/test/upgrade/dao.ts ###
import {DAO, ProtocolVersion__factory} from '../../typechain';
import {
  DAO as DAO_V1_0_0,
  DAO__factory as DAO_V1_0_0__factory,
} from '../../typechain/@aragon/osx-v1.0.1/core/dao/DAO.sol';
import {
  DAO as DAO_V1_3_0,
  DAO__factory as DAO_V1_3_0__factory,
} from '../../typechain/@aragon/osx-v1.3.0/core/dao/DAO.sol';
import {UpgradedEvent} from '../../typechain/DAO';
import {readStorage, ERC1967_IMPLEMENTATION_SLOT} from '../../utils/storage';
import {daoExampleURI, ZERO_BYTES32} from '../test-utils/dao';
import {ARTIFACT_SOURCES} from '../test-utils/wrapper';
import {
  IMPLICIT_INITIAL_PROTOCOL_VERSION,
  findEventTopicLog,
} from '@aragon/osx-commons-sdk';
import {DAO_PERMISSIONS} from '@aragon/osx-commons-sdk';
import {getInterfaceId} from '@aragon/osx-commons-sdk';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import hre, {ethers} from 'hardhat';

let signers: SignerWithAddress[];

let daoV100Proxy: DAO_V1_0_0;
let daoV100Implementation: DAO_V1_0_0;
let daoV130Implementation: DAO_V1_3_0;

const EMPTY_DATA = '0x';

const DUMMY_METADATA = ethers.utils.hexlify(
  ethers.utils.toUtf8Bytes('0x123456789')
);

const FORWARDER_1 = `0x${'1'.repeat(40)}`;
const FORWARDER_2 = `0x${'2'.repeat(40)}`;

describe('DAO Upgrade', function () {
  before(async function () {
    signers = await ethers.getSigners();

    // Deploy the v1.3.0 implementation
    daoV130Implementation = await hre.wrapper.deploy(
      ARTIFACT_SOURCES.DAO_V1_3_0
    );
  });

  context(`Re-entrancy`, function () {
    context(`v1.0.0 to v1.3.0`, function () {
      beforeEach(async function () {
        daoV100Proxy = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO_V1_0_0, {
          withProxy: true,
        });

        await daoV100Proxy.initialize(
          DUMMY_METADATA,
          signers[0].address,
          ethers.constants.AddressZero,
          daoExampleURI
        );

        // Store the v1.0.0 implementation
        daoV100Implementation = new DAO_V1_0_0__factory(signers[0]).attach(
          await readStorage(daoV100Proxy.address, ERC1967_IMPLEMENTATION_SLOT, [
            'address',
          ])
        );

        // Grant the upgrade permission
        await daoV100Proxy.grant(
          daoV100Proxy.address,
          signers[0].address,
          DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
        );
      });

      it('does not corrupt the DAO storage', async () => {
        // Upgrade and call `initializeFrom`.
        const upgradeTx = await daoV100Proxy.upgradeToAndCall(
          daoV130Implementation.address,
          daoV130Implementation.interface.encodeFunctionData('initializeFrom', [
            IMPLICIT_INITIAL_PROTOCOL_VERSION,
            EMPTY_DATA,
          ])
        );

        // Check the stored implementation.
        const implementationAfterUpgrade = await readStorage(
          daoV100Proxy.address,
          ERC1967_IMPLEMENTATION_SLOT,
          ['address']
        );
        expect(implementationAfterUpgrade).to.equal(
          daoV130Implementation.address
        );
        expect(implementationAfterUpgrade).to.not.equal(daoV100Implementation);

        // Check the emitted implementation.
        const emittedImplementation = findEventTopicLog<UpgradedEvent>(
          await upgradeTx.wait(),
          daoV130Implementation.interface,
          'Upgraded'
        ).args.implementation;
        expect(emittedImplementation).to.equal(daoV130Implementation.address);

        // Check that storage is not corrupted.
        expect(await daoV100Proxy.callStatic.daoURI()).to.equal(daoExampleURI);
      });

      it('does not corrupt permissions', async () => {
        await daoV100Proxy.grant(
          daoV100Proxy.address,
          signers[0].address,
          ethers.utils.id('EXECUTE_PERMISSION')
        );

        // Check that permissions are granted before the upgrade
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('EXECUTE_PERMISSION'),
            EMPTY_DATA
          )
        ).to.be.true;
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('ROOT_PERMISSION'),
            EMPTY_DATA
          )
        ).to.be.true;

        // Check that a arbitrary permission is not granted.
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('NOT_GRANTED'),
            EMPTY_DATA
          )
        ).to.be.false;

        // Upgrade and call `initializeFrom`.
        await daoV100Proxy.upgradeToAndCall(
          daoV130Implementation.address,
          daoV130Implementation.interface.encodeFunctionData('initializeFrom', [
            IMPLICIT_INITIAL_PROTOCOL_VERSION,
            EMPTY_DATA,
          ])
        );

        // Check the stored implementation.
        const implementationAfterUpgrade = await readStorage(
          daoV100Proxy.address,
          ERC1967_IMPLEMENTATION_SLOT,
          ['address']
        );
        expect(implementationAfterUpgrade).to.equal(
          daoV130Implementation.address
        );
        expect(implementationAfterUpgrade).to.not.equal(daoV100Implementation);

        // Check that the permissions are still granted.
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('EXECUTE_PERMISSION'),
            EMPTY_DATA
          )
        ).to.be.true;
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('ROOT_PERMISSION'),
            EMPTY_DATA
          )
        ).to.be.true;

        // Check that a the arbitrary permission is still not granted.
        expect(
          await daoV100Proxy.hasPermission(
            daoV100Proxy.address,
            signers[0].address,
            ethers.utils.id('NOT_GRANTED'),
            EMPTY_DATA
          )
        ).to.be.false;
      });

      it('executes actions after the upgrade', async () => {
        await daoV100Proxy.grant(
          daoV100Proxy.address,
          signers[0].address,
          ethers.utils.id('EXECUTE_PERMISSION')
        );

        // We use the `setTrustedForwarder` to test execution and must give permission to the DAO (executor) to call it.
        await daoV100Proxy.grant(
          daoV100Proxy.address,
          daoV100Proxy.address,
          ethers.utils.id('SET_TRUSTED_FORWARDER_PERMISSION')
        );

        // Create an action to set forwarder1
        const forwarderChangeAction1 = {
          to: daoV100Proxy.address,
          data: daoV100Proxy.interface.encodeFunctionData(
            'setTrustedForwarder',
            [FORWARDER_1]
          ),
          value: 0,
        };

        // Execute and check in the event that the forwarder1 has been set.
        await expect(
          daoV100Proxy.execute(ZERO_BYTES32, [forwarderChangeAction1], 0)
        )
          .to.emit(daoV100Proxy, 'TrustedForwarderSet')
          .withArgs(FORWARDER_1);

        // Check that the storage variable now forwarder 1.
        expect(await daoV100Proxy.getTrustedForwarder()).to.equal(FORWARDER_1);

        // Upgrade and call `initializeFrom`.
        await daoV100Proxy.upgradeToAndCall(
          daoV130Implementation.address,
          daoV130Implementation.interface.encodeFunctionData('initializeFrom', [
            IMPLICIT_INITIAL_PROTOCOL_VERSION,
            EMPTY_DATA,
          ])
        );

        // Check that the stored implementation has changed.
        const implementationAfterUpgrade = await readStorage(
          daoV100Proxy.address,
          ERC1967_IMPLEMENTATION_SLOT,
          ['address']
        );
        expect(implementationAfterUpgrade).to.equal(
          daoV130Implementation.address
        );
        expect(implementationAfterUpgrade).to.not.equal(daoV100Implementation);

        // Check that the old forwarder is still unchanged.
        expect(await daoV100Proxy.getTrustedForwarder()).to.equal(FORWARDER_1);

        // Create an action to change the forwarder to a new address.
        const testAction = {
          to: daoV100Proxy.address,
          data: daoV100Proxy.interface.encodeFunctionData(
            'setTrustedForwarder',
            [FORWARDER_2]
          ),
          value: 0,
        };

        // Execute and check in the event that the forwarder1 has been set.
        await expect(daoV100Proxy.execute(ZERO_BYTES32, [testAction], 0))
          .to.emit(daoV100Proxy, 'TrustedForwarderSet')
          .withArgs(FORWARDER_2);

        // Check that the storage variable is now forwarder 2.
        expect(await daoV100Proxy.getTrustedForwarder()).to.equal(FORWARDER_2);
      });
    });
  });

  context(`Protocol Version`, function () {
    beforeEach(async function () {
      // prepare v1.0.0
      daoV100Proxy = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO_V1_0_0, {
        withProxy: true,
      });

      await daoV100Proxy.initialize(
        DUMMY_METADATA,
        signers[0].address,
        ethers.constants.AddressZero,
        daoExampleURI
      );

      // Grant the upgrade permission
      await daoV100Proxy.grant(
        daoV100Proxy.address,
        signers[0].address,
        DAO_PERMISSIONS.UPGRADE_DAO_PERMISSION_ID
      );
    });

    it('fails to call protocolVersion on versions prior to v1.3.0 and succeeds from v1.3.0 onwards', async () => {
      // deploy the different versions
      const daoCurrentProxy = await hre.wrapper.deploy(
        ARTIFACT_SOURCES.DAO_V1_3_0,
        {
          withProxy: true,
        }
      );
      await daoCurrentProxy.initialize(
        DUMMY_METADATA,
        signers[0].address,
        ethers.constants.AddressZero,
        daoExampleURI
      );

      const protocolVersionSelector = new ethers.utils.Interface(
        daoCurrentProxy.interface.fragments
      ).getSighash('protocolVersion');

      // for DAO prior to v1.3.0
      const daoV100 = ProtocolVersion__factory.connect(
        daoV100Proxy.address,
        signers[0]
      );

      await expect(daoV100.protocolVersion())
        .to.be.revertedWithCustomError(daoV100Proxy, 'UnkownCallback')
        .withArgs(protocolVersionSelector, '0x00000000');

      // for DAO v1.3.0 onward
      const daoV130 = ProtocolVersion__factory.connect(
        daoCurrentProxy.address,
        signers[0]
      );

      await expect(daoV130.protocolVersion()).to.not.be.reverted;
    });

    context('v1.0.0 to v1.3.0', function () {
      it('supports new protocol version interface after upgrade', async () => {
        // check that the old version do not support protocol version interface
        const protocolVersionInterface =
          ProtocolVersion__factory.createInterface();

        expect(
          await daoV100Proxy.supportsInterface(
            getInterfaceId(protocolVersionInterface)
          )
        ).to.be.eq(false);

        // Upgrade and call `initializeFrom`.
        await daoV100Proxy.upgradeToAndCall(
          daoV130Implementation.address,
          daoV130Implementation.interface.encodeFunctionData('initializeFrom', [
            IMPLICIT_INITIAL_PROTOCOL_VERSION,
            EMPTY_DATA,
          ])
        );

        // check the interface is registered.
        expect(
          await daoV100Proxy.supportsInterface(
            getInterfaceId(protocolVersionInterface)
          )
        ).to.be.eq(true);
      });

      it('returns the correct protocol version after upgrade', async () => {
        // Upgrade and call `initializeFrom`.
        await daoV100Proxy.upgradeToAndCall(
          daoV130Implementation.address,
          daoV130Implementation.interface.encodeFunctionData('initializeFrom', [
            IMPLICIT_INITIAL_PROTOCOL_VERSION,
            EMPTY_DATA,
          ])
        );

        const daoV130 = new DAO_V1_3_0__factory(signers[0]).attach(
          daoV100Proxy.address
        );
        expect(await daoV130.protocolVersion()).to.be.deep.eq([1, 3, 0]);
      });
    });
  });
});


### File: /home/errick/core/packages/contracts/test/test-utils/fixture.ts ###
import {getNetworkByNameOrAlias} from '@aragon/osx-commons-configs';
import hre, {network, deployments} from 'hardhat';

export interface ForkOsxVersion {
  version: string;
  activeContracts: any;
  forkBlockNumber: number;
}

export async function initializeFork(
  forkNetwork: string,
  blockNumber: number
): Promise<void> {
  const networkSettings = getNetworkByNameOrAlias(forkNetwork);

  if (networkSettings === null) {
    throw new Error(`No info found for network '${forkNetwork}'.`);
  }

  await network.provider.request({
    method: 'hardhat_reset',
    params: [
      {
        forking: {
          jsonRpcUrl: networkSettings.url,
          blockNumber: blockNumber,
        },
      },
    ],
  });
}

export async function closeFork() {
  await network.provider.request({
    method: 'hardhat_reset',
    params: [],
  });
}

export async function initializeDeploymentFixture(tag: string | string[]) {
  const fixture = deployments.createFixture(async () => {
    await deployments.fixture(tag); // ensure you start from a fresh deployments
  });

  await fixture();
}

export async function initForkForOsxVersion(
  forkNetwork: string,
  osxVersion: ForkOsxVersion
): Promise<void> {
  // Aggregate necessary information to HardhatEnvironment.
  hre.testingFork = {
    network: forkNetwork,
    osxVersion: osxVersion.version,
    activeContracts: osxVersion.activeContracts,
  };

  // Initialize a fork.
  await initializeFork(forkNetwork, osxVersion.forkBlockNumber);
}


### File: /home/errick/core/packages/contracts/test/test-utils/matcher.ts ###
import {decodeReturnData} from '@nomicfoundation/hardhat-chai-matchers/internal/reverted/utils.js';
import {buildAssert} from '@nomicfoundation/hardhat-chai-matchers/utils.js';
import {AssertionError} from 'chai';
import chai from 'chai';

/// The below code overwrites the behaviour of the `revertedWith` matcher to support how zkSync and ethers-v5
/// encode and handle errors. The functions below are lifted from the `hardhat-chai-matchers` package and modified
/// to check for deeper nesting of error.data in the error object.
/// Unfortunately, the `hardhat-chai-matchers` package does not have a way to super the `revertedWith` matcher, so
/// we have to copy the code here and modify i,t.
/// We also directly import the javascript files from the `hardhat-chai-matchers` package to avoid issues with import paths.
/// See https://github.com/ethers-io/ethers.js/discussions/4715 for full details.

chai.use(({Assertion}) => {
  supportReverted(Assertion);
  supportRevertedWith(Assertion);
  supportRevertedWithCustomError(Assertion, chai.util);
});

/**
 * Try to obtain the return data of a transaction from the given value.
 *
 * If the value is an error but it doesn't have data, we assume it's not related
 * to a reverted transaction and we re-throw it.
 */
export function getReturnDataFromError(error: any): string {
  if (!(error instanceof Error)) {
    throw new AssertionError('Expected an Error object');
  }

  // cast to any again so we don't have to cast it every time we access
  // some property that doesn't exist on Error
  error = error as any;

  // This is the changed line, we have to check for deeply nested error.data otherwise
  // ethers will re-throw our error and our tests won't work.
  // If you can find a better way to do this, please let me know.
  const errorData =
    error.data ??
    error.error?.data ??
    error.error?.error?.data ??
    error.error?.error?.error?.data;

  if (errorData === undefined) {
    throw error;
  }

  const returnData = typeof errorData === 'string' ? errorData : errorData.data;

  if (returnData === undefined || typeof returnData !== 'string') {
    throw error;
  }

  return returnData;
}

export function supportRevertedWith(Assertion: Chai.AssertionStatic) {
  console.debug('Overwriting revertedWith matcher');

  Assertion.addMethod(
    'revertedWith',
    function (this: any, expectedReason: string | RegExp) {
      // capture negated flag before async code executes; see buildAssert's jsdoc
      const negated = this.__flags.negate;

      // validate expected reason
      if (
        !(expectedReason instanceof RegExp) &&
        typeof expectedReason !== 'string'
      ) {
        throw new TypeError(
          'Expected the revert reason to be a string or a regular expression'
        );
      }

      const expectedReasonString =
        expectedReason instanceof RegExp
          ? expectedReason.source
          : expectedReason;

      const onSuccess = () => {
        const assert = buildAssert(negated, onSuccess);

        assert(
          false,
          `Expected transaction to be reverted with reason '${expectedReasonString}', but it didn't revert`
        );
      };

      const onError = (error: any) => {
        const assert = buildAssert(negated, onError);

        const returnData = getReturnDataFromError(error);
        const decodedReturnData = decodeReturnData(returnData);
        if (decodedReturnData.kind === 'Empty') {
          assert(
            false,
            `Expected transaction to be reverted with reason '${expectedReasonString}', but it reverted without a reason`
          );
        } else if (decodedReturnData.kind === 'Error') {
          const matchesExpectedReason =
            expectedReason instanceof RegExp
              ? expectedReason.test(decodedReturnData.reason)
              : decodedReturnData.reason === expectedReasonString;

          assert(
            matchesExpectedReason,
            `Expected transaction to be reverted with reason '${expectedReasonString}', but it reverted with reason '${decodedReturnData.reason}'`,
            `Expected transaction NOT to be reverted with reason '${expectedReasonString}', but it was`
          );
        } else if (decodedReturnData.kind === 'Panic') {
          assert(
            false,
            `Expected transaction to be reverted with reason '${expectedReasonString}', but it reverted with panic code ${decodedReturnData.code.toHexString()} (${
              decodedReturnData.description
            })`
          );
        } else if (decodedReturnData.kind === 'Custom') {
          assert(
            false,
            `Expected transaction to be reverted with reason '${expectedReasonString}', but it reverted with a custom error`
          );
        } else {
          const _exhaustiveCheck: never = decodedReturnData;
        }
      };

      const derivedPromise = Promise.resolve(this._obj).then(
        onSuccess,
        onError
      );

      this.then = derivedPromise.then.bind(derivedPromise);
      this.catch = derivedPromise.catch.bind(derivedPromise);

      return this;
    }
  );
}

export const REVERTED_WITH_CUSTOM_ERROR_CALLED = 'customErrorAssertionCalled';

interface CustomErrorAssertionData {
  contractInterface: any;
  returnData: string;
  customError: CustomError;
}

export function supportRevertedWithCustomError(
  Assertion: Chai.AssertionStatic,
  utils: Chai.ChaiUtils
) {
  Assertion.addMethod(
    'revertedWithCustomError',
    function (this: any, contract: any, expectedCustomErrorName: string) {
      // capture negated flag before async code executes; see buildAssert's jsdoc
      const negated = this.__flags.negate;

      // check the case where users forget to pass the contract as the first
      // argument
      if (typeof contract === 'string' || contract?.interface === undefined) {
        throw new TypeError(
          'The first argument of .revertedWithCustomError must be the contract that defines the custom error'
        );
      }

      // validate custom error name
      if (typeof expectedCustomErrorName !== 'string') {
        throw new TypeError('Expected the custom error name to be a string');
      }

      const iface: any = contract.interface;

      const expectedCustomError = findCustomErrorByName(
        iface,
        expectedCustomErrorName
      );

      // check that interface contains the given custom error
      if (expectedCustomError === undefined) {
        throw new Error(
          `The given contract doesn't have a custom error named '${expectedCustomErrorName}'`
        );
      }

      const onSuccess = () => {
        const assert = buildAssert(negated, onSuccess);

        assert(
          false,
          `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it didn't revert`
        );
      };

      const onError = (error: any) => {
        const assert = buildAssert(negated, onError);

        const returnData = getReturnDataFromError(error);
        const decodedReturnData = decodeReturnData(returnData);

        if (decodedReturnData.kind === 'Empty') {
          assert(
            false,
            `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it reverted without a reason`
          );
        } else if (decodedReturnData.kind === 'Error') {
          assert(
            false,
            `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it reverted with reason '${decodedReturnData.reason}'`
          );
        } else if (decodedReturnData.kind === 'Panic') {
          assert(
            false,
            `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it reverted with panic code ${decodedReturnData.code.toHexString()} (${
              decodedReturnData.description
            })`
          );
        } else if (decodedReturnData.kind === 'Custom') {
          if (decodedReturnData.id === expectedCustomError.id) {
            // add flag with the data needed for .withArgs
            const customErrorAssertionData: CustomErrorAssertionData = {
              contractInterface: iface,
              customError: expectedCustomError,
              returnData,
            };
            this.customErrorData = customErrorAssertionData;

            assert(
              true,
              undefined,
              `Expected transaction NOT to be reverted with custom error '${expectedCustomErrorName}', but it was`
            );
          } else {
            // try to decode the actual custom error
            // this will only work when the error comes from the given contract
            const actualCustomError = findCustomErrorById(
              iface,
              decodedReturnData.id
            );

            if (actualCustomError === undefined) {
              assert(
                false,
                `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it reverted with a different custom error`
              );
            } else {
              assert(
                false,
                `Expected transaction to be reverted with custom error '${expectedCustomErrorName}', but it reverted with custom error '${actualCustomError.name}'`
              );
            }
          }
        } else {
          const _exhaustiveCheck: never = decodedReturnData;
        }
      };

      const derivedPromise = Promise.resolve(this._obj).then(
        onSuccess,
        onError
      );

      // needed for .withArgs
      utils.flag(this, REVERTED_WITH_CUSTOM_ERROR_CALLED, true);
      this.promise = derivedPromise;

      this.then = derivedPromise.then.bind(derivedPromise);
      this.catch = derivedPromise.catch.bind(derivedPromise);

      return this;
    }
  );
}
export type Ssfi = (...args: any[]) => any;
export async function revertedWithCustomErrorWithArgs(
  context: any,
  Assertion: Chai.AssertionStatic,
  _: Chai.ChaiUtils,
  expectedArgs: any[],
  ssfi: Ssfi
) {
  const negated = false; // .withArgs cannot be negated
  const assert = buildAssert(negated, ssfi);

  const customErrorAssertionData: CustomErrorAssertionData =
    context.customErrorData;

  if (customErrorAssertionData === undefined) {
    throw new Error(
      '[.withArgs] should never happen, please submit an issue to the Hardhat repository'
    );
  }

  const {contractInterface, customError, returnData} = customErrorAssertionData;

  const errorFragment = contractInterface.errors[customError.signature];
  // We transform ether's Array-like object into an actual array as it's safer
  const actualArgs = Array.from<any>(
    contractInterface.decodeErrorResult(errorFragment, returnData)
  );

  new Assertion(actualArgs).to.have.same.length(
    expectedArgs.length,
    `expected ${expectedArgs.length} args but got ${actualArgs.length}`
  );

  for (const [i, actualArg] of actualArgs.entries()) {
    const expectedArg = expectedArgs[i];
    if (typeof expectedArg === 'function') {
      const errorPrefix = `The predicate for custom error argument with index ${i}`;
      try {
        assert(
          expectedArg(actualArg),
          `${errorPrefix} returned false`
          // no need for a negated message, since we disallow mixing .not. with
          // .withArgs
        );
      } catch (e) {
        if (e instanceof AssertionError) {
          assert(
            false,
            `${errorPrefix} threw an AssertionError: ${e.message}`
            // no need for a negated message, since we disallow mixing .not. with
            // .withArgs
          );
        }
        throw e;
      }
    } else if (Array.isArray(expectedArg)) {
      new Assertion(actualArg).to.deep.equal(expectedArg);
    } else {
      new Assertion(actualArg).to.equal(expectedArg);
    }
  }
}

interface CustomError {
  name: string;
  id: string;
  signature: string;
}

function findCustomErrorByName(
  iface: any,
  name: string
): CustomError | undefined {
  const ethers = require('ethers');

  const customErrorEntry = Object.entries(iface.errors).find(
    ([, fragment]: any) => fragment.name === name
  );

  if (customErrorEntry === undefined) {
    return undefined;
  }

  const [customErrorSignature] = customErrorEntry;
  const customErrorId = ethers.utils.id(customErrorSignature).slice(0, 10);

  return {
    id: customErrorId,
    name,
    signature: customErrorSignature,
  };
}

function findCustomErrorById(iface: any, id: string): CustomError | undefined {
  const ethers = require('ethers');

  const customErrorEntry: any = Object.entries(iface.errors).find(
    ([signature]: any) => ethers.utils.id(signature).slice(0, 10) === id
  );

  if (customErrorEntry === undefined) {
    return undefined;
  }

  return {
    id,
    name: customErrorEntry[1].name,
    signature: customErrorEntry[0],
  };
}

export function supportReverted(Assertion: Chai.AssertionStatic) {
  Assertion.addProperty('reverted', function (this: any) {
    // capture negated flag before async code executes; see buildAssert's jsdoc
    const negated = this.__flags.negate;

    const subject: unknown = this._obj;

    // Check if the received value can be linked to a transaction, and then
    // get the receipt of that transaction and check its status.
    //
    // If the value doesn't correspond to a transaction, then the `reverted`
    // assertion is false.
    const onSuccess = async (value: unknown) => {
      const assert = buildAssert(negated, onSuccess);

      if (isTransactionResponse(value) || typeof value === 'string') {
        const hash = typeof value === 'string' ? value : value.hash;

        if (!isValidTransactionHash(hash)) {
          throw new TypeError(
            `Expected a valid transaction hash, but got '${hash}'`
          );
        }

        const receipt = await getTransactionReceipt(hash);

        assert(
          receipt.status === 0,
          'Expected transaction to be reverted',
          'Expected transaction NOT to be reverted'
        );
      } else if (isTransactionReceipt(value)) {
        const receipt = value;

        assert(
          receipt.status === 0,
          'Expected transaction to be reverted',
          'Expected transaction NOT to be reverted'
        );
      } else {
        // If the subject of the assertion is not connected to a transaction
        // (hash, receipt, etc.), then the assertion fails.
        // Since we use `false` here, this means that `.not.to.be.reverted`
        // assertions will pass instead of always throwing a validation error.
        // This allows users to do things like:
        //   `expect(c.callStatic.f()).to.not.be.reverted`
        assert(false, 'Expected transaction to be reverted');
      }
    };

    const onError = (error: any) => {
      const assert = buildAssert(negated, onError);
      const returnData = getReturnDataFromError(error);
      const decodedReturnData = decodeReturnData(returnData);

      if (
        decodedReturnData.kind === 'Empty' ||
        decodedReturnData.kind === 'Custom'
      ) {
        // in the negated case, if we can't decode the reason, we just indicate
        // that the transaction didn't revert
        assert(true, undefined, `Expected transaction NOT to be reverted`);
      } else if (decodedReturnData.kind === 'Error') {
        assert(
          true,
          undefined,
          `Expected transaction NOT to be reverted, but it reverted with reason '${decodedReturnData.reason}'`
        );
      } else if (decodedReturnData.kind === 'Panic') {
        assert(
          true,
          undefined,
          `Expected transaction NOT to be reverted, but it reverted with panic code ${decodedReturnData.code.toHexString()} (${
            decodedReturnData.description
          })`
        );
      } else {
        const _exhaustiveCheck: never = decodedReturnData;
      }
    };

    // we use `Promise.resolve(subject)` so we can process both values and
    // promises of values in the same way
    const derivedPromise = Promise.resolve(subject).then(onSuccess, onError);

    this.then = derivedPromise.then.bind(derivedPromise);
    this.catch = derivedPromise.catch.bind(derivedPromise);

    return this;
  });
}

async function getTransactionReceipt(hash: string) {
  const hre = await import('hardhat');

  return hre.ethers.provider.getTransactionReceipt(hash);
}

function isTransactionResponse(x: unknown): x is {hash: string} {
  if (typeof x === 'object' && x !== null) {
    return 'hash' in x;
  }

  return false;
}

function isTransactionReceipt(x: unknown): x is {status: number} {
  if (typeof x === 'object' && x !== null && 'status' in x) {
    const status = (x as any).status;

    // this means we only support ethers's receipts for now; adding support for
    // raw receipts, where the status is an hexadecimal string, should be easy
    // and we can do it if there's demand for that
    return typeof status === 'number';
  }

  return false;
}

function isValidTransactionHash(x: string): boolean {
  return /0x[0-9a-fA-F]{64}/.test(x);
}


### File: /home/errick/core/packages/contracts/test/test-utils/ens.ts ###
import {
  DAO,
  ENSSubdomainRegistrar,
  ENSRegistry,
  PublicResolver,
} from '../../typechain';
import {
  ENSRegistry__factory,
  ENSSubdomainRegistrar__factory,
  PublicResolver__factory,
} from '../../typechain';
import {ensDomainHash, ensLabelHash} from '../../utils/ens';
import {ARTIFACT_SOURCES} from './wrapper';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import hre, {ethers} from 'hardhat';

export async function deployENSSubdomainRegistrar(
  owner: SignerWithAddress,
  managingDao: DAO,
  domain: string
): Promise<ENSSubdomainRegistrar> {
  const ensRegistry = await hre.wrapper.deploy('ENSRegistry');
  const publicResolver = await hre.wrapper.deploy('PublicResolver', {
    args: [ensRegistry.address, owner.address],
  });

  // Register subdomains in the reverse order
  let domainNamesReversed = domain.split('.');
  domainNamesReversed.push(''); //add the root domain
  domainNamesReversed = domainNamesReversed.reverse();

  for (let i = 0; i < domainNamesReversed.length - 1; i++) {
    // to support subdomains
    const domain = domainNamesReversed
      .map((value, index) => (index <= i ? value : ''))
      .filter(value => value !== '')
      .reverse()
      .join('.');
    await ensRegistry.setSubnodeRecord(
      ensDomainHash(domain),
      ensLabelHash(domainNamesReversed[i + 1]),
      owner.address,
      publicResolver.address,
      0
    );
  }

  const ensSubdomainRegistrar = await hre.wrapper.deploy(
    ARTIFACT_SOURCES.ENS_SUBDOMAIN_REGISTRAR,
    {withProxy: true}
  );

  await ensRegistry
    .connect(owner)
    .setApprovalForAll(ensSubdomainRegistrar.address, true);

  // Initialize it with the domain
  const node = ethers.utils.namehash(domain);
  await ensSubdomainRegistrar.initialize(
    managingDao.address,
    ensRegistry.address,
    node
  );

  return ensSubdomainRegistrar;
}

export async function setupResolver(
  ens: ENSRegistry,
  resolver: PublicResolver,
  owner: SignerWithAddress
) {
  await ens
    .connect(owner)
    .setSubnodeOwner(
      ensDomainHash(''),
      ensLabelHash('resolver'),
      await owner.getAddress()
    );

  const resolverNode = ensDomainHash('resolver');

  await ens.connect(owner).setResolver(resolverNode, resolver.address);
  await resolver
    .connect(owner)
    ['setAddr(bytes32,address)'](resolverNode, resolver.address);
}


### File: /home/errick/core/packages/contracts/test/test-utils/plugin-setup-processor.ts ###
import {
  PluginSetupProcessor__factory,
  PluginRepoRegistry,
  PluginSetupProcessor,
} from '../../typechain';
import hre, {ethers} from 'hardhat';

export async function deployPluginSetupProcessor(
  pluginRepoRegistry: PluginRepoRegistry
): Promise<PluginSetupProcessor> {
  const psp = await hre.wrapper.deploy('PluginSetupProcessor', {
    args: [pluginRepoRegistry.address],
  });

  return psp;
}


### File: /home/errick/core/packages/contracts/test/test-utils/skip-functions.ts ###
import {ZK_SYNC_NETWORKS} from '../../utils/zksync';
import hre from 'hardhat';

// ANSI escape codes for colored terminal output
const YELLOW = '\x1b[33m'; // Yellow color for SKIPPED
const BLUE = '\x1b[34m'; // Blue color for message
const RESET = '\x1b[0m'; // Reset to default terminal color

const logSkipped = (testName: string, reason?: string) =>
  console.log(
    `${YELLOW}SKIPPING TEST ${
      reason ? '(' + reason + ')' : ''
    }${RESET}: ${BLUE}${testName}${RESET}`
  );

const logSkippedSuite = (testName: string, reason?: string) =>
  console.log(
    `${YELLOW}SKIPPING TEST SUITE ${
      reason ? '(' + reason + ')' : ''
    }${RESET}: ${BLUE}${testName}${RESET}`
  );

/**
 * Creates a conditional test function that skips based on the provided condition.
 * @param condition - The condition upon which to skip the test.
 * @returns A function to define a test, which will skip based on the condition.
 */
export function skipTestIf(condition: boolean, reason?: string) {
  return (
    testName: string,
    testFunc: ((args: any) => void) | ((args: any) => Promise<void>)
  ) => {
    if (condition) {
      logSkipped(testName, reason);
      return it.skip(testName, testFunc);
    } else {
      return it(testName, testFunc);
    }
  };
}

/**
 * Creates a conditional test suite that skips based on the provided condition.
 * @param condition - The condition upon which to skip the test.
 * @returns A function to define a test, which will skip based on the condition.
 */
export function skipDescribeIf(condition: boolean, reason?: string) {
  return (testName: string, testFunc: (() => void) | (() => Promise<void>)) => {
    if (condition) {
      logSkippedSuite(testName, reason);
      return describe.skip(testName, testFunc);
    } else {
      return describe(testName, testFunc);
    }
  };
}

export function skipTestIfNetworks(networksToSkip: string[], reason?: string) {
  return skipTestIf(networksToSkip.includes(hre.network.name), reason);
}

export function skipDescribeIfNetworks(
  networksToSkip: string[],
  reason?: string
) {
  return skipDescribeIf(networksToSkip.includes(hre.network.name), reason);
}

export const skipTestSuiteIfNetworkIsZkSync = skipDescribeIfNetworks(
  ZK_SYNC_NETWORKS,
  'ZkSync network'
);
export const skipTestIfNetworkIsZkSync = skipTestIfNetworks(
  ZK_SYNC_NETWORKS,
  'ZkSync network'
);


### File: /home/errick/core/packages/contracts/test/test-utils/repo.ts ###
import {
  PluginRepoRegistry,
  PluginRepoFactory,
  PluginRepo,
  PluginUUPSUpgradeableSetupV1Mock,
  PluginRepo__factory,
  PluginUUPSUpgradeableSetupV1Mock__factory,
  PluginRepoRegistry__factory,
  PluginRepoFactory__factory,
} from '../../typechain';
import {ARTIFACT_SOURCES} from './wrapper';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import hre from 'hardhat';

export async function deployMockPluginSetup(
  signer: SignerWithAddress
): Promise<PluginUUPSUpgradeableSetupV1Mock> {
  const implV1 = await hre.wrapper.deploy('PluginUUPSUpgradeableV1Mock');

  const pluginSetupMockContract = await hre.wrapper.deploy(
    'PluginUUPSUpgradeableSetupV1Mock',
    {args: [implV1.address]}
  );

  return pluginSetupMockContract;
}

export async function deployNewPluginRepo(
  maintainer: SignerWithAddress
): Promise<PluginRepo> {
  const newPluginRepo = await hre.wrapper.deploy(ARTIFACT_SOURCES.PLUGIN_REPO, {
    withProxy: true,
  });
  await newPluginRepo.initialize(maintainer.address);

  return newPluginRepo;
}

export async function deployPluginRepoFactory(
  signers: any,
  pluginRepoRegistry: PluginRepoRegistry
): Promise<PluginRepoFactory> {
  // PluginRepoFactory
  const pluginRepoFactory = await hre.wrapper.deploy('PluginRepoFactory', {
    args: [pluginRepoRegistry.address],
  });

  return pluginRepoFactory;
}

export async function deployPluginRepoRegistry(
  managingDao: any,
  ensSubdomainRegistrar: any,
  signer: SignerWithAddress
): Promise<PluginRepoRegistry> {
  let pluginRepoRegistry = await hre.wrapper.deploy(
    ARTIFACT_SOURCES.PLUGIN_REPO_REGISTRY,
    {withProxy: true}
  );

  await pluginRepoRegistry.initialize(
    managingDao.address,
    ensSubdomainRegistrar.address
  );

  return pluginRepoRegistry;
}


### File: /home/errick/core/packages/contracts/test/test-utils/dao.ts ###
import {
  DAO,
  ActionExecute__factory,
  ERC20Mock__factory,
  ERC721Mock__factory,
  ERC1155Mock__factory,
  DAO__factory,
} from '../../typechain';
import {ARTIFACT_SOURCES} from './wrapper';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {BigNumber} from 'ethers';
import hre, {ethers} from 'hardhat';

export const ZERO_BYTES32 =
  '0x0000000000000000000000000000000000000000000000000000000000000000';
export const daoExampleURI = 'https://example.com';

export const TOKEN_INTERFACE_IDS = {
  erc721ReceivedId: '0x150b7a02',
  erc1155ReceivedId: '0xf23a6e61',
  erc1155BatchReceivedId: '0xbc197c81',
  erc721InterfaceId: '0x150b7a02',
  erc1155InterfaceId: '0x4e2312e0',
};

export async function deployNewDAO(signer: SignerWithAddress): Promise<DAO> {
  const dao = await hre.wrapper.deploy(ARTIFACT_SOURCES.DAO, {withProxy: true});

  await dao.initialize(
    '0x00',
    signer.address,
    ethers.constants.AddressZero,
    daoExampleURI
  );

  return dao;
}

export async function getActions() {
  const signers = await ethers.getSigners();
  let ActionExecute = await hre.wrapper.deploy('ActionExecute');
  const iface = new ethers.utils.Interface(ActionExecute__factory.abi);

  const num = 20;
  return {
    failAction: {
      to: ActionExecute.address,
      data: iface.encodeFunctionData('fail'),
      value: 0,
    },
    succeedAction: {
      to: ActionExecute.address,
      data: iface.encodeFunctionData('setTest', [num]),
      value: 0,
    },
    failActionMessage: ethers.utils
      .hexlify(ethers.utils.toUtf8Bytes('ActionExecute:Revert'))
      .substring(2),
    successActionResult: ethers.utils.hexZeroPad(ethers.utils.hexlify(num), 32),
  };
}

export function getERC721TransferAction(
  tokenAddress: string,
  from: string,
  to: string,
  tokenId: number,
  issafe: boolean = true
) {
  const iface = new ethers.utils.Interface(ERC721Mock__factory.abi);

  const functionName = issafe
    ? 'safeTransferFrom(address, address, uint256)'
    : 'transferFrom(address, address, uint256)';

  const encodedData = iface.encodeFunctionData(functionName, [
    from,
    to,
    tokenId,
  ]);

  return {
    to: tokenAddress,
    value: 0,
    data: encodedData,
  };
}

export function getERC20TransferAction(
  tokenAddress: string,
  to: string,
  amount: number | BigNumber
) {
  const iface = new ethers.utils.Interface(ERC20Mock__factory.abi);

  const encodedData = iface.encodeFunctionData('transfer', [to, amount]);
  return {
    to: tokenAddress,
    value: 0,
    data: encodedData,
  };
}

export function getERC1155TransferAction(
  tokenAddress: string,
  from: string,
  to: string,
  tokenId: number,
  amount: number | BigNumber
) {
  const iface = new ethers.utils.Interface(ERC1155Mock__factory.abi);

  const encodedData = iface.encodeFunctionData('safeTransferFrom', [
    from,
    to,
    tokenId,
    amount,
    '0x',
  ]);

  return {
    to: tokenAddress,
    value: 0,
    data: encodedData,
  };
}


### File: /home/errick/core/packages/contracts/test/test-utils/proxy.ts ###
import {ContractFactory} from 'ethers';
import {upgrades} from 'hardhat';

type DeployOptions = {
  constructurArgs?: unknown[];
  proxyType?: 'uups';
};

// Used to deploy the implementation with the ERC1967 Proxy behind it.
// It is designed this way, because it might be desirable to avoid the OpenZeppelin upgrades package.
// In the future, this function might get replaced.
// NOTE: To avoid lots of changes in the whole test codebase, `deployWithProxy`
// won't automatically call `initialize` and it's the caller's responsibility to do so.
export async function deployWithProxy<T>(
  contractFactory: ContractFactory,
  options: DeployOptions = {}
): Promise<T> {
  // NOTE: taking this out of this file and putting this in each test file's
  // before hook seems a good idea for efficiency, though, all test files become
  // highly dependent on this package which is undesirable for now.
  upgrades.silenceWarnings();

  return upgrades.deployProxy(contractFactory, [], {
    kind: options.proxyType || 'uups',
    initializer: false,
    unsafeAllow: ['constructor'],
    constructorArgs: options.constructurArgs || [],
  }) as unknown as Promise<T>;
}


### File: /home/errick/core/packages/contracts/test/test-utils/protocol-version.ts ###
import {version} from '../../package.json';

/**
 * Returns the NPM version number from the `osx` package.json file
 */
export function osxContractsVersion(): [number, number, number] {
  const trimmedVersion = version.split('-')[0];
  const semver = trimmedVersion.split('.');
  return [Number(semver[0]), Number(semver[1]), Number(semver[2])];
}


### File: /home/errick/core/packages/contracts/test/test-utils/uups-upgradeable.ts ###
import {DAO, PluginRepo} from '../../typechain';
import {readStorage, ERC1967_IMPLEMENTATION_SLOT} from '../../utils/storage';
import {SignerWithAddress} from '@nomiclabs/hardhat-ethers/signers';
import {expect} from 'chai';
import {Contract, ContractFactory} from 'ethers';
import hre from 'hardhat';

type options = {
  args?: Record<string, any>;
  initArgs?: Record<string, any>;
  initializer?: string | undefined;
};

// Deploys a proxy and a new implementation from the same factory and checks that the upgrade works.
export async function deployAndUpgradeSelfCheck(
  deployer: number,
  upgrader: number,
  {args = {}, initArgs = {}, initializer = undefined}: options,
  from: string,
  to: string,
  upgradePermissionId: string,
  managingContract?: DAO
) {
  const deployerSigner = (await hre.ethers.getSigners())[deployer];
  const upgraderSigner = (await hre.ethers.getSigners())[upgrader];

  // Deploy proxy and implementation
  const proxy = await hre.wrapper.deployProxy(deployer, from, {
    args: Object.values(args),
    initArgs: Object.values(initArgs),
    proxySettings: {
      initializer: initializer,
    },
  });

  // Grant the upgrade permission
  const grantArgs: [string, string, string] = [
    proxy.address,
    upgraderSigner.address,
    upgradePermissionId,
  ];

  // Check if the contract is a permission manager itself
  if (managingContract === undefined) {
    await expect(
      hre.wrapper.upgradeProxy(upgrader, proxy.address, to, {
        args: Object.values(args),
      })
    )
      .to.be.revertedWithCustomError(proxy, 'Unauthorized')
      .withArgs(...grantArgs);

    await proxy.connect(deployerSigner).grant(...grantArgs);
  }
  // Or if the permission manager is located in a different contract
  else {
    await expect(
      hre.wrapper.upgradeProxy(upgrader, proxy.address, to, {
        args: Object.values(args),
      })
    )
      .to.be.revertedWithCustomError(proxy, 'DaoUnauthorized')
      .withArgs(managingContract.address, ...grantArgs);

    await managingContract.connect(deployerSigner).grant(...grantArgs);
  }

  // Deploy a new implementation (the same contract at a different address)
  const toImplementation = (await hre.wrapper.deploy(to)).address;

  // Confirm that the two implementations are different
  const fromImplementation = await readStorage(
    proxy.address,
    ERC1967_IMPLEMENTATION_SLOT,
    ['address']
  );
  expect(toImplementation).to.not.equal(fromImplementation);

  // Upgrade from the old to the new implementation
  await proxy.connect(upgraderSigner).upgradeTo(toImplementation);

  // Confirm that the proxy points to the new implementation
  const implementationAfterUpgrade = await readStorage(
    proxy.address,
    ERC1967_IMPLEMENTATION_SLOT,
    ['address']
  );
  expect(implementationAfterUpgrade).to.equal(toImplementation);
}

// Deploys a proxy and a new implementation via two different factories and checks that the upgrade works.
export async function deployAndUpgradeFromToCheck(
  deployer: number,
  upgrader: number,
  {args = {}, initArgs = {}, initializer = undefined}: options,
  from: string,
  to: string,
  upgradePermissionId: string,
  managingDao?: DAO | PluginRepo
): Promise<{
  proxy: Contract;
  fromImplementation: string;
  toImplementation: string;
}> {
  const deployerSigner = (await hre.ethers.getSigners())[deployer];
  const upgraderSigner = (await hre.ethers.getSigners())[upgrader];

  // Deploy proxy and implementation
  let proxy = await hre.wrapper.deployProxy(deployer, from, {
    args: Object.values(args),
    initArgs: Object.values(initArgs),
    proxySettings: {
      initializer: initializer,
    },
  });

  const fromImplementation = await readStorage(
    proxy.address,
    ERC1967_IMPLEMENTATION_SLOT,
    ['address']
  );

  // Grant the upgrade permission
  const grantArgs: [string, string, string] = [
    proxy.address,
    upgraderSigner.address,
    upgradePermissionId,
  ];

  if (managingDao === undefined) {
    await expect(
      hre.wrapper.upgradeProxy(upgrader, proxy.address, to, {
        args: Object.values(args),
      })
    )
      .to.be.revertedWithCustomError(proxy, 'Unauthorized')
      .withArgs(...grantArgs);

    await proxy.connect(deployerSigner).grant(...grantArgs);
  } else {
    await expect(
      hre.wrapper.upgradeProxy(upgrader, proxy.address, to, {
        args: Object.values(args),
      })
    )
      .to.be.revertedWithCustomError(proxy, 'DaoUnauthorized')
      .withArgs(managingDao.address, ...grantArgs);

    await managingDao.connect(deployerSigner).grant(...grantArgs);
  }

  // Upgrade the proxy to a new implementation from a different factory
  proxy = await hre.wrapper.upgradeProxy(upgrader, proxy.address, to, {
    args: Object.values(args),
  });

  const toImplementation = await readStorage(
    proxy.address,
    ERC1967_IMPLEMENTATION_SLOT,
    ['address']
  );
  return {proxy, fromImplementation, toImplementation};
}


### File: /home/errick/core/packages/contracts/test/test-utils/wrapper/index.ts ###
import {ProxyCreatedEvent} from '../../../typechain/ProxyFactory';
import {HardhatClass} from './hardhat';
import {ZkSync} from './zksync';
import {findEvent} from '@aragon/osx-commons-sdk';
import {BigNumberish, Contract, Wallet} from 'ethers';
import {providers} from 'ethers';
import hre, {ethers} from 'hardhat';

// TODO: generate paths programatically.
export const ARTIFACT_SOURCES = {
  DAO: 'src/core/dao/DAO.sol:DAO',
  DAO_V1_0_0: '@aragon/osx-v1.0.1/core/dao/DAO.sol:DAO',
  DAO_V1_3_0: '@aragon/osx-v1.3.0/core/dao/DAO.sol:DAO',
  PLUGIN_REPO: 'src/framework/plugin/repo/PluginRepo.sol:PluginRepo',
  PLUGIN_REPO_V1_0_0:
    '@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepo.sol:PluginRepo',
  PLUGIN_REPO_V1_3_0:
    '@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepo.sol:PluginRepo',
  DAO_REGISTRY: 'src/framework/dao/DAORegistry.sol:DAORegistry',
  DAO_REGISTRY_V1_0_0:
    '@aragon/osx-v1.0.1/framework/dao/DAORegistry.sol:DAORegistry',
  DAO_REGISTRY_V1_3_0:
    '@aragon/osx-v1.3.0/framework/dao/DAORegistry.sol:DAORegistry',
  PLUGIN_REPO_REGISTRY:
    'src/framework/plugin/repo/PluginRepoRegistry.sol:PluginRepoRegistry',
  PLUGIN_REPO_REGISTRY_V1_0_0:
    '@aragon/osx-v1.0.1/framework/plugin/repo/PluginRepoRegistry.sol:PluginRepoRegistry',
  PLUGIN_REPO_REGISTRY_V1_3_0:
    '@aragon/osx-v1.3.0/framework/plugin/repo/PluginRepoRegistry.sol:PluginRepoRegistry',
  ENS_SUBDOMAIN_REGISTRAR:
    'src/framework/utils/ens/ENSSubdomainRegistrar.sol:ENSSubdomainRegistrar',
  ENS_SUBDOMAIN_REGISTRAR_V1_0_0:
    '@aragon/osx-v1.0.1/framework/utils/ens/ENSSubdomainRegistrar.sol:ENSSubdomainRegistrar',
  ENS_SUBDOMAIN_REGISTRAR_V1_3_0:
    '@aragon/osx-v1.3.0/framework/utils/ens/ENSSubdomainRegistrar.sol:ENSSubdomainRegistrar',
  MERKLE_DISTRIBUTOR:
    'src/plugins/token/MerkleDistributor.sol:MerkleDistributor',
  MERKLE_DISTRIBUTOR_V1_0_0:
    '@aragon/osx-v1.0.1/plugins/token/MerkleDistributor.sol:MerkleDistributor',
  MERKLE_MINTER: 'src/plugins/token/MerkleMinter.sol:MerkleMinter',
  MERKLE_MINTER_V1_0_0:
    '@aragon/osx-v1.0.1/plugins/token/MerkleMinter.sol:MerkleMinter',
  ADDRESSLIST_VOTING:
    'src/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol:AddresslistVoting',
  ADDRESSLIST_VOTING_V1_0_0:
    '@aragon/osx-v1.0.1/plugins/governance/majority-voting/addresslist/AddresslistVoting.sol:AddresslistVoting',
  TOKEN_VOTING:
    'src/plugins/governance/majority-voting/token/TokenVoting.sol:TokenVoting',
  TOKEN_VOTING_V1_0_0:
    '@aragon/osx-v1.0.1/plugins/governance/majority-voting/token/TokenVoting.sol:TokenVoting',
  MULTISIG: 'src/plugins/governance/multisig/Multisig.sol:Multisig',
  MULTISIG_V1_0_0:
    '@aragon/osx-v1.0.1/plugins/governance/multisig/Multisig.sol:Multisig',
};

export type DeployOptions = {
  initArgs?: any[]; // initialize function arguments in case `withProxy` is set to true.
  args?: any[]; // constructor arguments
  withProxy?: boolean;
  proxySettings?: {
    type?: 'uups' | 'transparent' | 'beacon' | undefined;
    initializer?: string;
  };
};

export interface NetworkDeployment {
  deploy(artifactName: string, args: any[]): any;
  getCreateAddress(sender: string, nonce: BigNumberish): string;
  getNonce(
    sender: string,
    type?: 'Deployment' | 'Transaction'
  ): Promise<number>;
  encodeFunctionData(
    artifactName: string,
    functionName: string,
    args: any[]
  ): Promise<string>;
  deployProxy(
    deployer: number,
    artifactName: string,
    options: DeployOptions
  ): Promise<Contract>;
  upgradeProxy(
    upgrader: number,
    proxyAddress: string,
    newArtifactName: string,
    options: DeployOptions
  ): Promise<Contract>;
}

export class Wrapper {
  network: NetworkDeployment;

  constructor(_network: NetworkDeployment) {
    this.network = _network;
  }

  // Creates an according wrapper class depending on the network.
  // Note that on zksync network, node only has 10 rich addresses whereas
  // on hardhat, it's 20. Tests are heavily using the numbers in the Signers
  // object from 10 to 20. So We make 10 custom addresses rich-funded to
  // allow tests use the same approach on zksync as on hardhat.
  static async create(networkName: string, provider: providers.BaseProvider) {
    if (networkName == 'zkLocalTestnet' || networkName == 'zkSyncLocal') {
      const signers = await ethers.getSigners();
      const allSigners = signers.map(signer => signer.address);

      for (let i = 10; i < 20; i++) {
        await signers[0].sendTransaction({
          to: allSigners[i],
          value: ethers.utils.parseEther('0.5'),
        });
      }

      // @ts-ignore TODO:GIORGI
      return new Wrapper(new ZkSync(provider));
    }

    return new Wrapper(new HardhatClass(provider));
  }

  async deploy(artifactName: string, options?: DeployOptions) {
    const constructorArgs = options?.args ?? [];
    const isProxy = options?.withProxy ?? false;
    const initializer = options?.proxySettings?.initializer ?? undefined;

    let {artifact, contract} = await this.network.deploy(
      artifactName,
      constructorArgs
    );
    if (isProxy) {
      const {contract: proxyFactoryContract} = await this.network.deploy(
        'ProxyFactory',
        [contract.address]
      );

      // Currently, always deploys with UUPS
      let data = '0x';
      if (initializer) {
        data = await this.network.encodeFunctionData(
          artifactName,
          initializer,
          options?.initArgs ?? []
        );
      }

      const tx = await proxyFactoryContract.deployUUPSProxy(data);

      const event = findEvent<ProxyCreatedEvent>(
        await tx.wait(),
        'ProxyCreated'
      );

      contract = new hre.ethers.Contract(
        event.args.proxy,
        artifact.abi,
        (await hre.ethers.getSigners())[0]
      );
    }

    return contract;
  }

  getCreateAddress(sender: string, nonce: BigNumberish): string {
    return this.network.getCreateAddress(sender, nonce);
  }

  async getNonce(
    sender: string,
    type?: 'Deployment' | 'Transaction'
  ): Promise<number> {
    return this.network.getNonce(sender, type ?? 'Deployment');
  }

  async deployProxy(
    deployer: number,
    artifactName: string,
    options?: DeployOptions
  ) {
    const _options: DeployOptions = {
      args: options?.args ?? [],
      initArgs: options?.initArgs ?? [],
      proxySettings: {
        type: options?.proxySettings?.type ?? 'uups',
        initializer: options?.proxySettings?.initializer ?? undefined,
      },
    };

    return this.network.deployProxy(deployer, artifactName, _options);
  }

  async upgradeProxy(
    upgrader: number,
    proxyAddress: string,
    newArtifactName: string,
    options?: DeployOptions
  ) {
    const _options: DeployOptions = {
      args: options?.args ?? [],
      initArgs: options?.initArgs ?? [],
      proxySettings: {
        initializer: options?.proxySettings?.initializer ?? undefined,
      },
    };
    return this.network.upgradeProxy(
      upgrader,
      proxyAddress,
      newArtifactName,
      _options
    );
  }
}


### File: /home/errick/core/packages/contracts/test/test-utils/wrapper/hardhat.ts ###
import {DeployOptions, NetworkDeployment} from '.';
import {BigNumberish, Contract, providers} from 'ethers';
import {utils} from 'ethers';
import hre from 'hardhat';

export class HardhatClass implements NetworkDeployment {
  provider: providers.BaseProvider;
  constructor(_provider: providers.BaseProvider) {
    this.provider = _provider;
  }

  async deploy(artifactName: string, args: any[] = []) {
    const {ethers} = hre;
    const signers = await ethers.getSigners();
    const artifact = await hre.artifacts.readArtifact(artifactName);
    let contract = await new ethers.ContractFactory(
      artifact.abi,
      artifact.bytecode,
      signers[0]
    ).deploy(...args);

    return {artifact, contract};
  }

  async encodeFunctionData(
    artifactName: string,
    functionName: string,
    args: any[]
  ): Promise<string> {
    const {ethers} = hre;
    const signers = await ethers.getSigners();
    const artifact = await hre.artifacts.readArtifact(artifactName);
    const contract = new ethers.ContractFactory(
      artifact.abi,
      artifact.bytecode,
      signers[0]
    );

    const fragment = contract.interface.getFunction(functionName);
    return contract.interface.encodeFunctionData(fragment, args);
  }

  getCreateAddress(sender: string, nonce: BigNumberish): string {
    return utils.getContractAddress({from: sender, nonce: nonce});
  }

  async getNonce(
    sender: string,
    type?: 'Deployment' | 'Transaction'
  ): Promise<number> {
    return this.provider.getTransactionCount(sender);
  }

  async deployProxy(
    deployer: number,
    artifactName: string,
    options: DeployOptions
  ): Promise<Contract> {
    const {ethers} = hre;
    const signer = (await ethers.getSigners())[deployer];

    const artifact = await hre.artifacts.readArtifact(artifactName);
    const contract = new ethers.ContractFactory(
      artifact.abi,
      artifact.bytecode,
      signer
    );

    // Currently, it doesn't use type and always deployes with uups
    return hre.upgrades.deployProxy(contract, options.initArgs, {
      kind: options.proxySettings?.type,
      initializer: options.proxySettings?.initializer ?? false,
      unsafeAllow: ['constructor'],
      constructorArgs: options.args,
    });
  }

  async upgradeProxy(
    upgrader: number,
    proxyAddress: string,
    newArtifactName: string,
    options: DeployOptions
  ): Promise<Contract> {
    const {ethers} = hre;
    const signer = (await ethers.getSigners())[upgrader];

    const artifact = await hre.artifacts.readArtifact(newArtifactName);

    let contract = new ethers.ContractFactory(
      artifact.abi,
      artifact.bytecode,
      signer
    );

    return hre.upgrades.upgradeProxy(proxyAddress, contract, {
      unsafeAllow: ['constructor'],
      constructorArgs: options.args,
    });
  }
}


### File: /home/errick/core/packages/contracts/test/test-utils/wrapper/zksync.ts ###
import {DeployOptions, NetworkDeployment} from '.';
import {getTime} from '../voting';
import {BigNumber, BigNumberish, Contract} from 'ethers';
import hre from 'hardhat';
import {Provider} from 'zksync-ethers';
import {utils, ContractFactory} from 'zksync-ethers';

export class ZkSync implements NetworkDeployment {
  provider: Provider;
  constructor(_provider: Provider) {
    this.provider = _provider;
  }

  async deploy(artifactName: string, args: any[] = []) {
    const {deployer} = hre;

    const artifact = await deployer.loadArtifact(artifactName);
    const contract = await deployer.deploy(artifact, args);

    return {artifact, contract};
  }

  async encodeFunctionData(
    artifactName: string,
    functionName: string,
    args: any[]
  ): Promise<string> {
    const {deployer} = hre;
    const artifact = await deployer.loadArtifact(artifactName);
    const contract = new ContractFactory(
      artifact.abi,
      artifact.bytecode,
      await deployer.getWallet()
    );

    const fragment = contract.interface.getFunction(functionName);
    return contract.interface.encodeFunctionData(fragment, args);
  }

  getCreateAddress(sender: string, nonce: BigNumberish): string {
    return utils.createAddress(sender, nonce);
  }

  async getNonce(
    sender: string,
    type: 'Deployment' | 'Transaction' = 'Deployment'
  ): Promise<number> {
    if (type == 'Deployment') {
      const {ethers} = hre;
      const NONCE_HOLDER_ADDRESS = '0x0000000000000000000000000000000000008003';
      const abi = [
        'function getDeploymentNonce(address) public view returns(uint256)',
      ];
      let signers = await ethers.getSigners();
      let contract = new ethers.Contract(NONCE_HOLDER_ADDRESS, abi, signers[0]);
      const nonce = await contract.getDeploymentNonce(sender);
      return BigNumber.from(nonce).toNumber();
    }

    return this.provider.getTransactionCount(sender);
  }

  // currently, type is not used and always deploys with UUPS
  async deployProxy(
    deployer: number,
    artifactName: string,
    options: DeployOptions
  ): Promise<Contract> {
    const wallets = await hre.zksyncEthers.getWallets();
    const artifact = await hre.deployer.loadArtifact(artifactName);

    return hre.zkUpgrades.deployProxy(
      wallets[deployer],
      artifact,
      options.initArgs,
      {
        kind: options.proxySettings?.type,
        unsafeAllow: ['constructor'],
        constructorArgs: options.args,
        initializer: options.proxySettings?.initializer,
      },
      true
    );
  }

  async upgradeProxy(
    upgrader: number,
    proxyAddress: string,
    newArtifactName: string,
    options: DeployOptions
  ): Promise<Contract> {
    const wallets = await hre.zksyncEthers.getWallets();
    const newArtifact = await hre.deployer.loadArtifact(newArtifactName);

    return hre.zkUpgrades.upgradeProxy(
      wallets[upgrader],
      proxyAddress,
      newArtifact,
      {
        unsafeAllow: ['constructor'],
        constructorArgs: options.args,
        // TODO: pass initiailizer and initArgs
      },
      true
    );
  }
}


### File: /home/errick/core/packages/contracts/test/test-utils/psp/mock-helpers.ts ###
import {Operation} from '@aragon/osx-commons-sdk';
import {utils, constants} from 'ethers';
import {ethers} from 'hardhat';

export function mockPermissionsOperations(
  start: number,
  end: number,
  op: Operation
) {
  let arr = [];

  for (let i = start; i < end; i++) {
    arr.push({
      operation: op,
      where: utils.hexZeroPad(ethers.utils.hexlify(i), 20),
      who: utils.hexZeroPad(ethers.utils.hexlify(i), 20),
      condition: constants.AddressZero,
      permissionId: utils.id('MOCK_PERMISSION'),
    });
  }

  return arr.map(item => Object.values(item));
}

export function mockHelpers(amount: number): string[] {
  let arr: string[] = [];

  for (let i = 0; i < amount; i++) {
    arr.push(utils.hexZeroPad(ethers.utils.hexlify(i), 20));
  }

  return arr;
}


### File: /home/errick/core/packages/contracts/test/test-utils/psp/create-params.ts ###
import {hashHelpers} from '../../../utils/psp';
import {PermissionOperation, PluginRepoPointer, VersionTag} from './types';
import {BytesLike} from 'ethers';

export function createPrepareInstallationParams(
  pluginRepoPointer: PluginRepoPointer,
  data: BytesLike
) {
  return {
    pluginSetupRef: {
      pluginSetupRepo: pluginRepoPointer[0],
      versionTag: {
        release: pluginRepoPointer[1],
        build: pluginRepoPointer[2],
      },
    },
    data: data,
  };
}

export function createApplyInstallationParams(
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  permissions: PermissionOperation[],
  helpers: string[]
) {
  return {
    plugin: plugin,
    pluginSetupRef: {
      pluginSetupRepo: pluginRepoPointer[0],
      versionTag: {
        release: pluginRepoPointer[1],
        build: pluginRepoPointer[2],
      },
    },
    permissions: permissions,
    helpersHash: hashHelpers(helpers),
  };
}

export function createPrepareUpdateParams(
  plugin: string,
  currentVersionTag: VersionTag,
  newVersionTag: VersionTag,
  pluginSetupRepo: string,
  helpers: string[],
  data: BytesLike
) {
  return {
    currentVersionTag: {
      release: currentVersionTag[0],
      build: currentVersionTag[1],
    },
    newVersionTag: {
      release: newVersionTag[0],
      build: newVersionTag[1],
    },
    pluginSetupRepo: pluginSetupRepo,
    setupPayload: {
      plugin: plugin,
      currentHelpers: helpers,
      data: data,
    },
  };
}

export function createApplyUpdateParams(
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  initData: BytesLike,
  permissions: PermissionOperation[],
  helpers: string[]
) {
  return {
    plugin: plugin,
    permissions: permissions,
    pluginSetupRef: {
      pluginSetupRepo: pluginRepoPointer[0],
      versionTag: {
        release: pluginRepoPointer[1],
        build: pluginRepoPointer[2],
      },
    },
    helpersHash: hashHelpers(helpers),
    initData: initData,
  };
}

export function createPrepareUninstallationParams(
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  helpers: string[],
  data: BytesLike
) {
  return {
    pluginSetupRef: {
      pluginSetupRepo: pluginRepoPointer[0],
      versionTag: {
        release: pluginRepoPointer[1],
        build: pluginRepoPointer[2],
      },
    },
    setupPayload: {
      plugin: plugin,
      currentHelpers: helpers,
      data: data,
    },
  };
}

export function createApplyUninstallationParams(
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  permissions: PermissionOperation[]
) {
  return {
    plugin: plugin,
    pluginSetupRef: {
      pluginSetupRepo: pluginRepoPointer[0],
      versionTag: {
        release: pluginRepoPointer[1],
        build: pluginRepoPointer[2],
      },
    },
    permissions: permissions,
  };
}


### File: /home/errick/core/packages/contracts/test/test-utils/psp/types.ts ###
import {Operation} from '@aragon/osx-commons-sdk';
import {BytesLike} from 'ethers';

export type PermissionOperation = {
  operation: Operation;
  where: string;
  who: string;
  condition: string;
  permissionId: BytesLike;
};

export enum PreparationType {
  None,
  Installation,
  Update,
  Uninstallation,
}

// release, build
export type VersionTag = [number, number];

// PluginRepo, release, build
export type PluginRepoPointer = [string, number, number];


### File: /home/errick/core/packages/contracts/test/test-utils/psp/hash-helpers.ts ###
import {hashHelpers} from '../../../utils/psp';
import {PermissionOperation, PluginRepoPointer, PreparationType} from './types';
import {BytesLike} from 'ethers';
import {defaultAbiCoder, keccak256, solidityPack} from 'ethers/lib/utils';

const ZERO_BYTES_HASH = keccak256(
  defaultAbiCoder.encode(
    ['bytes32'],
    ['0x0000000000000000000000000000000000000000000000000000000000000000']
  )
);

export function tagHash(release: number, build: number) {
  return keccak256(solidityPack(['uint8', 'uint16'], [release, build]));
}

export function hashPermissions(permissions: PermissionOperation[]) {
  return keccak256(
    defaultAbiCoder.encode(
      ['tuple(uint8,address,address,address,bytes32)[]'],
      [permissions]
    )
  );
}

export function getPluginInstallationId(dao: string, plugin: string) {
  return keccak256(
    defaultAbiCoder.encode(['address', 'address'], [dao, plugin])
  );
}

export function getPreparedSetupId(
  pluginRepoPointer: PluginRepoPointer,
  helpers: string[] | null,
  permissions: PermissionOperation[] | null,
  data: BytesLike,
  preparationType: PreparationType
) {
  return keccak256(
    defaultAbiCoder.encode(
      [
        'tuple(uint8, uint16)',
        'address',
        'bytes32',
        'bytes32',
        'bytes32',
        'uint8',
      ],
      [
        [pluginRepoPointer[1], pluginRepoPointer[2]],
        pluginRepoPointer[0],
        permissions !== null ? hashPermissions(permissions) : ZERO_BYTES_HASH,
        helpers !== null ? hashHelpers(helpers) : ZERO_BYTES_HASH,
        keccak256(data),
        preparationType,
      ]
    )
  );
}

export function getAppliedSetupId(
  pluginRepoPointer: PluginRepoPointer,
  helpers: string[]
) {
  return keccak256(
    defaultAbiCoder.encode(
      ['tuple(uint8, uint16)', 'address', 'bytes32'],
      [
        [pluginRepoPointer[1], pluginRepoPointer[2]],
        pluginRepoPointer[0],
        hashHelpers(helpers),
      ]
    )
  );
}


### File: /home/errick/core/packages/contracts/test/test-utils/psp/wrappers.ts ###
import {PluginSetupProcessor} from '../../../typechain';
import {
  InstallationAppliedEvent,
  InstallationPreparedEvent,
  UninstallationAppliedEvent,
  UninstallationPreparedEvent,
  UpdateAppliedEvent,
  UpdatePreparedEvent,
} from '../../../typechain/PluginSetupProcessor';
import {
  createApplyInstallationParams,
  createApplyUninstallationParams,
  createApplyUpdateParams,
  createPrepareInstallationParams,
  createPrepareUninstallationParams,
  createPrepareUpdateParams,
} from './create-params';
import {PermissionOperation, PluginRepoPointer} from './types';
import {findEvent} from '@aragon/osx-commons-sdk';
import {BytesLike} from 'ethers';

export async function prepareInstallation(
  psp: PluginSetupProcessor,
  daoAddress: string,
  pluginRepoPointer: PluginRepoPointer,
  data: BytesLike
): Promise<InstallationPreparedEvent['args']> {
  const tx = await psp.prepareInstallation(
    daoAddress,
    createPrepareInstallationParams(pluginRepoPointer, data)
  );

  const event = findEvent<InstallationPreparedEvent>(
    await tx.wait(),
    'InstallationPrepared'
  );

  return event.args;
}

export async function applyInstallation(
  psp: PluginSetupProcessor,
  daoAddress: string,
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  permissions: PermissionOperation[],
  helpers: string[]
): Promise<InstallationAppliedEvent['args']> {
  const tx = await psp.applyInstallation(
    daoAddress,
    createApplyInstallationParams(
      plugin,
      pluginRepoPointer,
      permissions,
      helpers
    )
  );

  const event = findEvent<InstallationAppliedEvent>(
    await tx.wait(),
    'InstallationApplied'
  );

  return event.args;
}

export async function prepareUpdate(
  psp: PluginSetupProcessor,
  daoAddress: string,
  plugin: string,
  currentVersionTag: [number, number],
  newVersionTag: [number, number],
  pluginSetupRepo: string,
  helpers: string[],
  data: BytesLike
): Promise<UpdatePreparedEvent['args']> {
  const tx = await psp.prepareUpdate(
    daoAddress,
    createPrepareUpdateParams(
      plugin,
      currentVersionTag,
      newVersionTag,
      pluginSetupRepo,
      helpers,
      data
    )
  );

  const event = findEvent<UpdatePreparedEvent>(
    await tx.wait(),
    'UpdatePrepared'
  );

  return event.args;
}

export async function applyUpdate(
  psp: PluginSetupProcessor,
  daoAddress: string,
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  initData: BytesLike,
  permissions: PermissionOperation[],
  helpers: string[]
): Promise<UpdateAppliedEvent['args']> {
  const tx = await psp.applyUpdate(
    daoAddress,
    createApplyUpdateParams(
      plugin,
      pluginRepoPointer,
      initData,
      permissions,
      helpers
    )
  );

  const event = findEvent<UpdateAppliedEvent>(await tx.wait(), 'UpdateApplied');

  return event.args;
}

export async function prepareUninstallation(
  psp: PluginSetupProcessor,
  daoAddress: string,
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  helpers: string[],
  data: BytesLike
): Promise<UninstallationPreparedEvent['args']> {
  const tx = await psp.prepareUninstallation(
    daoAddress,
    createPrepareUninstallationParams(plugin, pluginRepoPointer, helpers, data)
  );

  const event = findEvent<UninstallationPreparedEvent>(
    await tx.wait(),
    'UninstallationPrepared'
  );

  return event.args;
}

export async function applyUninstallation(
  psp: PluginSetupProcessor,
  daoAddress: string,
  plugin: string,
  pluginRepoPointer: PluginRepoPointer,
  permissions: PermissionOperation[]
): Promise<UninstallationAppliedEvent['args']> {
  const tx = await psp.applyUninstallation(
    daoAddress,
    createApplyUninstallationParams(plugin, pluginRepoPointer, permissions)
  );

  const event = findEvent<UninstallationAppliedEvent>(
    await tx.wait(),
    'UninstallationApplied'
  );

  return event.args;
}


### File: /home/errick/core/packages/contracts/test/test-utils/psp/atomic-helpers.ts ###
import {DAO, PluginSetupProcessor} from '../../../typechain';
import {PermissionOperation, PluginRepoPointer, VersionTag} from './types';
import {
  applyInstallation,
  applyUninstallation,
  applyUpdate,
  prepareInstallation,
  prepareUninstallation,
  prepareUpdate,
} from './wrappers';
import {BytesLike} from 'ethers';

const EMPTY_DATA = '0x';

// Requires a caller to have apply install permission on psp.
export async function installPlugin(
  psp: PluginSetupProcessor,
  targetDao: string,
  pluginRepoPointer: PluginRepoPointer,
  data: BytesLike = EMPTY_DATA
): Promise<{
  plugin: string;
  helpers: string[];
  permissions: PermissionOperation[];
  preparedSetupId: string;
  appliedSetupId: string;
}> {
  let plugin: string;
  let helpers: string[];
  let permissions: PermissionOperation[];
  let preparedSetupId: string;
  ({
    plugin: plugin,
    preparedSetupData: {helpers, permissions},
    preparedSetupId: preparedSetupId,
  } = await prepareInstallation(psp, targetDao, pluginRepoPointer, data));

  const {appliedSetupId: appliedSetupId} = await applyInstallation(
    psp,
    targetDao,
    plugin,
    pluginRepoPointer,
    permissions,
    helpers
  );

  return {plugin, helpers, permissions, appliedSetupId, preparedSetupId};
}

// Requires a caller to have apply uninstall permission on psp.
export async function uninstallPlugin(
  psp: PluginSetupProcessor,
  targetDao: string,
  plugin: string,
  helpers: string[],
  pluginRepoPointer: PluginRepoPointer,
  data: BytesLike = EMPTY_DATA
) {
  const {permissions} = await prepareUninstallation(
    psp,
    targetDao,
    plugin,
    pluginRepoPointer,
    helpers,
    data
  );

  await applyUninstallation(
    psp,
    targetDao,
    plugin,
    pluginRepoPointer,
    permissions
  );
}

export async function updatePlugin(
  psp: PluginSetupProcessor,
  targetDao: string,
  proxy: string,
  currentVersion: VersionTag,
  newVersion: VersionTag,
  pluginSetupRepo: string,
  currentHelpers: string[],
  data: BytesLike
) {
  const {
    preparedSetupData: {permissions, helpers: updatedHelpers},
    initData,
  } = await prepareUpdate(
    psp,
    targetDao,
    proxy,
    currentVersion,
    newVersion,
    pluginSetupRepo,
    currentHelpers,
    data
  );

  await applyUpdate(
    psp,
    targetDao,
    proxy,
    [pluginSetupRepo, ...newVersion],
    initData,
    permissions,
    updatedHelpers
  );

  return {initData, updatedHelpers, permissions};
}


### File: /home/errick/core/packages/contracts/types/hardhat.d.ts ###
import {BigNumberish, BytesLike} from 'ethers';

import {Wrapper} from '../test/test-utils/wrapper';
import { HardhatRuntimeEnvironment } from 'hardhat/types';


export type AragonVerifyEntry = {
  contract?: string;
  address: string;
  args?: any[];
};

/**
 * Represents a testing fork configuration.
 *
 * @network The name of the forked network.
 * @osxVersion The version of OSx at the moment of the fork.
 */
export type TestingFork = {
  network: string;
  osxVersion: string;
  activeContracts: any;
};

declare module 'hardhat/types/runtime' {
  interface HardhatRuntimeEnvironment {
    aragonToVerifyContracts: AragonVerifyEntry[];
    managementDAOMultisigPluginAddress: string;
    placeholderBuildCIDPath: string;
    managementDAOActions: {
      to: string;
      value: BigNumberish;
      data: BytesLike;
      description: string; // Description to be included in proposal metadata
    }[];
    wrapper: Wrapper;
    testingFork: TestingFork;
  }
}

### File: /home/errick/core/packages/contracts/scripts/generate-typechain-osx-versions.ts ###
import {OSX_VERSION_ALIASES} from './osx-versions-aliases';
import {exec} from 'child_process';
import fs from 'fs';
import path from 'path';
import util from 'util';

const execPromise = util.promisify(exec);

async function generateTypechain(src: string, dest: string): Promise<void> {
  const {stdout} = await execPromise(
    `find "${src}" -name '*.json' -type f ! -name '*.dbg.json'`
  );
  const jsonFiles = stdout.trim().split('\n');

  for (const file of jsonFiles) {
    const relativePath = path.relative(src, path.dirname(file));
    const outputDir = path.join(dest, relativePath);
    fs.mkdirSync(outputDir, {recursive: true});

    await execPromise(
      `typechain --target ethers-v5 --out-dir "${outputDir}" "${file}"`
    );
  }
}

for (let i = 0; i < OSX_VERSION_ALIASES.length; i++) {
  generateTypechain(
    `./artifacts/${OSX_VERSION_ALIASES[i]}`,
    `./typechain/${OSX_VERSION_ALIASES[i]}`
  );
}


### File: /home/errick/core/packages/contracts/scripts/prepare-docs.sh ###
#!/usr/bin/env bash

set -euo pipefail
# shopt -s globstar

PACKAGE_NAME="@aragon/osx-commons-configs"
PACKAGE_PATH=$(node -p "require.resolve('$PACKAGE_NAME')")
TEMPLATES_PATH=$(dirname "$PACKAGE_PATH")/docs/templates

cp -r "$TEMPLATES_PATH" "./docs"

OUTDIR="$(node -p 'require("./docs/config.js").outputDir')"

if [ ! -d node_modules ]; then
  npm ci
fi

rm -rf "$OUTDIR"

echo $OUTDIR

hardhat docgen

node scripts/gen-nav.js "$OUTDIR" > "$OUTDIR/../nav.adoc"

rm -rf ./docs/templates

### File: /home/errick/core/packages/contracts/scripts/generate-typechain-osx.ts ###
import {OSX_VERSION_ALIASES} from './osx-versions-aliases';
import {exec} from 'child_process';
import fs from 'fs';
import path from 'path';
import util from 'util';

const execPromise = util.promisify(exec);

async function generateTypechain(): Promise<void> {
  const artifactsDir = './artifacts';
  const excludedDirs = new Set([path.join(artifactsDir, 'build-info')]);

  for (let i = 0; i < OSX_VERSION_ALIASES.length; i++) {
    excludedDirs.add(path.join(artifactsDir, OSX_VERSION_ALIASES[i]));
  }

  const jsonFiles: string[] = [];

  console.log('Searching for files...');

  findFiles(artifactsDir, filePath => {
    if (!filePath.endsWith('.json')) {
      return;
    }

    if (filePath.endsWith('.dbg.json')) {
      return;
    }

    const dirPath = path.dirname(filePath);
    if (!excludedDirs.has(dirPath)) {
      jsonFiles.push(filePath);
    }
  });

  console.log(`Found ${jsonFiles.length} files. Running typechain...`);

  const filesArg = jsonFiles.join(' ');

  if (filesArg) {
    await execPromise(
      `typechain --target ethers-v5 --out-dir ./typechain ${filesArg}`
    );
  }

  console.log('Finished processing all files.');
}

function findFiles(dir: string, callback: (filePath: string) => void): void {
  const files = fs.readdirSync(dir);

  for (const file of files) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat.isDirectory()) {
      findFiles(filePath, callback);
    } else if (stat.isFile()) {
      callback(filePath);
    }
  }
}

generateTypechain().catch(error => {
  console.error('An error occurred:', error);
});


### File: /home/errick/core/packages/contracts/scripts/osx-versions-aliases.ts ###
/**
 * An array of strings representing the aliases of different versions
 * of the @aragon/osx package. These aliases can be used to import
 * and work with contracts from previous versions of the package.
 *
 * To add a new version alias, append it to this array.
 */
export const OSX_VERSION_ALIASES = [
  '@aragon/osx-v1.0.1/',
  '@aragon/osx-v1.3.0/',
];


### File: /home/errick/core/packages/contracts/scripts/gen-nav.js ###
#!/usr/bin/env node

const path = require('path');
const glob = require('glob');
const startCase = require('lodash.startcase');

const baseDir = process.argv[2];

const files = glob
  .sync(baseDir + '/**/*.adoc')
  .map(f => path.relative(baseDir, f));

console.log('.API');

function getPageTitle(directory) {
  switch (directory) {
    case 'metatx':
      return 'Meta Transactions';
    case 'common':
      return 'Common (Tokens)';
    default:
      return startCase(directory);
  }
}

const links = files.map(file => {
  const doc = file.replace(baseDir, '');
  const title = path.parse(file).name;

  return {
    xref: `* xref:${doc}[${getPageTitle(title)}]`,
    title,
  };
});

// Case-insensitive sort based on titles (so 'token/ERC20' gets sorted as 'erc20')
const sortedLinks = links.sort(function (a, b) {
  return a.title
    .toLowerCase()
    .localeCompare(b.title.toLowerCase(), undefined, {numeric: true});
});

for (const link of sortedLinks) {
  console.log(link.xref);
}


### File: /home/errick/core/packages/artifacts/prepare-abi.sh ###
#!/usr/bin/env bash

# Exit on error
set -e

# Constants
CONTRACTS_FOLDER="../contracts"
TARGET_ABI_FILE="./src/abi.ts"

# Move into contracts package and install dependencies
cd $CONTRACTS_FOLDER

yarn --ignore-scripts && yarn build

# Move back to artifacts package
cd - > /dev/null

# Wipe the destination file
echo "// NOTE: Do not edit this file. It is generated automatically." > $TARGET_ABI_FILE

# Extract the abi field and create a TS file
CONTRACT_ARTIFACTS=$(ls \
    $CONTRACTS_FOLDER/artifacts/src/core/*/*/*.json \
    $CONTRACTS_FOLDER/artifacts/src/framework/*/*/*.json \
    $CONTRACTS_FOLDER/artifacts/src/framework/*/*/*/*.json \
    | grep -v ".dbg." \
    | grep -v utils
)
for FILE in $CONTRACT_ARTIFACTS
do
    SRC_FILE_NAME=$(basename $FILE)

    # Backwards compatible exports with abi and bytecode
    ABI=$(node -e "console.log(JSON.stringify(JSON.parse(fs.readFileSync('$FILE').toString()).abi))")
    BYTECODE=$(node -e "console.log(JSON.parse(fs.readFileSync('$FILE').toString()).bytecode || '')")
    CONTRACT_NAME=${SRC_FILE_NAME%".json"}

    echo "export const ${CONTRACT_NAME}ABI = $ABI as const;" >> $TARGET_ABI_FILE

    if [ "$BYTECODE" == "0x" -o "$BYTECODE" == "" ]; then
        echo "const ${CONTRACT_NAME}Bytecode = null;" >> $TARGET_ABI_FILE
    else
        echo "const ${CONTRACT_NAME}Bytecode = \"$BYTECODE\";" >> $TARGET_ABI_FILE
    fi

    echo "
export class ${CONTRACT_NAME} {
  /** @deprecated Use \`${CONTRACT_NAME}ABI\` instead. */
  static get abi() {
    console.warn('Warning: \`${CONTRACT_NAME}.abi\` is deprecated. Use \`${CONTRACT_NAME}ABI\` instead.');
    return ${CONTRACT_NAME}ABI;
  }

  /** @deprecated Use the bytecode deployed on the target network. See addresses.json */
  static get bytecode(): \`0x\${string}\` | null {
    console.warn('Warning: \`${CONTRACT_NAME}.bytecode\` is deprecated and may be removed in future versions.');
    return ${CONTRACT_NAME}Bytecode;
  }
}

" >> $TARGET_ABI_FILE

    echo "" >> $TARGET_ABI_FILE
done

# Common interfaces JSON ABI
EXTRA_CONTRACT_ABI_FILES=$(ls \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/dao/*.sol/*.json \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/executors/*.sol/*.json \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/permission/*/*.sol/*.json \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/plugin/*.sol/*.json \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/plugin/setup/*.sol/*.json \
    $CONTRACTS_FOLDER/artifacts/@aragon/osx-commons-contracts/src/utils/versioning/*.sol/*.json \
    | grep -v ".dbg."
)

# Shipping the common interfaces as well
for FILE in $EXTRA_CONTRACT_ABI_FILES
do
    SRC_FILE_NAME=$(basename $FILE)

    ABI=$(node -e "console.log(JSON.stringify(JSON.parse(fs.readFileSync('$FILE').toString()).abi))")
    BYTECODE=$(node -e "console.log(JSON.parse(fs.readFileSync('$FILE').toString()).bytecode || '')")
    CONTRACT_NAME=${SRC_FILE_NAME%".json"}

    echo "export const ${CONTRACT_NAME}ABI = $ABI as const;" >> $TARGET_ABI_FILE

    if [ "$BYTECODE" == "0x" -o "$BYTECODE" == "" ]; then
        echo "const ${CONTRACT_NAME}Bytecode = null;" >> $TARGET_ABI_FILE
    else
        echo "const ${CONTRACT_NAME}Bytecode = \"$BYTECODE\";" >> $TARGET_ABI_FILE
    fi

    echo "
export class ${CONTRACT_NAME} {
  /** @deprecated Use \`${CONTRACT_NAME}ABI\` instead. */
  static get abi() {
    console.warn('Warning: \`${CONTRACT_NAME}.abi\` is deprecated. Use \`${CONTRACT_NAME}ABI\` instead.');
    return ${CONTRACT_NAME}ABI;
  }

  /** @deprecated Use the bytecode deployed on the target network. See addresses.json */
  static get bytecode(): \`0x\${string}\` | null {
    console.warn('Warning: \`${CONTRACT_NAME}.bytecode\` is deprecated and may be removed in future versions.');
    return ${CONTRACT_NAME}Bytecode;
  }
}

" >> $TARGET_ABI_FILE

    echo "" >> $TARGET_ABI_FILE
done

echo "ABI prepared: $TARGET_ABI_FILE"


### File: /home/errick/core/packages/artifacts/tsconfig.json ###
{
    "compilerOptions": {
      "target": "ES2018",
      "module": "commonjs",
      "declaration": true,
      "outDir": "./dist",
      "resolveJsonModule": true
    },
    "include": ["src"]
}


### File: /home/errick/core/packages/artifacts/package.json ###
{
  "name": "@aragon/osx-artifacts",
  "version": "1.4.0-alpha",
  "description": "The ABI definitions and addresses for Aragon OSx",
  "typings": "dist/index.d.ts",
  "main": "dist/index.js",
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "yarn prepare-abi && rm -Rf dist && tsc -p tsconfig.json",
    "prepare-abi": "bash prepare-abi.sh"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/aragon/osx"
  },
  "author": "Aragon X",
  "license": "AGPL-3.0-or-later",
  "bugs": {
    "url": "https://github.com/aragon/osx/issues"
  },
  "homepage": "https://github.com/aragon/osx#readme",
  "devDependencies": {
    "typescript": "^5.7.3"
  }
}


### File: /home/errick/core/packages/artifacts/src/index.ts ###
export * from "./abi";

import * as addresses from "./addresses.json";
export {addresses};


### File: /home/errick/core/packages/artifacts/src/addresses.json ###
{
    "dao": {
      "mainnet": "",
      "sepolia": "",
      "holesky": "",
      "devSepolia": "",
      "polygon": "",
      "mumbai": "",
      "base": "",
      "baseSepolia": "",
      "arbitrum": "",
      "arbitrumSepolia": "",
      "linea": "",
      "lineaSepolia": "",
      "zksync": "",
      "zksyncSepolia": ""
    },
    "daoFactory": {
      "mainnet": "",
      "sepolia": "",
      "holesky": "",
      "devSepolia": "",
      "polygon": "",
      "mumbai": "",
      "base": "",
      "baseSepolia": "",
      "arbitrum": "",
      "arbitrumSepolia": "",
      "linea": "",
      "lineaSepolia": "",
      "zksync": "",
      "zksyncSepolia": ""
    },
    "daoRegistry": {
      "mainnet": "0x7a62da7B56fB3bfCdF70E900787010Bc4c9Ca42e",
      "sepolia": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "holesky": "0x005098056a837c2c4F99C7eCeE976F8D90bdFFF8",
      "devSepolia": "0x11C12ECfdDa98e19D765904DCe1Ac2C0504F64c5",
      "polygon": "0x96E54098317631641703404C06A5afAD89da7373",
      "mumbai": "0x6dD0C8b7F9406206ceAA01B5576D9d46e9298f0E",
      "base": "0xeB98a71d69a1e12B62c10368D9dA5364CE0f7178",
      "baseSepolia": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "arbitrum": "0xB5146Fd572C669ABC353902e43F47fda4609E38A",
      "arbitrumSepolia": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "linea": "0xB2CCCB4d7ec56F992219BCF4abe2E7F02003443e",
      "lineaSepolia": "0x55D97adc381ac85AA35E6215460431E069BFe264",
      "zksync": "0xE7351bA0DDCc52249F27353893BcDBC74229e99d",
      "zksyncSepolia": "0x9305Ecd8D3837F7AC4f425dA578a0D11352D317A"
    },
    "pluginRepoFactory": {
      "mainnet": "",
      "sepolia": "",
      "holesky": "",
      "devSepolia": "",
      "polygon": "",
      "mumbai": "",
      "base": "",
      "baseSepolia": "",
      "arbitrum": "",
      "arbitrumSepolia": "",
      "linea": "",
      "lineaSepolia": "",
      "zksync": "",
      "zksyncSepolia": ""
    },
    "pluginRepoRegistry": {
      "mainnet": "0x5B3B36BdC9470963A2734D6a0d2F6a64C21C159f",
      "sepolia": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "holesky": "0xB5146Fd572C669ABC353902e43F47fda4609E38A",
      "devSepolia": "0xf05128AaE416d6Dd5B1AcCAf18F3E5B1d489b3A4",
      "polygon": "0xA03C2182af8eC460D498108C92E8638a580b94d4",
      "mumbai": "0xc796bB1AfEBc56daDF6CAcD2aDa78055e5381971",
      "base": "0xB5eB5C011827C9F5787ceE3Abc72d247E36a5a0D",
      "baseSepolia": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "arbitrum": "0xCe0B4124dea6105bfB85fB4461c4D39f360E9ef3",
      "arbitrumSepolia": "0x35B62715459cB60bf6dC17fF8cfe138EA305E7Ee",
      "linea": "0xB2A2b32b9d885C85d5b229C0509341c37CaE7483",
      "lineaSepolia": "0x686890728f6BeD73EFD113b3Be267F498C1e20c5",
      "zksync": "0xEa26fC4028D9293f453804b40F097F11974FdB79",
      "zksyncSepolia": "0x22eE909B94c5FAeee67B7e187ca81E5A291A9EC0"
    },
    "pluginSetupProcessor": {
      "mainnet": "0xE978942c691e43f65c1B7c7F8f1dc8cDF061B13f",
      "sepolia": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
      "holesky": "0xCe0B4124dea6105bfB85fB4461c4D39f360E9ef3",
      "devSepolia": "0x9e99D11b513dD2cc5e117a5793412106502FF04B",
      "polygon": "0x879D9dfe3F36d7684BeC1a2bB4Aa8E8871A7245B",
      "mumbai": "0x9227b311C5cecB416707F1C8B7Ca1b52649AabEc",
      "base": "0x91a851E9Ed7F2c6d41b15F76e4a88f5A37067cC9",
      "baseSepolia": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
      "arbitrum": "0x308a1DC5020c4B5d992F5543a7236c465997fecB",
      "arbitrumSepolia": "0xC24188a73dc09aA7C721f96Ad8857B469C01dC9f",
      "linea": "0x8d6726Fe85Caa585d88FD8342ebEEE88d703E754",
      "lineaSepolia": "0x74a4b164008381637927282EAd471E73e6853Cac",
      "zksync": "0x8E3e98ECF5CdBF2bEcCD91d3BA580D472df5A0cB",
      "zksyncSepolia": "0xe2Ef39f1be2269644cBfa9b70003A143bF1fdf4d"
    }
}


### File: /home/errick/core/packages/contracts-ethers/rollup.config.ts ###
import json from '@rollup/plugin-json';
import typescript from '@rollup/plugin-typescript';
import dts from 'rollup-plugin-dts';

export default [
  {
    input: 'npm/index.ts',
    plugins: [typescript({project: './tsconfig.json'}), json()],
    output: [
      {
        file: 'dist/bundle-cjs.js',
        format: 'cjs',
      },
      {
        file: 'dist/bundle-esm.js',
        format: 'es',
      },
    ],
  },
  {
    input: 'npm/index.ts',
    plugins: [dts()],
    output: [
      {
        file: 'dist/bundle.d.ts',
        format: 'es',
      },
    ],
  },
];


### File: /home/errick/core/packages/contracts-ethers/tsconfig.json ###
{
  "compilerOptions": {
    "target": "es2018",
    "module": "esnext",
    "strict": true,
    "esModuleInterop": true,
    "outDir": "dist",
    "declaration": true,
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "rootDir": "../../"
  },
  "include": ["./npm", "/types"],
  "files": ["./npm/index.ts"]
}


### File: /home/errick/core/packages/contracts-ethers/package.json ###
{
  "name": "@aragon/osx-ethers",
  "version": "1.4.0",
  "description": "The Aragon OSx contract definitions for ethers.js",
  "main": "dist/bundle-cjs.js",
  "module": "dist/bundle-esm.js",
  "types": "dist/bundle.d.ts",
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "build:contracts": "cd ../contracts && yarn build",
    "build": "find ../contracts/artifacts/src/ ../contracts/artifacts/@ensdomains/ens-contracts/contracts/ -name '*.json' -type f | grep -v '.dbg.json' | xargs typechain --target=ethers-v5 --out-dir ./types",
    "build:npm": "rollup --config rollup.config.ts",
    "prepublishOnly": "yarn build:contracts && yarn build && yarn build:npm"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/aragon/osx.git"
  },
  "author": "",
  "license": "AGPL-3.0-or-later",
  "bugs": {
    "url": "https://github.com/aragon/osx/issues"
  },
  "homepage": "https://github.com/aragon/osx#readme",
  "devDependencies": {
    "@rollup/plugin-typescript": "^8.3.1",
    "@typechain/ethers-v5": "^10.0.0",
    "rollup": "^2.70.1",
    "rollup-plugin-dts": "^4.2.0",
    "typechain": "^8.0.0",
    "typescript": "^4.4.4"
  },
  "dependencies": {
    "ethers": "^5.6.2"
  }
}


### File: /home/errick/core/packages/contracts-ethers/npm/index.ts ###
export * from '../types/';
export * from './events/';
export * from './structs';


### File: /home/errick/core/packages/contracts-ethers/npm/events/index.ts ###
export * as DAOEvents from './DAO';
export * as DAORegistryEvents from './DAORegistry';
export * as PluginRepoEvents from './PluginRepo';
export * as PluginRepoRegistryEvents from './PluginRepoRegistry';
export * as PluginSetupProcessorEvents from './PluginSetupProcessor';


### File: /home/errick/core/packages/contracts-ethers/npm/events/DAO.ts ###
export {
  GrantedEvent,
  RevokedEvent,
  ExecutedEvent,
  UpgradedEvent,
  DepositedEvent,
  InitializedEvent,
  MetadataSetEvent,
  AdminChangedEvent,
  BeaconUpgradedEvent,
  CallbackReceivedEvent,
  TrustedForwarderSetEvent,
  NativeTokenDepositedEvent,
  StandardCallbackRegisteredEvent,
} from '../../types/src/core/dao/DAO';

export type EventName =
  | 'Granted'
  | 'Revoked'
  | 'Executed'
  | 'Upgraded'
  | 'Deposited'
  | 'Initialized'
  | 'MetadataSet'
  | 'AdminChanged'
  | 'BeaconUpgraded'
  | 'CallbackReceived'
  | 'TrustedForwarderSet'
  | 'NativeTokenDeposited'
  | 'SignatureValidatorSet'
  | 'StandardCallbackRegistered';


### File: /home/errick/core/packages/contracts-ethers/npm/events/PluginRepo.ts ###
export {
  GrantedEvent,
  RevokedEvent,
  UpgradedEvent,
  InitializedEvent,
  AdminChangedEvent,
  BeaconUpgradedEvent,
  VersionCreatedEvent,
  ReleaseMetadataUpdatedEvent,
} from '../../types/src/framework/plugin/repo/PluginRepo';

export type EventName =
  | 'Granted'
  | 'Revoked'
  | 'Upgraded'
  | 'Initialized'
  | 'AdminChanged'
  | 'BeaconUpgraded'
  | 'VersionCreated'
  | 'ReleaseMetadataUpdated';


### File: /home/errick/core/packages/contracts-ethers/npm/events/DAORegistry.ts ###
export {
  UpgradedEvent,
  AdminChangedEvent,
  BeaconUpgradedEvent,
  DAORegisteredEvent,
  InitializedEvent,
} from '../../types/src/framework/dao/DAORegistry';

export type EventName =
  | 'Upgraded'
  | 'AdminChanged'
  | 'BeaconUpgraded'
  | 'DAORegistered'
  | 'Initialized';


### File: /home/errick/core/packages/contracts-ethers/npm/events/PluginSetupProcessor.ts ###
export {
  UpdateAppliedEvent,
  UpdatePreparedEvent,
  InstallationAppliedEvent,
  InstallationPreparedEvent,
  UninstallationAppliedEvent,
  UninstallationPreparedEvent,
} from '../../types/src/framework/plugin/setup/PluginSetupProcessor';

export type EventName =
  | 'UpdateApplied'
  | 'UpdatePrepared'
  | 'InstallationApplied'
  | 'InstallationPrepared'
  | 'UninstallationApplied'
  | 'UninstallationPrepared';


### File: /home/errick/core/packages/contracts-ethers/npm/events/PluginRepoRegistry.ts ###
export {
  UpgradedEvent,
  InitializedEvent,
  AdminChangedEvent,
  BeaconUpgradedEvent,
  PluginRepoRegisteredEvent,
} from '../../types/src/framework/plugin/repo/PluginRepoRegistry';

export type EventName =
  | 'Upgraded'
  | 'Initialized'
  | 'AdminChanged'
  | 'BeaconUpgraded'
  | 'PluginRepoRegistered';


### File: /home/errick/core/packages/contracts-ethers/npm/structs/index.ts ###
export * as DAOStructs from './DAO';
export * as DAOFactoryStructs from './DAOFactory';
export * as PluginRepoStructs from './PluginRepo';
export * as PluginSetupProcessorStructs from './PluginSetupProcessor';


### File: /home/errick/core/packages/contracts-ethers/npm/structs/DAO.ts ###
import {PermissionLib} from '../../types/src/core/dao/DAO';

export {ActionStruct} from '../../types/src/core/dao/DAO';

export type MultiTargetPermissionStruct =
  PermissionLib.MultiTargetPermissionStruct;
export type SingleTargetPermissionStruct =
  PermissionLib.SingleTargetPermissionStruct;


### File: /home/errick/core/packages/contracts-ethers/npm/structs/PluginRepo.ts ###
import {PluginRepo} from '../../types/src/framework/plugin/repo/PluginRepo';

export type TagStruct = PluginRepo.TagStruct;
export type VersionStruct = PluginRepo.VersionStruct;


### File: /home/errick/core/packages/contracts-ethers/npm/structs/DAOFactory.ts ###
import {DAOFactory} from '../../types/src/framework/dao/DAOFactory';

export type DAOSettingsStruct = DAOFactory.DAOSettingsStruct;
export type PluginSettingsStruct = DAOFactory.PluginSettingsStruct;


### File: /home/errick/core/packages/contracts-ethers/npm/structs/PluginSetupProcessor.ts ###
import {
  PluginSetupProcessor,
  PluginSetupRefStruct as PluginSetupRefStruct_,
  PluginSetupRefStructOutput as PluginSetupRefStructOutput_,
} from '../../types/src/framework/plugin/setup/PluginSetupProcessor';

export type ApplyInstallationParamsStruct =
  PluginSetupProcessor.ApplyInstallationParamsStruct;

export type ApplyUninstallationParamsStruct =
  PluginSetupProcessor.ApplyUninstallationParamsStruct;

export type ApplyUpdateParamsStruct =
  PluginSetupProcessor.ApplyUpdateParamsStruct;

export type PrepareInstallationParamsStruct =
  PluginSetupProcessor.PrepareInstallationParamsStruct;
export type PrepareUninstallationParamsStruct =
  PluginSetupProcessor.PrepareUninstallationParamsStruct;

export type PrepareUpdateParamsStructOutput =
  PluginSetupProcessor.PrepareUpdateParamsStructOutput;

export type PluginSetupRefStruct = PluginSetupRefStruct_;

export type PluginSetupRefStructOutput = PluginSetupRefStructOutput_;


### File: /home/errick/core/packages/web-app/tsconfig.json ###
{
  "compilerOptions": {
    "target": "esnext",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react"
  },
  "include": ["src", "react-i18next.d.ts"],
  "exclude": ["node_modules"]
}


### File: /home/errick/core/packages/web-app/package.json ###
{
  "name": "aragonzaragoza-webapp",
  "description": "Webapp to interact with Zaragoza",
  "version": "0.1.0",
  "private": true,
  "author": "Aragon Association",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "serve": "vite preview",
    "test": "jest",
    "lint": "eslint src --max-warnings=0"
  },
  "dependencies": {
    "i18next": "^21.3.3",
    "react": "^17.0.2",
    "react-dom": "^17.0.2",
    "react-i18next": "^11.12.0",
    "styled-components": "^5.3.1"
  },
  "devDependencies": {
    "@babel/core": "^7.14.6",
    "@babel/preset-env": "^7.14.7",
    "@babel/preset-react": "^7.14.5",
    "@babel/preset-typescript": "^7.14.5",
    "@testing-library/jest-dom": "^5.14.1",
    "@testing-library/react": "^12.0.0",
    "@types/jest": "^26.0.24",
    "@types/node": "^16.3.2",
    "@types/react": "^17.0.14",
    "@types/react-dom": "^17.0.9",
    "@typescript-eslint/eslint-plugin": "^4.28.3",
    "@vitejs/plugin-react-refresh": "^1.3.5",
    "autoprefixer": "^10.3.1",
    "babel-jest": "^27.0.6",
    "eslint": "^7.30.0",
    "eslint-config-prettier": "^8.3.0",
    "eslint-plugin-prettier": "^3.4.0",
    "eslint-plugin-react": "^7.24.0",
    "eslint-plugin-react-hooks": "^4.2.0",
    "eslint-plugin-tailwindcss": "^1.14.1",
    "jest": "^27.0.6",
    "postcss": "^8.3.5",
    "prettier": "2.3.2",
    "react-test-renderer": "^17.0.2",
    "tailwindcss": "^2.2.4",
    "typescript": "^4.3.5",
    "vite": "^2.4.2"
  }
}


### File: /home/errick/core/packages/web-app/react-i18next.d.ts ###
import { resources, defaultNS } from './i18n.config';
// react-i18next versions lower than 11.11.0
declare module 'react-i18next' {
  type DefaultResources = typeof resources['en'];
  interface Resources extends DefaultResources {}
}
// react-i18next versions higher than 11.11.0
declare module 'react-i18next' {
  interface CustomTypeOptions {
    defaultNS: typeof defaultNS;
    resources: typeof resources['en'];
  };
};

### File: /home/errick/core/packages/web-app/i18n.config.ts ###
import i18n from 'i18next'
import en from './src/languages/en.json'
import { initReactI18next } from 'react-i18next'

export const resources = {
  en: {
    translation: en
  }
} as const

i18n.use(initReactI18next).init({
  lng: 'en',
  resources,
  interpolation: {
    escapeValue: false // react already safes from xss
  }
})


### File: /home/errick/core/packages/web-app/src/App.tsx ###
import React from 'react'
import styled from 'styled-components'
import { useTranslation } from 'react-i18next'
import '../i18n.config'

function App() {
  const { t } = useTranslation()
  return (
    <div className="bg-white">
      <div className="py-16 sm:py-24 px-4 sm:px-6 lg:px-8 mx-auto max-w-screen-xl">
        <div className="text-center">
          <WelcomeMessage>{t('subtitle')}</WelcomeMessage>
          <Title>{t('title.part1')}</Title>
          <Subtitle>{t('title.part2')}</Subtitle>
        </div>
      </div>
    </div>
  )
}

const WelcomeMessage = styled.h2.attrs({
  className: 'text-base font-semibold tracking-wide text-blue-600 uppercase'
})``
const Title = styled.p.attrs({
  className:
    'my-3 text-4xl sm:text-5xl lg:text-6xl font-bold sm:tracking-tight text-gray-900'
})``
const Subtitle = styled.p.attrs({
  className:
    'my-3 text-4xl sm:text-5xl lg:text-6xl font-bold sm:tracking-tight text-gray-900'
})``

export default App


### File: /home/errick/core/packages/web-app/src/languages/en.json ###
{
  "subtitle": "Welcome to",
  "title": {
    "part1": "Zaragoza",
    "part2": "The human centered Dao infrastructure."
  }
}


